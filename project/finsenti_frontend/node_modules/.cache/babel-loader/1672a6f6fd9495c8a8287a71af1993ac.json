{"ast":null,"code":"\"use strict\";\n\nvar _interopRequireDefault = require(\"@babel/runtime/helpers/interopRequireDefault\");\n\nObject.defineProperty(exports, \"__esModule\", {\n  value: true\n});\nexports.default = void 0;\n\nvar _underscore = _interopRequireDefault(require(\"underscore\"));\n\nvar _immutable = _interopRequireDefault(require(\"immutable\"));\n\nvar _moment = _interopRequireDefault(require(\"moment\"));\n\nvar _timerange = _interopRequireDefault(require(\"../timerange\"));\n\nvar _index = _interopRequireDefault(require(\"../index\"));\n/**\n *  Copyright (c) 2015-2017, The Regents of the University of California,\n *  through Lawrence Berkeley National Laboratory (subject to receipt\n *  of any required approvals from the U.S. Dept. of Energy).\n *  All rights reserved.\n *\n *  This source code is licensed under the BSD-style license found in the\n *  LICENSE file in the root directory of this source tree.\n */\n\n\nvar units = {\n  s: {\n    label: \"seconds\",\n    length: 1\n  },\n  m: {\n    label: \"minutes\",\n    length: 60\n  },\n  h: {\n    label: \"hours\",\n    length: 60 * 60\n  },\n  d: {\n    label: \"days\",\n    length: 60 * 60 * 24\n  }\n};\n/**\n * This function will take an index, which may be of two forms:\n *     2015-07-14  (day)\n *     2015-07     (month)\n *     2015        (year)\n * or:\n *     1d-278      (range, in n x days, hours, minutes or seconds)\n *\n * and return a TimeRange for that time. The TimeRange may be considered to be\n * local time or UTC time, depending on the utc flag passed in.\n */\n\nvar _default = {\n  /**\n   * Single zero left padding, for days and months.\n   */\n  leftPad(value) {\n    return \"\".concat(value < 10 ? \"0\" : \"\").concat(value);\n  },\n\n  /**\n   * Returns a duration in milliseconds given a window duration string.\n   * For example \"30s\" (30 seconds) should return 30000ms. Accepts\n   * seconds (e.g. \"30s\"), minutes (e.g. \"5m\"), hours (e.g. \"6h\") and\n   * days (e.g. \"30d\")\n   */\n  windowDuration(w) {\n    // window should be two parts, a number and a letter if it's a\n    // range based index, e.g \"1h\".\n    var regex = /([0-9]+)([smhd])/;\n    var parts = regex.exec(w);\n\n    if (parts && parts.length >= 3) {\n      var num = parseInt(parts[1], 10);\n      var unit = parts[2];\n      return num * units[unit].length * 1000;\n    }\n  },\n\n  windowPositionFromDate(w, date) {\n    var duration = this.windowDuration(w);\n\n    var dd = _moment.default.utc(date).valueOf();\n\n    return parseInt(dd /= duration, 10);\n  },\n\n  rangeFromIndexString(index, utc) {\n    var isUTC = !_underscore.default.isUndefined(utc) ? utc : true;\n    var parts = index.split(\"-\");\n    var beginTime;\n    var endTime;\n\n    switch (parts.length) {\n      case 3:\n        // A day, month and year e.g. 2014-10-24\n        if (!_underscore.default.isNaN(parseInt(parts[0], 10)) && !_underscore.default.isNaN(parseInt(parts[1], 10)) && !_underscore.default.isNaN(parseInt(parts[2], 10))) {\n          var _year = parseInt(parts[0], 10);\n\n          var month = parseInt(parts[1], 10);\n          var day = parseInt(parts[2], 10);\n          beginTime = isUTC ? _moment.default.utc([_year, month - 1, day]) : (0, _moment.default)([_year, month - 1, day]);\n          endTime = isUTC ? _moment.default.utc(beginTime).endOf(\"day\") : (0, _moment.default)(beginTime).endOf(\"day\");\n        }\n\n        break;\n\n      case 2:\n        // Size should be two parts, a number and a letter if it's a\n        // range based index, e.g 1h-23478\n        var rangeRegex = /([0-9]+)([smhd])/;\n        var sizeParts = rangeRegex.exec(parts[0]);\n\n        if (sizeParts && sizeParts.length >= 3 && !_underscore.default.isNaN(parseInt(parts[1], 10))) {\n          var pos = parseInt(parts[1], 10);\n          var num = parseInt(sizeParts[1], 10);\n          var unit = sizeParts[2];\n          var length = num * units[unit].length * 1000;\n          beginTime = isUTC ? _moment.default.utc(pos * length) : (0, _moment.default)(pos * length);\n          endTime = isUTC ? _moment.default.utc((pos + 1) * length) : (0, _moment.default)((pos + 1) * length); // A month and year e.g 2015-09\n        } else if (!_underscore.default.isNaN(parseInt(parts[0], 10)) && !_underscore.default.isNaN(parseInt(parts[1], 10))) {\n          var _year2 = parseInt(parts[0], 10);\n\n          var _month = parseInt(parts[1], 10);\n\n          beginTime = isUTC ? _moment.default.utc([_year2, _month - 1]) : (0, _moment.default)([_year2, _month - 1]);\n          endTime = isUTC ? _moment.default.utc(beginTime).endOf(\"month\") : (0, _moment.default)(beginTime).endOf(\"month\");\n        }\n\n        break;\n      // A year e.g. 2015\n\n      case 1:\n        var year = parts[0];\n        beginTime = isUTC ? _moment.default.utc([year]) : (0, _moment.default)([year]);\n        endTime = isUTC ? _moment.default.utc(beginTime).endOf(\"year\") : (0, _moment.default)(beginTime).endOf(\"year\");\n        break;\n    }\n\n    if (beginTime && beginTime.isValid() && endTime && endTime.isValid()) {\n      return new _timerange.default(beginTime, endTime);\n    } else {\n      return undefined;\n    }\n  },\n\n  /**\n   * Returns a nice string for the index. If the index is of the form\n   * 1d-2345 then just that string is returned (there's not nice way to put\n   * it), but if it represents a day, month, or year (e.g. 2015-07) then a\n   * nice string like \"July\" will be returned. It's also possible to pass in\n   * the format of the reply for these types of strings. See moment's format\n   * naming conventions:\n   * http://momentjs.com/docs/#/displaying/format/\n   */\n  niceIndexString(index, format) {\n    var t;\n    var parts = index.split(\"-\");\n\n    switch (parts.length) {\n      case 3:\n        if (!_underscore.default.isNaN(parseInt(parts[0], 10)) && !_underscore.default.isNaN(parseInt(parts[1], 10)) && !_underscore.default.isNaN(parseInt(parts[2], 10))) {\n          var _year3 = parseInt(parts[0], 10);\n\n          var month = parseInt(parts[1], 10);\n          var day = parseInt(parts[2], 10);\n          t = _moment.default.utc([_year3, month - 1, day]);\n\n          if (format) {\n            return t.format(format);\n          } else {\n            return t.format(\"MMMM Do YYYY\");\n          }\n        }\n\n        break;\n\n      case 2:\n        var rangeRegex = /([0-9]+)([smhd])/;\n        var sizeParts = rangeRegex.exec(parts[0]);\n\n        if (sizeParts && sizeParts.length >= 3 && !_underscore.default.isNaN(parseInt(parts[1], 10))) {\n          return index;\n        } else if (!_underscore.default.isNaN(parseInt(parts[0], 10)) && !_underscore.default.isNaN(parseInt(parts[1], 10))) {\n          var _year4 = parseInt(parts[0], 10);\n\n          var _month2 = parseInt(parts[1], 10);\n\n          t = _moment.default.utc([_year4, _month2 - 1]);\n\n          if (format) {\n            return t.format(format);\n          } else {\n            return t.format(\"MMMM\");\n          }\n        }\n\n        break;\n\n      case 1:\n        var year = parts[0];\n        t = _moment.default.utc([year]);\n\n        if (format) {\n          return t.format(format);\n        } else {\n          return t.format(\"YYYY\");\n        }\n\n        break;\n    }\n\n    return index;\n  },\n\n  isMissing(val) {\n    return _underscore.default.isNull(val) || _underscore.default.isUndefined(val) || _underscore.default.isNaN(val);\n  },\n\n  /**\n   * Split the field spec if it is not already a list.\n   *\n   * Also, allow for deep fields to be passed in as a tuple because\n   * it will need to be used as a dict key in some of the processor\n   * Options.\n   *\n   * This is deployed in Event.get() to process anything passed\n   * to it, but this should also be deployed \"upstream\" to avoid\n   * having that split() done over and over in a loop.\n   */\n  fieldPathToArray(fieldSpec) {\n    if (_underscore.default.isArray(fieldSpec) || _underscore.default.isFunction(fieldSpec)) {\n      return fieldSpec;\n    } else if (_underscore.default.isString(fieldSpec)) {\n      return fieldSpec.split(\".\");\n    } else if (_underscore.default.isUndefined(fieldSpec)) {\n      return [\"value\"];\n    }\n  },\n\n  /**\n   * Generate a list of all possible field paths in an object. This is\n   * for to determine all deep paths when none is given.\n   */\n  generatePaths(newData) {\n    var paths = [];\n\n    function* recurse(data) {\n      var keys = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : [];\n\n      if (_underscore.default.isObject(data)) {\n        for (var key of Object.keys(data)) {\n          for (var path of recurse(data[key], [...keys, key])) {\n            yield path;\n          }\n        }\n      } else {\n        yield keys;\n      }\n    }\n\n    for (var key of recurse(newData)) {\n      paths.push(key);\n    }\n\n    return paths;\n  },\n\n  //\n  // Functions to turn constructor args\n  // into other stuff\n  //\n  timestampFromArg(arg) {\n    if (_underscore.default.isNumber(arg)) {\n      return new Date(arg);\n    } else if (_underscore.default.isString(arg)) {\n      return new Date(+arg);\n    } else if (_underscore.default.isDate(arg)) {\n      return new Date(arg.getTime());\n    } else if (_moment.default.isMoment(arg)) {\n      return new Date(arg.valueOf());\n    } else {\n      throw new Error(\"Unable to get timestamp from \".concat(arg, \". Should be a number, date, or moment.\"));\n    }\n  },\n\n  timeRangeFromArg(arg) {\n    if (arg instanceof _timerange.default) {\n      return arg;\n    } else if (_underscore.default.isString(arg)) {\n      var [begin, end] = arg.split(\",\");\n      return new _timerange.default([+begin, +end]);\n    } else if (_underscore.default.isArray(arg) && arg.length === 2) {\n      return new _timerange.default(arg);\n    } else {\n      throw new Error(\"Unable to parse timerange. Should be a TimeRange. Got \".concat(arg, \".\"));\n    }\n  },\n\n  indexFromArgs(arg1) {\n    var arg2 = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : true;\n\n    if (_underscore.default.isString(arg1)) {\n      return new _index.default(arg1, arg2);\n    } else if (arg1 instanceof _index.default) {\n      return arg1;\n    } else {\n      throw new Error(\"Unable to get index from \".concat(arg1, \". Should be a string or Index.\"));\n    }\n  },\n\n  dataFromArg(arg) {\n    var data;\n\n    if (_underscore.default.isObject(arg)) {\n      // Deeply convert the data to Immutable Map\n      data = new _immutable.default.fromJS(arg);\n    } else if (data instanceof _immutable.default.Map) {\n      // Copy reference to the data\n      data = arg;\n    } else if (_underscore.default.isNumber(arg) || _underscore.default.isString(arg)) {\n      // Just add it to the value key of a new Map\n      // e.g. new Event(t, 25); -> t, {value: 25}\n      data = new _immutable.default.Map({\n        value: arg\n      });\n    } else {\n      throw new Error(\"Unable to interpret event data from \".concat(arg, \".\"));\n    }\n\n    return data;\n  }\n\n};\nexports.default = _default;","map":{"version":3,"sources":["/Users/nicholasraffone/Documents/swefall2021/finalproj/FinancialSentiment/fin_sentiment_front/node_modules/pondjs/lib/lib/base/util.js"],"names":["_interopRequireDefault","require","Object","defineProperty","exports","value","default","_underscore","_immutable","_moment","_timerange","_index","units","s","label","length","m","h","d","_default","leftPad","concat","windowDuration","w","regex","parts","exec","num","parseInt","unit","windowPositionFromDate","date","duration","dd","utc","valueOf","rangeFromIndexString","index","isUTC","isUndefined","split","beginTime","endTime","isNaN","_year","month","day","endOf","rangeRegex","sizeParts","pos","_year2","_month","year","isValid","undefined","niceIndexString","format","t","_year3","_year4","_month2","isMissing","val","isNull","fieldPathToArray","fieldSpec","isArray","isFunction","isString","generatePaths","newData","paths","recurse","data","keys","arguments","isObject","key","path","push","timestampFromArg","arg","isNumber","Date","isDate","getTime","isMoment","Error","timeRangeFromArg","begin","end","indexFromArgs","arg1","arg2","dataFromArg","fromJS","Map"],"mappings":"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","sourcesContent":["\"use strict\";\n\nvar _interopRequireDefault = require(\"@babel/runtime/helpers/interopRequireDefault\");\n\nObject.defineProperty(exports, \"__esModule\", {\n  value: true\n});\nexports.default = void 0;\n\nvar _underscore = _interopRequireDefault(require(\"underscore\"));\n\nvar _immutable = _interopRequireDefault(require(\"immutable\"));\n\nvar _moment = _interopRequireDefault(require(\"moment\"));\n\nvar _timerange = _interopRequireDefault(require(\"../timerange\"));\n\nvar _index = _interopRequireDefault(require(\"../index\"));\n\n/**\n *  Copyright (c) 2015-2017, The Regents of the University of California,\n *  through Lawrence Berkeley National Laboratory (subject to receipt\n *  of any required approvals from the U.S. Dept. of Energy).\n *  All rights reserved.\n *\n *  This source code is licensed under the BSD-style license found in the\n *  LICENSE file in the root directory of this source tree.\n */\nvar units = {\n  s: {\n    label: \"seconds\",\n    length: 1\n  },\n  m: {\n    label: \"minutes\",\n    length: 60\n  },\n  h: {\n    label: \"hours\",\n    length: 60 * 60\n  },\n  d: {\n    label: \"days\",\n    length: 60 * 60 * 24\n  }\n};\n/**\n * This function will take an index, which may be of two forms:\n *     2015-07-14  (day)\n *     2015-07     (month)\n *     2015        (year)\n * or:\n *     1d-278      (range, in n x days, hours, minutes or seconds)\n *\n * and return a TimeRange for that time. The TimeRange may be considered to be\n * local time or UTC time, depending on the utc flag passed in.\n */\n\nvar _default = {\n  /**\n   * Single zero left padding, for days and months.\n   */\n  leftPad(value) {\n    return \"\".concat(value < 10 ? \"0\" : \"\").concat(value);\n  },\n\n  /**\n   * Returns a duration in milliseconds given a window duration string.\n   * For example \"30s\" (30 seconds) should return 30000ms. Accepts\n   * seconds (e.g. \"30s\"), minutes (e.g. \"5m\"), hours (e.g. \"6h\") and\n   * days (e.g. \"30d\")\n   */\n  windowDuration(w) {\n    // window should be two parts, a number and a letter if it's a\n    // range based index, e.g \"1h\".\n    var regex = /([0-9]+)([smhd])/;\n    var parts = regex.exec(w);\n\n    if (parts && parts.length >= 3) {\n      var num = parseInt(parts[1], 10);\n      var unit = parts[2];\n      return num * units[unit].length * 1000;\n    }\n  },\n\n  windowPositionFromDate(w, date) {\n    var duration = this.windowDuration(w);\n\n    var dd = _moment.default.utc(date).valueOf();\n\n    return parseInt(dd /= duration, 10);\n  },\n\n  rangeFromIndexString(index, utc) {\n    var isUTC = !_underscore.default.isUndefined(utc) ? utc : true;\n    var parts = index.split(\"-\");\n    var beginTime;\n    var endTime;\n\n    switch (parts.length) {\n      case 3:\n        // A day, month and year e.g. 2014-10-24\n        if (!_underscore.default.isNaN(parseInt(parts[0], 10)) && !_underscore.default.isNaN(parseInt(parts[1], 10)) && !_underscore.default.isNaN(parseInt(parts[2], 10))) {\n          var _year = parseInt(parts[0], 10);\n\n          var month = parseInt(parts[1], 10);\n          var day = parseInt(parts[2], 10);\n          beginTime = isUTC ? _moment.default.utc([_year, month - 1, day]) : (0, _moment.default)([_year, month - 1, day]);\n          endTime = isUTC ? _moment.default.utc(beginTime).endOf(\"day\") : (0, _moment.default)(beginTime).endOf(\"day\");\n        }\n\n        break;\n\n      case 2:\n        // Size should be two parts, a number and a letter if it's a\n        // range based index, e.g 1h-23478\n        var rangeRegex = /([0-9]+)([smhd])/;\n        var sizeParts = rangeRegex.exec(parts[0]);\n\n        if (sizeParts && sizeParts.length >= 3 && !_underscore.default.isNaN(parseInt(parts[1], 10))) {\n          var pos = parseInt(parts[1], 10);\n          var num = parseInt(sizeParts[1], 10);\n          var unit = sizeParts[2];\n          var length = num * units[unit].length * 1000;\n          beginTime = isUTC ? _moment.default.utc(pos * length) : (0, _moment.default)(pos * length);\n          endTime = isUTC ? _moment.default.utc((pos + 1) * length) : (0, _moment.default)((pos + 1) * length); // A month and year e.g 2015-09\n        } else if (!_underscore.default.isNaN(parseInt(parts[0], 10)) && !_underscore.default.isNaN(parseInt(parts[1], 10))) {\n          var _year2 = parseInt(parts[0], 10);\n\n          var _month = parseInt(parts[1], 10);\n\n          beginTime = isUTC ? _moment.default.utc([_year2, _month - 1]) : (0, _moment.default)([_year2, _month - 1]);\n          endTime = isUTC ? _moment.default.utc(beginTime).endOf(\"month\") : (0, _moment.default)(beginTime).endOf(\"month\");\n        }\n\n        break;\n      // A year e.g. 2015\n\n      case 1:\n        var year = parts[0];\n        beginTime = isUTC ? _moment.default.utc([year]) : (0, _moment.default)([year]);\n        endTime = isUTC ? _moment.default.utc(beginTime).endOf(\"year\") : (0, _moment.default)(beginTime).endOf(\"year\");\n        break;\n    }\n\n    if (beginTime && beginTime.isValid() && endTime && endTime.isValid()) {\n      return new _timerange.default(beginTime, endTime);\n    } else {\n      return undefined;\n    }\n  },\n\n  /**\n   * Returns a nice string for the index. If the index is of the form\n   * 1d-2345 then just that string is returned (there's not nice way to put\n   * it), but if it represents a day, month, or year (e.g. 2015-07) then a\n   * nice string like \"July\" will be returned. It's also possible to pass in\n   * the format of the reply for these types of strings. See moment's format\n   * naming conventions:\n   * http://momentjs.com/docs/#/displaying/format/\n   */\n  niceIndexString(index, format) {\n    var t;\n    var parts = index.split(\"-\");\n\n    switch (parts.length) {\n      case 3:\n        if (!_underscore.default.isNaN(parseInt(parts[0], 10)) && !_underscore.default.isNaN(parseInt(parts[1], 10)) && !_underscore.default.isNaN(parseInt(parts[2], 10))) {\n          var _year3 = parseInt(parts[0], 10);\n\n          var month = parseInt(parts[1], 10);\n          var day = parseInt(parts[2], 10);\n          t = _moment.default.utc([_year3, month - 1, day]);\n\n          if (format) {\n            return t.format(format);\n          } else {\n            return t.format(\"MMMM Do YYYY\");\n          }\n        }\n\n        break;\n\n      case 2:\n        var rangeRegex = /([0-9]+)([smhd])/;\n        var sizeParts = rangeRegex.exec(parts[0]);\n\n        if (sizeParts && sizeParts.length >= 3 && !_underscore.default.isNaN(parseInt(parts[1], 10))) {\n          return index;\n        } else if (!_underscore.default.isNaN(parseInt(parts[0], 10)) && !_underscore.default.isNaN(parseInt(parts[1], 10))) {\n          var _year4 = parseInt(parts[0], 10);\n\n          var _month2 = parseInt(parts[1], 10);\n\n          t = _moment.default.utc([_year4, _month2 - 1]);\n\n          if (format) {\n            return t.format(format);\n          } else {\n            return t.format(\"MMMM\");\n          }\n        }\n\n        break;\n\n      case 1:\n        var year = parts[0];\n        t = _moment.default.utc([year]);\n\n        if (format) {\n          return t.format(format);\n        } else {\n          return t.format(\"YYYY\");\n        }\n\n        break;\n    }\n\n    return index;\n  },\n\n  isMissing(val) {\n    return _underscore.default.isNull(val) || _underscore.default.isUndefined(val) || _underscore.default.isNaN(val);\n  },\n\n  /**\n   * Split the field spec if it is not already a list.\n   *\n   * Also, allow for deep fields to be passed in as a tuple because\n   * it will need to be used as a dict key in some of the processor\n   * Options.\n   *\n   * This is deployed in Event.get() to process anything passed\n   * to it, but this should also be deployed \"upstream\" to avoid\n   * having that split() done over and over in a loop.\n   */\n  fieldPathToArray(fieldSpec) {\n    if (_underscore.default.isArray(fieldSpec) || _underscore.default.isFunction(fieldSpec)) {\n      return fieldSpec;\n    } else if (_underscore.default.isString(fieldSpec)) {\n      return fieldSpec.split(\".\");\n    } else if (_underscore.default.isUndefined(fieldSpec)) {\n      return [\"value\"];\n    }\n  },\n\n  /**\n   * Generate a list of all possible field paths in an object. This is\n   * for to determine all deep paths when none is given.\n   */\n  generatePaths(newData) {\n    var paths = [];\n\n    function* recurse(data) {\n      var keys = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : [];\n\n      if (_underscore.default.isObject(data)) {\n        for (var key of Object.keys(data)) {\n          for (var path of recurse(data[key], [...keys, key])) {\n            yield path;\n          }\n        }\n      } else {\n        yield keys;\n      }\n    }\n\n    for (var key of recurse(newData)) {\n      paths.push(key);\n    }\n\n    return paths;\n  },\n\n  //\n  // Functions to turn constructor args\n  // into other stuff\n  //\n  timestampFromArg(arg) {\n    if (_underscore.default.isNumber(arg)) {\n      return new Date(arg);\n    } else if (_underscore.default.isString(arg)) {\n      return new Date(+arg);\n    } else if (_underscore.default.isDate(arg)) {\n      return new Date(arg.getTime());\n    } else if (_moment.default.isMoment(arg)) {\n      return new Date(arg.valueOf());\n    } else {\n      throw new Error(\"Unable to get timestamp from \".concat(arg, \". Should be a number, date, or moment.\"));\n    }\n  },\n\n  timeRangeFromArg(arg) {\n    if (arg instanceof _timerange.default) {\n      return arg;\n    } else if (_underscore.default.isString(arg)) {\n      var [begin, end] = arg.split(\",\");\n      return new _timerange.default([+begin, +end]);\n    } else if (_underscore.default.isArray(arg) && arg.length === 2) {\n      return new _timerange.default(arg);\n    } else {\n      throw new Error(\"Unable to parse timerange. Should be a TimeRange. Got \".concat(arg, \".\"));\n    }\n  },\n\n  indexFromArgs(arg1) {\n    var arg2 = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : true;\n\n    if (_underscore.default.isString(arg1)) {\n      return new _index.default(arg1, arg2);\n    } else if (arg1 instanceof _index.default) {\n      return arg1;\n    } else {\n      throw new Error(\"Unable to get index from \".concat(arg1, \". Should be a string or Index.\"));\n    }\n  },\n\n  dataFromArg(arg) {\n    var data;\n\n    if (_underscore.default.isObject(arg)) {\n      // Deeply convert the data to Immutable Map\n      data = new _immutable.default.fromJS(arg);\n    } else if (data instanceof _immutable.default.Map) {\n      // Copy reference to the data\n      data = arg;\n    } else if (_underscore.default.isNumber(arg) || _underscore.default.isString(arg)) {\n      // Just add it to the value key of a new Map\n      // e.g. new Event(t, 25); -> t, {value: 25}\n      data = new _immutable.default.Map({\n        value: arg\n      });\n    } else {\n      throw new Error(\"Unable to interpret event data from \".concat(arg, \".\"));\n    }\n\n    return data;\n  }\n\n};\nexports.default = _default;"]},"metadata":{},"sourceType":"script"}