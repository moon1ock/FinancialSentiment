{"ast":null,"code":"\"use strict\";\n\nvar _interopRequireDefault = require(\"@babel/runtime/helpers/interopRequireDefault\");\n\nObject.defineProperty(exports, \"__esModule\", {\n  value: true\n});\nexports.keep = keep;\nexports.sum = sum;\nexports.avg = avg;\nexports.max = max;\nexports.min = min;\nexports.count = count;\nexports.first = first;\nexports.last = last;\nexports.difference = difference;\nexports.median = median;\nexports.stdev = stdev;\nexports.percentile = percentile;\nexports.filter = void 0;\n\nvar _underscore = _interopRequireDefault(require(\"underscore\"));\n/**\n *  Copyright (c) 2015-2017, The Regents of the University of California,\n *  through Lawrence Berkeley National Laboratory (subject to receipt\n *  of any required approvals from the U.S. Dept. of Energy).\n *  All rights reserved.\n *\n *  This source code is licensed under the BSD-style license found in the\n *  LICENSE file in the root directory of this source tree.\n */\n\n\nfunction isValid(v) {\n  return !(_underscore.default.isUndefined(v) || _underscore.default.isNaN(v) || _underscore.default.isNull(v));\n} //\n// Functions to process missing values out of a value list\n//\n\n/**\n * Default filter, so default it does nothing at all to the values passed to it\n * e.g. max(1, 2, null, 4) would be max(1, 2, null, 4)\n */\n\n\nvar keepMissing = values => values;\n/**\n * Removes missing values (null, undefined or NaN) from the list of\n * values passed into the aggregation function \n * e.g. avg(1, 2, null, 4) would be avg(1, 2, 4)\n */\n\n\nvar ignoreMissing = values => values.filter(isValid);\n/**\n * Replaces missing values (null, undefined or NaN) by 0.\n * e.g. avg(1, 2, null, 4) would be avg(1, 2, 0, 4)\n */\n\n\nvar zeroMissing = values => values.map(v => isValid(v) ? v : 0);\n/**\n * If there are missing values in the list of values being\n * aggregated then the result of the aggregation should be\n * also undefined or null.\n * e.g. avg(2, 4, null, 7) would be null.\n */\n\n\nvar propagateMissing = values => ignoreMissing(values).length === values.length ? values : null;\n/**\n * If there are no values in the list, the result of the aggregation\n * is null \n */\n\n\nvar noneIfEmpty = values => values.length === 0 ? null : values;\n\nvar filter = {\n  keepMissing,\n  ignoreMissing,\n  zeroMissing,\n  propagateMissing,\n  noneIfEmpty\n};\n/**\n * Like first() except it will return null if not all the values are\n * the same. This can be used to transfer a value when doing aggregation.\n * For instance you might group by the 'type', then avg the 'value', but\n * you want to results to include the type. So you would 'keep' the type\n * and 'avg' the value.\n */\n\nexports.filter = filter;\n\nfunction keep() {\n  var clean = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : filter.ignoreMissing;\n  return values => {\n    var cleanValues = clean(values);\n    if (!cleanValues) return null;\n    var result = first()(cleanValues);\n    cleanValues.forEach(v => {\n      if (v !== result) {\n        return null;\n      }\n    });\n    return result;\n  };\n}\n/**\n * Returns a sum function.\n *\n * Optionally you can specify the method by which unclean values\n * are treated. The default is to exclude missing values from\n * the sum calculation. Other possibilities are:\n *     `propergateMissing` - which will cause the min itself to\n *     be null if the values contain a missing value\n *     `zeroMissing` - will replace missing values with a zero\n */\n\n\nfunction sum() {\n  var clean = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : filter.ignoreMissing;\n  return values => {\n    var cleanValues = clean(values);\n    if (!cleanValues) return null;\n    return _underscore.default.reduce(cleanValues, (a, b) => a + b, 0);\n  };\n}\n/**\n * Returns a avg function.\n *\n * Optionally you can specify the method by which unclean values\n * are treated. The default is to exclude missing values from\n * the average calculation. Other possibilities are:\n *     `propergateMissing` - which will cause the avg itself to\n *     be null if the values contain a missing value\n *     `zeroMissing` - will replace missing values with a zero\n */\n\n\nfunction avg() {\n  var clean = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : filter.ignoreMissing;\n  return values => {\n    var cleanValues = clean(values);\n    if (!cleanValues) return null;\n\n    var sum = _underscore.default.reduce(cleanValues, (a, b) => {\n      return a + b;\n    }, 0);\n\n    return sum / cleanValues.length;\n  };\n}\n/**\n * Return a max function.\n *\n * Optionally you can specify the method by which unclean values\n * are treated. The default is to exclude missing values from\n * the maximum search. Other possibilities are:\n *     `propergateMissing` - which will cause the max itself to\n *     be null if the values contain a missing value\n *     `zeroMissing` - will replace missing values with a zero\n */\n\n\nfunction max() {\n  var clean = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : filter.ignoreMissing;\n  return values => {\n    var cleanValues = clean(values);\n    if (!cleanValues) return null;\n\n    var max = _underscore.default.max(cleanValues);\n\n    if (_underscore.default.isFinite(max)) {\n      return max;\n    }\n  };\n}\n/**\n * Return a min function.\n *\n * Optionally you can specify the method by which unclean values\n * are treated. The default is to exclude missing values from\n * the minimum search. Other possibilities are:\n *     `propergateMissing` - which will cause the min itself to\n *     be null if the values contain a missing value\n *     `zeroMissing` - will replace missing values with a zero\n */\n\n\nfunction min() {\n  var clean = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : filter.ignoreMissing;\n  return values => {\n    var cleanValues = clean(values);\n    if (!cleanValues) return null;\n\n    var min = _underscore.default.min(cleanValues);\n\n    if (_underscore.default.isFinite(min)) {\n      return min;\n    }\n  };\n}\n/**\n * Returns a count() function.\n *\n * Optionally you can specify the method by which unclean values\n * are treated. The default is to exclude missing values from\n * the count. Other possibilities are:\n *     `propergateMissing` - which will cause the count itself to\n *     be null if the values contain a missing value\n */\n\n\nfunction count() {\n  var clean = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : filter.ignoreMissing;\n  return values => {\n    var cleanValues = clean(values);\n    if (!cleanValues) return null;\n    return cleanValues.length;\n  };\n}\n/**\n * Returns a first() function, i.e. a function that returns the first\n * value in the supplied values list.\n *\n * Optionally you can specify the method by which unclean values\n * are treated. The default is to exclude missing values from\n * the list, i.e to find the first non-missing value. Other\n * possibilities are:\n *     `keepMissing` - to return the first value, regardless of if\n *     it is a missing value or not.\n */\n\n\nfunction first() {\n  var clean = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : filter.ignoreMissing;\n  return values => {\n    var cleanValues = clean(values);\n    if (!cleanValues) return null;\n    return cleanValues.length ? cleanValues[0] : undefined;\n  };\n}\n/**\n * Returns a last() function, i.e. a function that returns the list\n * value in the supplied values list.\n *\n * Optionally you can specify the method by which unclean values\n * are treated. The default is to exclude missing values from\n * the list, i.e to find the last non-missing value. Other\n * possibilities are:\n *     `keepMissing` - to return the last value, regardless of if\n *     it is a missing value or not.\n */\n\n\nfunction last() {\n  var clean = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : filter.ignoreMissing;\n  return values => {\n    var cleanValues = clean(values);\n    if (!cleanValues) return null;\n    return cleanValues.length ? cleanValues[cleanValues.length - 1] : undefined;\n  };\n}\n/**\n * Returns a difference() function, i.e. a function that returns\n * the difference between the min and max values.\n *\n * Optionally you can specify the method by which unclean values\n * are treated. The default is to exclude missing values from\n * the list, i.e to find the last non-missing value. Other\n * possibilities are:\n *     `propergateMissing` - which will cause the min itself to\n *     be null if the values contain a missing value\n *     `zeroMissing` - will replace missing values with a zero\n */\n\n\nfunction difference() {\n  var clean = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : filter.ignoreMissing;\n  return values => {\n    var cleanValues = clean(values);\n    if (!cleanValues) return null;\n    return _underscore.default.max(cleanValues) - _underscore.default.min(cleanValues);\n  };\n}\n\nfunction median() {\n  var clean = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : filter.ignoreMissing;\n  return values => {\n    var cleanValues = clean(values);\n    if (!cleanValues) return null;\n    var sorted = cleanValues.sort();\n    var i = Math.floor(sorted.length / 2);\n\n    if (sorted.length % 2 === 0) {\n      var a = sorted[i];\n      var b = sorted[i - 1];\n      return (a + b) / 2;\n    } else {\n      return sorted[i];\n    }\n  };\n}\n\nfunction stdev() {\n  var clean = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : filter.ignoreMissing;\n  return values => {\n    var cleanValues = clean(values);\n    if (!cleanValues) return null;\n    var sums = 0;\n    var mean = avg(clean)(cleanValues);\n    cleanValues.forEach(v => sums += Math.pow(v - mean, 2));\n    return Math.sqrt(sums / values.length);\n  };\n}\n/**\n * Returns a percentile function within the a values list.\n *\n * @param  {object}  options  The parameters controlling the function:\n *                             * q        The percentile (should be between 0 and 100)\n *                             * interp   Specifies the interpolation method\n *                                        to use when the desired quantile lies between\n *                                        two data points. Options are:\n *                                          * linear: i + (j - i) * fraction, where fraction is the fractional part of the index surrounded by i and j.\n *                                          * lower: i.\n *                                          * higher: j.\n *                                          * nearest: i or j whichever is nearest.\n *                                          * midpoint: (i + j) / 2.\n *                             * clean    Strategy to use when encountering missing data:\n *                                          * `propergateMissing` - which will cause the min\n *                                             itself to be null if the values contain a\n *                                             missing value\n *                                          * `zeroMissing` - will replace missing values\n *                                             with a zero\n * @return {number}            The percentile\n */\n\n\nfunction percentile(q) {\n  var interp = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : \"linear\";\n  var clean = arguments.length > 2 && arguments[2] !== undefined ? arguments[2] : filter.ignoreMissing;\n  return values => {\n    var cleanValues = clean(values);\n    if (!cleanValues) return null;\n    var v;\n    var sorted = cleanValues.slice().sort((a, b) => a - b);\n    var size = sorted.length;\n\n    if (q < 0 || q > 100) {\n      throw new Error(\"Percentile q must be between 0 and 100\");\n    }\n\n    var i = q / 100;\n    var index = Math.floor((sorted.length - 1) * i);\n\n    if (size === 1 || q === 0) {\n      return sorted[0];\n    }\n\n    if (q === 100) {\n      return sorted[size - 1];\n    }\n\n    if (index < size - 1) {\n      var fraction = (size - 1) * i - index;\n      var v0 = sorted[index];\n      var v1 = sorted[index + 1];\n\n      if (interp === \"lower\" || fraction === 0) {\n        v = v0;\n      } else if (interp === \"linear\") {\n        v = v0 + (v1 - v0) * fraction;\n      } else if (interp === \"higher\") {\n        v = v1;\n      } else if (interp === \"nearest\") {\n        v = fraction < 0.5 ? v0 : v1;\n      } else if (interp === \"midpoint\") {\n        v = (v0 + v1) / 2;\n      }\n    }\n\n    return v;\n  };\n}","map":{"version":3,"sources":["/Users/nicholasraffone/Documents/swefall2021/finalproj/FinancialSentiment/fin_sentiment_front/node_modules/pondjs/lib/lib/base/functions.js"],"names":["_interopRequireDefault","require","Object","defineProperty","exports","value","keep","sum","avg","max","min","count","first","last","difference","median","stdev","percentile","filter","_underscore","isValid","v","default","isUndefined","isNaN","isNull","keepMissing","values","ignoreMissing","zeroMissing","map","propagateMissing","length","noneIfEmpty","clean","arguments","undefined","cleanValues","result","forEach","reduce","a","b","isFinite","sorted","sort","i","Math","floor","sums","mean","pow","sqrt","q","interp","slice","size","Error","index","fraction","v0","v1"],"mappings":"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","sourcesContent":["\"use strict\";\n\nvar _interopRequireDefault = require(\"@babel/runtime/helpers/interopRequireDefault\");\n\nObject.defineProperty(exports, \"__esModule\", {\n  value: true\n});\nexports.keep = keep;\nexports.sum = sum;\nexports.avg = avg;\nexports.max = max;\nexports.min = min;\nexports.count = count;\nexports.first = first;\nexports.last = last;\nexports.difference = difference;\nexports.median = median;\nexports.stdev = stdev;\nexports.percentile = percentile;\nexports.filter = void 0;\n\nvar _underscore = _interopRequireDefault(require(\"underscore\"));\n\n/**\n *  Copyright (c) 2015-2017, The Regents of the University of California,\n *  through Lawrence Berkeley National Laboratory (subject to receipt\n *  of any required approvals from the U.S. Dept. of Energy).\n *  All rights reserved.\n *\n *  This source code is licensed under the BSD-style license found in the\n *  LICENSE file in the root directory of this source tree.\n */\nfunction isValid(v) {\n  return !(_underscore.default.isUndefined(v) || _underscore.default.isNaN(v) || _underscore.default.isNull(v));\n} //\n// Functions to process missing values out of a value list\n//\n\n/**\n * Default filter, so default it does nothing at all to the values passed to it\n * e.g. max(1, 2, null, 4) would be max(1, 2, null, 4)\n */\n\n\nvar keepMissing = values => values;\n/**\n * Removes missing values (null, undefined or NaN) from the list of\n * values passed into the aggregation function \n * e.g. avg(1, 2, null, 4) would be avg(1, 2, 4)\n */\n\n\nvar ignoreMissing = values => values.filter(isValid);\n/**\n * Replaces missing values (null, undefined or NaN) by 0.\n * e.g. avg(1, 2, null, 4) would be avg(1, 2, 0, 4)\n */\n\n\nvar zeroMissing = values => values.map(v => isValid(v) ? v : 0);\n/**\n * If there are missing values in the list of values being\n * aggregated then the result of the aggregation should be\n * also undefined or null.\n * e.g. avg(2, 4, null, 7) would be null.\n */\n\n\nvar propagateMissing = values => ignoreMissing(values).length === values.length ? values : null;\n/**\n * If there are no values in the list, the result of the aggregation\n * is null \n */\n\n\nvar noneIfEmpty = values => values.length === 0 ? null : values;\n\nvar filter = {\n  keepMissing,\n  ignoreMissing,\n  zeroMissing,\n  propagateMissing,\n  noneIfEmpty\n};\n/**\n * Like first() except it will return null if not all the values are\n * the same. This can be used to transfer a value when doing aggregation.\n * For instance you might group by the 'type', then avg the 'value', but\n * you want to results to include the type. So you would 'keep' the type\n * and 'avg' the value.\n */\n\nexports.filter = filter;\n\nfunction keep() {\n  var clean = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : filter.ignoreMissing;\n  return values => {\n    var cleanValues = clean(values);\n    if (!cleanValues) return null;\n    var result = first()(cleanValues);\n    cleanValues.forEach(v => {\n      if (v !== result) {\n        return null;\n      }\n    });\n    return result;\n  };\n}\n/**\n * Returns a sum function.\n *\n * Optionally you can specify the method by which unclean values\n * are treated. The default is to exclude missing values from\n * the sum calculation. Other possibilities are:\n *     `propergateMissing` - which will cause the min itself to\n *     be null if the values contain a missing value\n *     `zeroMissing` - will replace missing values with a zero\n */\n\n\nfunction sum() {\n  var clean = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : filter.ignoreMissing;\n  return values => {\n    var cleanValues = clean(values);\n    if (!cleanValues) return null;\n    return _underscore.default.reduce(cleanValues, (a, b) => a + b, 0);\n  };\n}\n/**\n * Returns a avg function.\n *\n * Optionally you can specify the method by which unclean values\n * are treated. The default is to exclude missing values from\n * the average calculation. Other possibilities are:\n *     `propergateMissing` - which will cause the avg itself to\n *     be null if the values contain a missing value\n *     `zeroMissing` - will replace missing values with a zero\n */\n\n\nfunction avg() {\n  var clean = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : filter.ignoreMissing;\n  return values => {\n    var cleanValues = clean(values);\n    if (!cleanValues) return null;\n\n    var sum = _underscore.default.reduce(cleanValues, (a, b) => {\n      return a + b;\n    }, 0);\n\n    return sum / cleanValues.length;\n  };\n}\n/**\n * Return a max function.\n *\n * Optionally you can specify the method by which unclean values\n * are treated. The default is to exclude missing values from\n * the maximum search. Other possibilities are:\n *     `propergateMissing` - which will cause the max itself to\n *     be null if the values contain a missing value\n *     `zeroMissing` - will replace missing values with a zero\n */\n\n\nfunction max() {\n  var clean = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : filter.ignoreMissing;\n  return values => {\n    var cleanValues = clean(values);\n    if (!cleanValues) return null;\n\n    var max = _underscore.default.max(cleanValues);\n\n    if (_underscore.default.isFinite(max)) {\n      return max;\n    }\n  };\n}\n/**\n * Return a min function.\n *\n * Optionally you can specify the method by which unclean values\n * are treated. The default is to exclude missing values from\n * the minimum search. Other possibilities are:\n *     `propergateMissing` - which will cause the min itself to\n *     be null if the values contain a missing value\n *     `zeroMissing` - will replace missing values with a zero\n */\n\n\nfunction min() {\n  var clean = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : filter.ignoreMissing;\n  return values => {\n    var cleanValues = clean(values);\n    if (!cleanValues) return null;\n\n    var min = _underscore.default.min(cleanValues);\n\n    if (_underscore.default.isFinite(min)) {\n      return min;\n    }\n  };\n}\n/**\n * Returns a count() function.\n *\n * Optionally you can specify the method by which unclean values\n * are treated. The default is to exclude missing values from\n * the count. Other possibilities are:\n *     `propergateMissing` - which will cause the count itself to\n *     be null if the values contain a missing value\n */\n\n\nfunction count() {\n  var clean = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : filter.ignoreMissing;\n  return values => {\n    var cleanValues = clean(values);\n    if (!cleanValues) return null;\n    return cleanValues.length;\n  };\n}\n/**\n * Returns a first() function, i.e. a function that returns the first\n * value in the supplied values list.\n *\n * Optionally you can specify the method by which unclean values\n * are treated. The default is to exclude missing values from\n * the list, i.e to find the first non-missing value. Other\n * possibilities are:\n *     `keepMissing` - to return the first value, regardless of if\n *     it is a missing value or not.\n */\n\n\nfunction first() {\n  var clean = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : filter.ignoreMissing;\n  return values => {\n    var cleanValues = clean(values);\n    if (!cleanValues) return null;\n    return cleanValues.length ? cleanValues[0] : undefined;\n  };\n}\n/**\n * Returns a last() function, i.e. a function that returns the list\n * value in the supplied values list.\n *\n * Optionally you can specify the method by which unclean values\n * are treated. The default is to exclude missing values from\n * the list, i.e to find the last non-missing value. Other\n * possibilities are:\n *     `keepMissing` - to return the last value, regardless of if\n *     it is a missing value or not.\n */\n\n\nfunction last() {\n  var clean = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : filter.ignoreMissing;\n  return values => {\n    var cleanValues = clean(values);\n    if (!cleanValues) return null;\n    return cleanValues.length ? cleanValues[cleanValues.length - 1] : undefined;\n  };\n}\n/**\n * Returns a difference() function, i.e. a function that returns\n * the difference between the min and max values.\n *\n * Optionally you can specify the method by which unclean values\n * are treated. The default is to exclude missing values from\n * the list, i.e to find the last non-missing value. Other\n * possibilities are:\n *     `propergateMissing` - which will cause the min itself to\n *     be null if the values contain a missing value\n *     `zeroMissing` - will replace missing values with a zero\n */\n\n\nfunction difference() {\n  var clean = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : filter.ignoreMissing;\n  return values => {\n    var cleanValues = clean(values);\n    if (!cleanValues) return null;\n    return _underscore.default.max(cleanValues) - _underscore.default.min(cleanValues);\n  };\n}\n\nfunction median() {\n  var clean = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : filter.ignoreMissing;\n  return values => {\n    var cleanValues = clean(values);\n    if (!cleanValues) return null;\n    var sorted = cleanValues.sort();\n    var i = Math.floor(sorted.length / 2);\n\n    if (sorted.length % 2 === 0) {\n      var a = sorted[i];\n      var b = sorted[i - 1];\n      return (a + b) / 2;\n    } else {\n      return sorted[i];\n    }\n  };\n}\n\nfunction stdev() {\n  var clean = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : filter.ignoreMissing;\n  return values => {\n    var cleanValues = clean(values);\n    if (!cleanValues) return null;\n    var sums = 0;\n    var mean = avg(clean)(cleanValues);\n    cleanValues.forEach(v => sums += Math.pow(v - mean, 2));\n    return Math.sqrt(sums / values.length);\n  };\n}\n/**\n * Returns a percentile function within the a values list.\n *\n * @param  {object}  options  The parameters controlling the function:\n *                             * q        The percentile (should be between 0 and 100)\n *                             * interp   Specifies the interpolation method\n *                                        to use when the desired quantile lies between\n *                                        two data points. Options are:\n *                                          * linear: i + (j - i) * fraction, where fraction is the fractional part of the index surrounded by i and j.\n *                                          * lower: i.\n *                                          * higher: j.\n *                                          * nearest: i or j whichever is nearest.\n *                                          * midpoint: (i + j) / 2.\n *                             * clean    Strategy to use when encountering missing data:\n *                                          * `propergateMissing` - which will cause the min\n *                                             itself to be null if the values contain a\n *                                             missing value\n *                                          * `zeroMissing` - will replace missing values\n *                                             with a zero\n * @return {number}            The percentile\n */\n\n\nfunction percentile(q) {\n  var interp = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : \"linear\";\n  var clean = arguments.length > 2 && arguments[2] !== undefined ? arguments[2] : filter.ignoreMissing;\n  return values => {\n    var cleanValues = clean(values);\n    if (!cleanValues) return null;\n    var v;\n    var sorted = cleanValues.slice().sort((a, b) => a - b);\n    var size = sorted.length;\n\n    if (q < 0 || q > 100) {\n      throw new Error(\"Percentile q must be between 0 and 100\");\n    }\n\n    var i = q / 100;\n    var index = Math.floor((sorted.length - 1) * i);\n\n    if (size === 1 || q === 0) {\n      return sorted[0];\n    }\n\n    if (q === 100) {\n      return sorted[size - 1];\n    }\n\n    if (index < size - 1) {\n      var fraction = (size - 1) * i - index;\n      var v0 = sorted[index];\n      var v1 = sorted[index + 1];\n\n      if (interp === \"lower\" || fraction === 0) {\n        v = v0;\n      } else if (interp === \"linear\") {\n        v = v0 + (v1 - v0) * fraction;\n      } else if (interp === \"higher\") {\n        v = v1;\n      } else if (interp === \"nearest\") {\n        v = fraction < 0.5 ? v0 : v1;\n      } else if (interp === \"midpoint\") {\n        v = (v0 + v1) / 2;\n      }\n    }\n\n    return v;\n  };\n}"]},"metadata":{},"sourceType":"script"}