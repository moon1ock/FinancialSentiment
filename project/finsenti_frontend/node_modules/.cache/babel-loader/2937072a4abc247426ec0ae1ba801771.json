{"ast":null,"code":"\"use strict\";\n\nvar _interopRequireDefault = require(\"@babel/runtime/helpers/interopRequireDefault\");\n\nObject.defineProperty(exports, \"__esModule\", {\n  value: true\n});\nexports.default = void 0;\n\nvar _underscore = _interopRequireDefault(require(\"underscore\"));\n\nvar _processor = _interopRequireDefault(require(\"./processor\"));\n\nvar _collector = _interopRequireDefault(require(\"../collector\"));\n\nvar _indexedevent = _interopRequireDefault(require(\"../indexedevent\"));\n\nvar _timerangeevent = _interopRequireDefault(require(\"../timerangeevent\"));\n\nvar _pipeline = require(\"../pipeline\");\n/**\n *  Copyright (c) 2016-2017, The Regents of the University of California,\n *  through Lawrence Berkeley National Laboratory (subject to receipt\n *  of any required approvals from the U.S. Dept. of Energy).\n *  All rights reserved.\n *\n *  This source code is licensed under the BSD-style license found in the\n *  LICENSE file in the root directory of this source tree.\n */\n\n/**\n * An Aggregator takes incoming events and adds them to a Collector\n * with given windowing and grouping parameters. As each Collection is\n * emitted from the Collector it is aggregated into a new event\n * and emitted from this Processor.\n */\n\n\nclass Aggregator extends _processor.default {\n  constructor(arg1, options) {\n    super(arg1, options);\n\n    if (arg1 instanceof Aggregator) {\n      var other = arg1;\n      this._fields = other._fields;\n      this._windowType = other._windowType;\n      this._windowDuration = other._windowDuration;\n      this._groupBy = other._groupBy;\n      this._emitOn = other._emitOn;\n    } else if ((0, _pipeline.isPipeline)(arg1)) {\n      var pipeline = arg1;\n      this._windowType = pipeline.getWindowType();\n      this._windowDuration = pipeline.getWindowDuration();\n      this._groupBy = pipeline.getGroupBy();\n      this._emitOn = pipeline.getEmitOn();\n\n      if (!_underscore.default.has(options, \"fields\")) {\n        throw new Error(\"Aggregator: constructor needs an aggregator field mapping\");\n      } // Check each of the aggregator -> field mappings\n\n\n      _underscore.default.forEach(options.fields, (operator, field) => {\n        // Field should either be an array or a string\n        if (!_underscore.default.isString(field) && !_underscore.default.isArray(field)) {\n          throw new Error(\"Aggregator: field of unknown type: \" + field);\n        }\n      });\n\n      if (pipeline.mode() === \"stream\") {\n        if (!pipeline.getWindowType() || !pipeline.getWindowDuration()) {\n          throw new Error(\"Unable to aggregate because no windowing strategy was specified in pipeline\");\n        }\n      }\n\n      this._fields = options.fields;\n    } else {\n      throw new Error(\"Unknown arg to Filter constructor\", arg1);\n    }\n\n    this._collector = new _collector.default({\n      windowType: this._windowType,\n      windowDuration: this._windowDuration,\n      groupBy: this._groupBy,\n      emitOn: this._emitOn\n    }, (collection, windowKey, groupByKey) => this.handleTrigger(collection, windowKey, groupByKey));\n  }\n\n  clone() {\n    return new Aggregator(this);\n  }\n\n  handleTrigger(collection, windowKey) {\n    var d = {};\n\n    _underscore.default.each(this._fields, (f, fieldName) => {\n      var keys = Object.keys(f);\n\n      if (keys.length !== 1) {\n        throw new Error(\"Fields should contain exactly one field\", f);\n      }\n\n      var field = keys[0];\n      var operator = f[field];\n      d[fieldName] = collection.aggregate(operator, field);\n    });\n\n    var event;\n\n    if (windowKey === \"global\") {\n      event = new _timerangeevent.default(collection.range(), d);\n    } else {\n      //TODO: Specify UTC (or local) pipeline\n      var utc = this._windowType === \"fixed\";\n      event = new _indexedevent.default(windowKey, d, utc);\n    }\n\n    this.emit(event);\n  }\n\n  flush() {\n    this._collector.flushCollections();\n\n    super.flush();\n  }\n\n  addEvent(event) {\n    if (this.hasObservers()) {\n      this._collector.addEvent(event);\n    }\n  }\n\n}\n\nvar _default = Aggregator;\nexports.default = _default;","map":{"version":3,"sources":["/Users/nicholasraffone/Documents/swefall2021/finalproj/FinancialSentiment/fin_sentiment_front/node_modules/pondjs/lib/lib/processors/aggregator.js"],"names":["_interopRequireDefault","require","Object","defineProperty","exports","value","default","_underscore","_processor","_collector","_indexedevent","_timerangeevent","_pipeline","Aggregator","constructor","arg1","options","other","_fields","_windowType","_windowDuration","_groupBy","_emitOn","isPipeline","pipeline","getWindowType","getWindowDuration","getGroupBy","getEmitOn","has","Error","forEach","fields","operator","field","isString","isArray","mode","windowType","windowDuration","groupBy","emitOn","collection","windowKey","groupByKey","handleTrigger","clone","d","each","f","fieldName","keys","length","aggregate","event","range","utc","emit","flush","flushCollections","addEvent","hasObservers","_default"],"mappings":"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","sourcesContent":["\"use strict\";\n\nvar _interopRequireDefault = require(\"@babel/runtime/helpers/interopRequireDefault\");\n\nObject.defineProperty(exports, \"__esModule\", {\n  value: true\n});\nexports.default = void 0;\n\nvar _underscore = _interopRequireDefault(require(\"underscore\"));\n\nvar _processor = _interopRequireDefault(require(\"./processor\"));\n\nvar _collector = _interopRequireDefault(require(\"../collector\"));\n\nvar _indexedevent = _interopRequireDefault(require(\"../indexedevent\"));\n\nvar _timerangeevent = _interopRequireDefault(require(\"../timerangeevent\"));\n\nvar _pipeline = require(\"../pipeline\");\n\n/**\n *  Copyright (c) 2016-2017, The Regents of the University of California,\n *  through Lawrence Berkeley National Laboratory (subject to receipt\n *  of any required approvals from the U.S. Dept. of Energy).\n *  All rights reserved.\n *\n *  This source code is licensed under the BSD-style license found in the\n *  LICENSE file in the root directory of this source tree.\n */\n\n/**\n * An Aggregator takes incoming events and adds them to a Collector\n * with given windowing and grouping parameters. As each Collection is\n * emitted from the Collector it is aggregated into a new event\n * and emitted from this Processor.\n */\nclass Aggregator extends _processor.default {\n  constructor(arg1, options) {\n    super(arg1, options);\n\n    if (arg1 instanceof Aggregator) {\n      var other = arg1;\n      this._fields = other._fields;\n      this._windowType = other._windowType;\n      this._windowDuration = other._windowDuration;\n      this._groupBy = other._groupBy;\n      this._emitOn = other._emitOn;\n    } else if ((0, _pipeline.isPipeline)(arg1)) {\n      var pipeline = arg1;\n      this._windowType = pipeline.getWindowType();\n      this._windowDuration = pipeline.getWindowDuration();\n      this._groupBy = pipeline.getGroupBy();\n      this._emitOn = pipeline.getEmitOn();\n\n      if (!_underscore.default.has(options, \"fields\")) {\n        throw new Error(\"Aggregator: constructor needs an aggregator field mapping\");\n      } // Check each of the aggregator -> field mappings\n\n\n      _underscore.default.forEach(options.fields, (operator, field) => {\n        // Field should either be an array or a string\n        if (!_underscore.default.isString(field) && !_underscore.default.isArray(field)) {\n          throw new Error(\"Aggregator: field of unknown type: \" + field);\n        }\n      });\n\n      if (pipeline.mode() === \"stream\") {\n        if (!pipeline.getWindowType() || !pipeline.getWindowDuration()) {\n          throw new Error(\"Unable to aggregate because no windowing strategy was specified in pipeline\");\n        }\n      }\n\n      this._fields = options.fields;\n    } else {\n      throw new Error(\"Unknown arg to Filter constructor\", arg1);\n    }\n\n    this._collector = new _collector.default({\n      windowType: this._windowType,\n      windowDuration: this._windowDuration,\n      groupBy: this._groupBy,\n      emitOn: this._emitOn\n    }, (collection, windowKey, groupByKey) => this.handleTrigger(collection, windowKey, groupByKey));\n  }\n\n  clone() {\n    return new Aggregator(this);\n  }\n\n  handleTrigger(collection, windowKey) {\n    var d = {};\n\n    _underscore.default.each(this._fields, (f, fieldName) => {\n      var keys = Object.keys(f);\n\n      if (keys.length !== 1) {\n        throw new Error(\"Fields should contain exactly one field\", f);\n      }\n\n      var field = keys[0];\n      var operator = f[field];\n      d[fieldName] = collection.aggregate(operator, field);\n    });\n\n    var event;\n\n    if (windowKey === \"global\") {\n      event = new _timerangeevent.default(collection.range(), d);\n    } else {\n      //TODO: Specify UTC (or local) pipeline\n      var utc = this._windowType === \"fixed\";\n      event = new _indexedevent.default(windowKey, d, utc);\n    }\n\n    this.emit(event);\n  }\n\n  flush() {\n    this._collector.flushCollections();\n\n    super.flush();\n  }\n\n  addEvent(event) {\n    if (this.hasObservers()) {\n      this._collector.addEvent(event);\n    }\n  }\n\n}\n\nvar _default = Aggregator;\nexports.default = _default;"]},"metadata":{},"sourceType":"script"}