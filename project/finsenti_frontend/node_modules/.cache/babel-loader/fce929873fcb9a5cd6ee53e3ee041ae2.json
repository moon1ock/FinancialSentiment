{"ast":null,"code":"\"use strict\";\n\nvar _interopRequireDefault = require(\"@babel/runtime/helpers/interopRequireDefault\");\n\nObject.defineProperty(exports, \"__esModule\", {\n  value: true\n});\nexports.default = void 0;\n\nvar _underscore = _interopRequireDefault(require(\"underscore\"));\n\nvar _immutable = _interopRequireDefault(require(\"immutable\"));\n\nvar _bounded = _interopRequireDefault(require(\"./io/bounded\"));\n\nvar _event = _interopRequireDefault(require(\"./event\"));\n\nvar _timerange = _interopRequireDefault(require(\"./timerange\"));\n\nvar _util = _interopRequireDefault(require(\"./base/util\"));\n\nvar _functions = require(\"./base/functions\");\n/*\n *  Copyright (c) 2016-2017, The Regents of the University of California,\n *  through Lawrence Berkeley National Laboratory (subject to receipt\n *  of any required approvals from the U.S. Dept. of Energy).\n *  All rights reserved.\n *\n *  This source code is licensed under the BSD-style license found in the\n *  LICENSE file in the root directory of this source tree.\n */\n\n/**\n * A collection is an abstraction for a bag of Events.\n *\n * You typically construct a Collection from a list of Events, which\n * may be either within an Immutable.List or an Array. You can also\n * copy another Collection or create an empty one.\n *\n * You can mutate a collection in a number of ways. In each instance\n * a new Collection will be returned.\n *\n * Basic operations on the list of events are also possible. You\n * can iterate over the collection with a for..of loop, get the size()\n * of the collection and access a specific element with at().\n *\n * You can also perform aggregations of the events, map them, filter them\n * clean them, etc.\n *\n * Collections form the backing structure for a TimeSeries, as well as\n * in Pipeline event processing. They are an instance of a BoundedIn, so\n * they can be used as a pipeline source.\n */\n\n\nclass Collection extends _bounded.default {\n  /**\n   * Construct a new Collection.\n   *\n   * @param  {Collection|array|Immutable.List}  arg1 Initial data for\n   * the collection. If arg1 is another Collection, this will act as\n   * a copy constructor.\n   * @param  {Boolean} [arg2] When using a the copy constructor\n   * this specified whether or not to also copy all the events in this\n   * collection. Generally you'll want to let it copy the events.\n   * If arg1 is an Immutable.List, then arg2 will specify the type of\n   * the Events accepted into the Collection. This form is generally\n   * used internally.\n   *\n   * @return {Collection} The constructed Collection.\n   */\n  constructor(arg1, arg2) {\n    super();\n    this._id = _underscore.default.uniqueId(\"collection-\");\n    this._eventList = null; // The events in this collection\n\n    this._type = null; // The type (class) of the events in this collection\n\n    if (!arg1) {\n      this._eventList = new _immutable.default.List();\n    } else if (arg1 instanceof Collection) {\n      var other = arg1;\n      var copyEvents = arg2 || true; // copyEvents is whether to copy events from other, default is true\n\n      if (_underscore.default.isUndefined(copyEvents) || copyEvents === true) {\n        this._eventList = other._eventList;\n        this._type = other._type;\n      } else {\n        this._eventList = new _immutable.default.List();\n      }\n    } else if (_underscore.default.isArray(arg1)) {\n      var events = [];\n      arg1.forEach(e => {\n        this._check(e);\n\n        events.push(e._d);\n      });\n      this._eventList = new _immutable.default.List(events);\n    } else if (_immutable.default.List.isList(arg1)) {\n      var type = arg2;\n\n      if (!type) {\n        throw new Error(\"No type supplied to Collection constructor\");\n      }\n\n      this._type = type;\n      this._eventList = arg1;\n    }\n  }\n  /**\n   * Returns the Collection as a regular JSON object.\n   *\n   * @return {Object} The JSON representation of this Collection\n   */\n\n\n  toJSON() {\n    return this._eventList.toJS();\n  }\n  /**\n   * Serialize out the Collection as a string. This will be the\n   * string representation of `toJSON()`.\n   *\n   * @return {string} The Collection serialized as a string.\n   */\n\n\n  toString() {\n    return JSON.stringify(this.toJSON());\n  }\n  /**\n   * Returns the Event object type in this Collection.\n   *\n   * Since Collections may only have one type of event (`Event`, `IndexedEvent`\n   * or `TimeRangeEvent`) this will return that type. If no events\n   * have been added to the Collection it will return `undefined`.\n   *\n   * @return {Event} - The class of the type of events contained in\n   *                   this Collection.\n   */\n\n\n  type() {\n    return this._type;\n  }\n  /**\n   * Returns the number of events in this collection\n   *\n   * @return {number} Count of events\n   */\n\n\n  size() {\n    return this._eventList.size;\n  }\n  /**\n   * Returns the number of valid items in this collection.\n   *\n   * Uses the fieldPath to look up values in all events.\n   * It then counts the number that are considered valid, which\n   * specifically are not NaN, undefined or null.\n   *\n   * @return {number} Count of valid events\n   */\n\n\n  sizeValid() {\n    var fieldPath = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : \"value\";\n    var count = 0;\n\n    for (var e of this.events()) {\n      if (_event.default.isValidValue(e, fieldPath)) count++;\n    }\n\n    return count;\n  }\n  /**\n   * Returns an event in the Collection by its position.\n   * @example\n   * ```\n   * for (let row=0; row < series.size(); row++) {\n   *   const event = series.at(row);\n   *   console.log(event.toString());\n   * }\n   * ```\n   * @param  {number} pos The position of the event\n   * @return {Event}      Returns the event at the pos specified.\n   */\n\n\n  at(pos) {\n    if (this._eventList.size > 0) {\n      var event = new this._type(this._eventList.get(pos));\n      return event;\n    }\n  }\n  /**\n   * Returns a list of events in the Collection which have\n   * the exact key (time, timerange or index) as the key specified\n   * by 'at'. Note that this is an O(n) search for the time specified,\n   * since collections are an unordered bag of events.\n   *\n   * @param  {Date|string|TimeRange} key The key of the event.\n   * @return {Array} All events at that key\n   */\n\n\n  atKey(k) {\n    var result = [];\n    var key;\n\n    if (k instanceof Date) {\n      key = k.getTime();\n    } else if (_underscore.default.isString(k)) {\n      key = k;\n    } else if (k instanceof _timerange.default) {\n      key = \"\".concat(this.timerange().begin(), \",\").concat(this.timerange().end());\n    }\n\n    for (var e of this.events()) {\n      if (e.key() === key) {\n        result.push(e);\n      }\n    }\n\n    return result;\n  }\n  /**\n   * Returns the first event in the Collection.\n   *\n   * @return {Event}\n   */\n\n\n  atFirst() {\n    if (this.size()) {\n      return this.at(0);\n    }\n  }\n  /**\n   * Returns the last event in the Collection.\n   *\n   * @return {Event}\n   */\n\n\n  atLast() {\n    if (this.size()) {\n      return this.at(this.size() - 1);\n    }\n  }\n  /**\n   * Generator to return all the events in the Collection.\n   *\n   * @example\n   * ```\n   * for (let event of collection.events()) {\n   *     console.log(event.toString());\n   * }\n   * ```\n   */\n\n\n  *events() {\n    for (var i = 0; i < this.size(); i++) {\n      yield this.at(i);\n    }\n  }\n\n  setEvents(events) {\n    var result = new Collection(this);\n    result._eventList = events;\n    return result;\n  }\n  /**\n   * Returns the raw Immutable event list\n   *\n   * @return {Immutable.List} All events as an Immutable List.\n   */\n\n\n  eventList() {\n    return this._eventList;\n  }\n  /**\n   * Returns a Javascript array representation of the event list\n   *\n   * @return {Array} All events as a Javascript Array.\n   */\n\n\n  eventListAsArray() {\n    var events = [];\n\n    for (var e of this.events()) {\n      events.push(e);\n    }\n\n    return events;\n  }\n  /**\n   * Returns the events in the collection as a Javascript Map, where\n   * the key is the timestamp, index or timerange and the\n   * value is an array of events with that key.\n   *\n   * @return {map} The map of events\n   */\n\n\n  eventListAsMap() {\n    var events = {};\n\n    for (var e of this.events()) {\n      var key = e.key();\n\n      if (!_underscore.default.has(events, key)) {\n        events[key] = [];\n      }\n\n      events[key].push(e);\n    }\n\n    return events;\n  } //\n  // De-duplicate\n  //\n\n  /**\n   * Removes duplicates from the Collection. If duplicates\n   * exist in the collection with the same key but with different\n   * values, then later event values will be used.\n   *\n   * @return {Collection} The sorted Collection.\n   */\n\n\n  dedup() {\n    var events = _event.default.merge(this.eventListAsArray());\n\n    return new Collection(events);\n  } //\n  // Sorting\n  //\n\n  /**\n   * Sorts the Collection by the timestamp. In the case\n   * of TimeRangeEvents and IndexedEvents, it will be sorted\n   * by the begin time. This is useful when the collection\n   * will be passed into a TimeSeries.\n   *\n   * See also isChronological().\n   *\n   * @return {Collection} The sorted Collection\n   */\n\n\n  sortByTime() {\n    var sorted = this._eventList.sortBy(event => {\n      var e = new this._type(event);\n      return e.timestamp().getTime();\n    });\n\n    return this.setEvents(sorted);\n  }\n  /**\n   * Sorts the Collection using the value referenced by\n   * the fieldPath.\n   *\n   * @return {Collection} The extents of the Collection\n   */\n\n\n  sort(fieldPath) {\n    var fs = _util.default.fieldPathToArray(fieldPath);\n\n    var sorted = this._eventList.sortBy(event => {\n      var e = new this._type(event);\n      return e.get(fs);\n    });\n\n    return this.setEvents(sorted);\n  } //\n  // Series range\n  //\n\n  /**\n   * From the range of times, or Indexes within the TimeSeries, return\n   * the extents of the TimeSeries as a TimeRange. This is currently implemented\n   * by walking the events.\n   *\n   * @return {TimeRange} The extents of the TimeSeries\n   */\n\n\n  range() {\n    var min;\n    var max;\n\n    for (var e of this.events()) {\n      if (!min || e.begin() < min) min = e.begin();\n      if (!max || e.end() > max) max = e.end();\n    }\n\n    if (min && max) return new _timerange.default(min, max);\n  } //\n  // Collection mutation\n  //\n\n  /**\n   * Adds an event to the collection, returns a new Collection. The event added\n   * can be an Event, TimeRangeEvent or IndexedEvent, but it must be of the\n   * same type as other events within the Collection.\n   *\n   * @param {Event} event The event being added.\n   *\n   * @return {Collection} A new, modified, Collection containing the new event.\n   */\n\n\n  addEvent(event) {\n    this._check(event);\n\n    var result = new Collection(this);\n    result._eventList = this._eventList.push(event._d);\n    return result;\n  }\n  /**\n   * Perform a slice of events within the Collection, returns a new\n   * Collection representing a portion of this TimeSeries from begin up to\n   * but not including end.\n   *\n   * @param {Number} begin   The position to begin slicing\n   * @param {Number} end     The position to end slicing\n   *\n   * @return {Collection}    The new, sliced, Collection.\n   */\n\n\n  slice(begin, end) {\n    return new Collection(this._eventList.slice(begin, end), this._type);\n  }\n  /**\n   * Filter the collection's event list with the supplied function\n   *\n   * @param {function} func The filter function, that should return\n   *                        true or false when passed in an event.\n   *\n   * @return {Collection}   A new, filtered, Collection.\n   */\n\n\n  filter(filterFunc) {\n    var filteredEventList = [];\n\n    for (var e of this.events()) {\n      if (filterFunc(e)) {\n        filteredEventList.push(e);\n      }\n    }\n\n    return new Collection(filteredEventList);\n  }\n  /**\n   * Map the collection's event list to a new event list with\n   * the supplied function.\n   * @param {function} func The mapping function, that should return\n   * a new event when passed in the old event.\n   *\n   * @return {Collection} A new, modified, Collection.\n   */\n\n\n  map(mapFunc) {\n    var result = [];\n\n    for (var e of this.events()) {\n      result.push(mapFunc(e));\n    }\n\n    return new Collection(result);\n  }\n  /**\n   * Returns a new Collection by testing the fieldPath\n   * values for being valid (not NaN, null or undefined).\n   *\n   * The resulting Collection will be clean (for that fieldPath).\n   *\n   * @param  {string}      fieldPath  Name of value to look up. If not supplied,\n   *                                  defaults to ['value']. \"Deep\" syntax is\n   *                                  ['deep', 'value'] or 'deep.value'\n   *\n   * @return {Collection}             A new, modified, Collection.\n   */\n\n\n  clean(fieldPath) {\n    var fs = _util.default.fieldPathToArray(fieldPath);\n\n    var filteredEvents = [];\n\n    for (var e of this.events()) {\n      if (_event.default.isValidValue(e, fs)) {\n        filteredEvents.push(e);\n      }\n    }\n\n    return new Collection(filteredEvents);\n  } //\n  // Aggregate the event list to a single value\n  //\n\n  /**\n   * Returns the number of events in this collection\n   *\n   * @return {number} The number of events\n   */\n\n\n  count() {\n    return this.size();\n  }\n  /**\n   * Returns the first value in the Collection for the fieldspec\n   *\n   * @param {string} fieldPath  Column to find the first value of. A deep value can be referenced with a\n   *                            string.like.this.  If not supplied the `value` column will be\n   *                            aggregated.\n   * @param {function} filter   Optional filter function used to clean data before aggregating\n   *\n   * @return {number}           The first value\n   */\n\n\n  first(fieldPath, filter) {\n    return this.aggregate((0, _functions.first)(filter), fieldPath);\n  }\n  /**\n   * Returns the last value in the Collection for the fieldspec\n   *\n   * @param {string} fieldPath  Column to find the last value of. A deep value can be referenced with a\n   *                            string.like.this.  If not supplied the `value` column will be\n   *                            aggregated.\n   * @param {function} filter   Optional filter function used to clean data before aggregating\n   *\n   * @return {number}           The last value\n   */\n\n\n  last(fieldPath, filter) {\n    return this.aggregate((0, _functions.last)(filter), fieldPath);\n  }\n  /**\n   * Returns the sum of the Collection for the fieldspec\n   *\n   * @param {string} fieldPath  Column to find the sum of. A deep value can be referenced with a\n   *                            string.like.this.  If not supplied the `value` column will be\n   *                            aggregated.\n   * @param {function} filter   Optional filter function used to clean data before aggregating\n   *\n   * @return {number}           The sum\n   */\n\n\n  sum(fieldPath, filter) {\n    return this.aggregate((0, _functions.sum)(filter), fieldPath);\n  }\n  /**\n   * Aggregates the events down to their average(s)\n   *\n   * @param {string} fieldPath  Column to find the avg of. A deep value can be referenced with a\n   *                            string.like.this.  If not supplied the `value` column will be\n   *                            aggregated.\n   * @param {function} filter   Optional filter function used to clean data before aggregating\n   *\n   * @return {number}           The average\n   */\n\n\n  avg(fieldPath, filter) {\n    return this.aggregate((0, _functions.avg)(filter), fieldPath);\n  }\n  /**\n   * Aggregates the events down to their maximum value\n   *\n   * @param {string} fieldPath  Column to find the max of. A deep value can be referenced with a\n   *                            string.like.this.  If not supplied the `value` column will be\n   *                            aggregated.\n   * @param {function} filter   Optional filter function used to clean data before aggregating\n   *\n   * @return {number}           The max value for the field\n   */\n\n\n  max(fieldPath, filter) {\n    return this.aggregate((0, _functions.max)(filter), fieldPath);\n  }\n  /**\n   * Aggregates the events down to their minimum value\n   *\n   * @param {string} fieldPath  Column to find the min of. A deep value can be referenced with a\n   *                            string.like.this.  If not supplied the `value` column will be\n   *                            aggregated.\n   * @param {function} filter   Optional filter function used to clean data before aggregating\n   *\n   * @return {number}           The min value for the field\n   */\n\n\n  min(fieldPath, filter) {\n    return this.aggregate((0, _functions.min)(filter), fieldPath);\n  }\n  /**\n   * Aggregates the events down to their mean (same as avg)\n   *\n   * @param {string} fieldPath  Column to find the mean of. A deep value can be referenced with a\n   *                            string.like.this.  If not supplied the `value` column will be\n   *                            aggregated.\n   * @param {function} filter   Optional filter function used to clean data before aggregating\n   *\n   * @return {number}           The mean\n   */\n\n\n  mean(fieldPath, filter) {\n    return this.avg(fieldPath, filter);\n  }\n  /**\n   * Aggregates the events down to their minimum value\n   *\n   * @param {string} fieldPath  Column to find the median of. A deep value can be referenced with a\n   *                            string.like.this.  If not supplied the `value` column will be\n   *                            aggregated.\n   * @param {function} filter   Optional filter function used to clean data before aggregating\n   *\n   * @return {number}           The median value\n   */\n\n\n  median(fieldPath, filter) {\n    return this.aggregate((0, _functions.median)(filter), fieldPath);\n  }\n  /**\n   * Aggregates the events down to their stdev\n   *\n   * @param {string} fieldPath  Column to find the stdev of. A deep value can be referenced with a\n   *                            string.like.this.  If not supplied the `value` column will be\n   *                            aggregated.\n   * @param {function} filter   Optional filter function used to clean data before aggregating\n   *\n   * @return {number}           The resulting stdev value\n   */\n\n\n  stdev(fieldPath, filter) {\n    return this.aggregate((0, _functions.stdev)(filter), fieldPath);\n  }\n  /**\n   * Gets percentile q within the Collection. This works the same way as numpy.\n   *\n   * @param  {integer} q        The percentile (should be between 0 and 100)\n   *\n   * @param {string} fieldPath  Column to find the percentile of. A deep value can be referenced with a\n   *                            string.like.this.  If not supplied the `value` column will be\n   *                            aggregated.\n   *\n   * @param  {string} interp    Specifies the interpolation method\n   *                            to use when the desired quantile lies between\n   *                            two data points. Options are:\n   *                            options are:\n   *                             * linear: i + (j - i) * fraction, where fraction is the fractional part of the index surrounded by i and j.\n   *                             * lower: i.\n   *                             * higher: j.\n   *                             * nearest: i or j whichever is nearest.\n   *                             * midpoint: (i + j) / 2.\n   * @param {function} filter   Optional filter function used to clean data before aggregating\n   *\n   * @return {number}           The percentile\n   */\n\n\n  percentile(q, fieldPath) {\n    var interp = arguments.length > 2 && arguments[2] !== undefined ? arguments[2] : \"linear\";\n    var filter = arguments.length > 3 ? arguments[3] : undefined;\n    return this.aggregate((0, _functions.percentile)(q, interp, filter), fieldPath);\n  }\n  /**\n   * Aggregates the events down using a user defined function to\n   * do the reduction.\n   *\n   * @param  {function} func    User defined reduction function. Will be\n   *                            passed a list of values. Should return a\n   *                            singe value.\n   *\n   * @param  {String} fieldPath The field to aggregate over\n   *\n   * @return {number}           The resulting value\n   */\n\n\n  aggregate(func, fieldPath) {\n    var options = arguments.length > 2 && arguments[2] !== undefined ? arguments[2] : {};\n    var fpath;\n\n    if (!_underscore.default.isFunction(func)) {\n      throw new Error(\"First arg to aggregate() must be a function\");\n    }\n\n    if (_underscore.default.isString(fieldPath)) {\n      fpath = fieldPath;\n    } else if (_underscore.default.isArray(fieldPath)) {\n      // if the ['array', 'style', 'fieldpath'] is being used,\n      // we need to turn it back into a string since we are\n      // using a subset of the the map() functionality on\n      // a single column\n      fpath = fieldPath.split(\".\");\n    } else if (_underscore.default.isUndefined(fieldPath)) {\n      // map() needs a field name to use as a key. Normally\n      // this case is normally handled by _field_spec_to_array()\n      // inside get(). Also, if map(func, field_spec=None) then\n      // it will map all the columns.\n      fpath = \"value\";\n    } else {\n      throw new Error(\"Collection.aggregate() takes a string/array fieldPath\");\n    }\n\n    var result = _event.default.mapReduce(this.eventListAsArray(), fpath, func, options);\n\n    return result[fpath];\n  }\n  /**\n   * Gets n quantiles within the Collection. This works the same way as numpy.\n   *\n   * @param  {integer} n        The number of quantiles to divide the\n   *                            Collection into.\n   *\n   * @param  {string} column    The field to return as the quantile\n   *\n   * @param  {string} interp    Specifies the interpolation method\n   *                            to use when the desired quantile lies between\n   *                            two data points. Options are:\n   *                            options are:\n   *                             * linear: i + (j - i) * fraction, where fraction is the fractional part of the index surrounded by i and j.\n   *                             * lower: i.\n   *                             * higher: j.\n   *                             * nearest: i or j whichever is nearest.\n   *                             * midpoint: (i + j) / 2.\n   *\n   * @return {array}            An array of n quantiles\n   */\n\n\n  quantile(n) {\n    var column = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : \"value\";\n    var interp = arguments.length > 2 && arguments[2] !== undefined ? arguments[2] : \"linear\";\n    var results = [];\n    var sorted = this.sort(column);\n    var subsets = 1.0 / n;\n\n    if (n > this.length) {\n      throw new Error(\"Subset n is greater than the Collection length\");\n    }\n\n    for (var i = subsets; i < 1; i += subsets) {\n      var index = Math.floor((sorted.size() - 1) * i);\n\n      if (index < sorted.size() - 1) {\n        var fraction = (sorted.size() - 1) * i - index;\n        var v0 = sorted.at(index).get(column);\n        var v1 = sorted.at(index + 1).get(column);\n        var v = void 0;\n\n        if (interp === \"lower\" || fraction === 0) {\n          v = v0;\n        } else if (interp === \"linear\") {\n          v = v0 + (v1 - v0) * fraction;\n        } else if (interp === \"higher\") {\n          v = v1;\n        } else if (interp === \"nearest\") {\n          v = fraction < 0.5 ? v0 : v1;\n        } else if (interp === \"midpoint\") {\n          v = (v0 + v1) / 2;\n        }\n\n        results.push(v);\n      }\n    }\n\n    return results;\n  }\n  /**\n   * Returns true if all events in this Collection are in chronological order.\n   * @return {Boolean} True if all events are in order, oldest events to newest.\n   */\n\n\n  isChronological() {\n    var result = true;\n    var t;\n\n    for (var e of this.events()) {\n      if (!t) {\n        t = e.timestamp().getTime();\n      } else {\n        if (e.timestamp() < t) {\n          result = false;\n        }\n\n        t = e.timestamp();\n      }\n    }\n\n    return result;\n  }\n  /**\n   * STATIC\n   */\n\n  /**\n    * Static function to compare two collections to each other. If the collections\n    * are of the same instance as each other then equals will return true.\n    *\n    * @param  {Collection} collection1\n    * @param  {Collection} collection2\n    *\n    * @return {bool} result\n    */\n\n\n  static equal(collection1, collection2) {\n    return collection1._type === collection2._type && collection1._eventList === collection2._eventList;\n  }\n  /**\n    * Static function to compare two collections to each other. If the collections\n    * are of the same value as each other then equals will return true.\n    *\n    * @param  {Collection} collection1\n    * @param  {Collection} collection2\n    *\n    * @return {bool} result\n    */\n\n\n  static is(collection1, collection2) {\n    return collection1._type === collection2._type && _immutable.default.is(collection1._eventList, collection2._eventList);\n  }\n\n}\n\nvar _default = Collection;\nexports.default = _default;","map":{"version":3,"sources":["/Users/nicholasraffone/Documents/swefall2021/finalproj/FinancialSentiment/fin_sentiment_front/node_modules/pondjs/lib/lib/collection.js"],"names":["_interopRequireDefault","require","Object","defineProperty","exports","value","default","_underscore","_immutable","_bounded","_event","_timerange","_util","_functions","Collection","constructor","arg1","arg2","_id","uniqueId","_eventList","_type","List","other","copyEvents","isUndefined","isArray","events","forEach","e","_check","push","_d","isList","type","Error","toJSON","toJS","toString","JSON","stringify","size","sizeValid","fieldPath","arguments","length","undefined","count","isValidValue","at","pos","event","get","atKey","k","result","key","Date","getTime","isString","concat","timerange","begin","end","atFirst","atLast","i","setEvents","eventList","eventListAsArray","eventListAsMap","has","dedup","merge","sortByTime","sorted","sortBy","timestamp","sort","fs","fieldPathToArray","range","min","max","addEvent","slice","filter","filterFunc","filteredEventList","map","mapFunc","clean","filteredEvents","first","aggregate","last","sum","avg","mean","median","stdev","percentile","q","interp","func","options","fpath","isFunction","split","mapReduce","quantile","n","column","results","subsets","index","Math","floor","fraction","v0","v1","v","isChronological","t","equal","collection1","collection2","is","_default"],"mappings":"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","sourcesContent":["\"use strict\";\n\nvar _interopRequireDefault = require(\"@babel/runtime/helpers/interopRequireDefault\");\n\nObject.defineProperty(exports, \"__esModule\", {\n  value: true\n});\nexports.default = void 0;\n\nvar _underscore = _interopRequireDefault(require(\"underscore\"));\n\nvar _immutable = _interopRequireDefault(require(\"immutable\"));\n\nvar _bounded = _interopRequireDefault(require(\"./io/bounded\"));\n\nvar _event = _interopRequireDefault(require(\"./event\"));\n\nvar _timerange = _interopRequireDefault(require(\"./timerange\"));\n\nvar _util = _interopRequireDefault(require(\"./base/util\"));\n\nvar _functions = require(\"./base/functions\");\n\n/*\n *  Copyright (c) 2016-2017, The Regents of the University of California,\n *  through Lawrence Berkeley National Laboratory (subject to receipt\n *  of any required approvals from the U.S. Dept. of Energy).\n *  All rights reserved.\n *\n *  This source code is licensed under the BSD-style license found in the\n *  LICENSE file in the root directory of this source tree.\n */\n\n/**\n * A collection is an abstraction for a bag of Events.\n *\n * You typically construct a Collection from a list of Events, which\n * may be either within an Immutable.List or an Array. You can also\n * copy another Collection or create an empty one.\n *\n * You can mutate a collection in a number of ways. In each instance\n * a new Collection will be returned.\n *\n * Basic operations on the list of events are also possible. You\n * can iterate over the collection with a for..of loop, get the size()\n * of the collection and access a specific element with at().\n *\n * You can also perform aggregations of the events, map them, filter them\n * clean them, etc.\n *\n * Collections form the backing structure for a TimeSeries, as well as\n * in Pipeline event processing. They are an instance of a BoundedIn, so\n * they can be used as a pipeline source.\n */\nclass Collection extends _bounded.default {\n  /**\n   * Construct a new Collection.\n   *\n   * @param  {Collection|array|Immutable.List}  arg1 Initial data for\n   * the collection. If arg1 is another Collection, this will act as\n   * a copy constructor.\n   * @param  {Boolean} [arg2] When using a the copy constructor\n   * this specified whether or not to also copy all the events in this\n   * collection. Generally you'll want to let it copy the events.\n   * If arg1 is an Immutable.List, then arg2 will specify the type of\n   * the Events accepted into the Collection. This form is generally\n   * used internally.\n   *\n   * @return {Collection} The constructed Collection.\n   */\n  constructor(arg1, arg2) {\n    super();\n    this._id = _underscore.default.uniqueId(\"collection-\");\n    this._eventList = null; // The events in this collection\n\n    this._type = null; // The type (class) of the events in this collection\n\n    if (!arg1) {\n      this._eventList = new _immutable.default.List();\n    } else if (arg1 instanceof Collection) {\n      var other = arg1;\n      var copyEvents = arg2 || true; // copyEvents is whether to copy events from other, default is true\n\n      if (_underscore.default.isUndefined(copyEvents) || copyEvents === true) {\n        this._eventList = other._eventList;\n        this._type = other._type;\n      } else {\n        this._eventList = new _immutable.default.List();\n      }\n    } else if (_underscore.default.isArray(arg1)) {\n      var events = [];\n      arg1.forEach(e => {\n        this._check(e);\n\n        events.push(e._d);\n      });\n      this._eventList = new _immutable.default.List(events);\n    } else if (_immutable.default.List.isList(arg1)) {\n      var type = arg2;\n\n      if (!type) {\n        throw new Error(\"No type supplied to Collection constructor\");\n      }\n\n      this._type = type;\n      this._eventList = arg1;\n    }\n  }\n  /**\n   * Returns the Collection as a regular JSON object.\n   *\n   * @return {Object} The JSON representation of this Collection\n   */\n\n\n  toJSON() {\n    return this._eventList.toJS();\n  }\n  /**\n   * Serialize out the Collection as a string. This will be the\n   * string representation of `toJSON()`.\n   *\n   * @return {string} The Collection serialized as a string.\n   */\n\n\n  toString() {\n    return JSON.stringify(this.toJSON());\n  }\n  /**\n   * Returns the Event object type in this Collection.\n   *\n   * Since Collections may only have one type of event (`Event`, `IndexedEvent`\n   * or `TimeRangeEvent`) this will return that type. If no events\n   * have been added to the Collection it will return `undefined`.\n   *\n   * @return {Event} - The class of the type of events contained in\n   *                   this Collection.\n   */\n\n\n  type() {\n    return this._type;\n  }\n  /**\n   * Returns the number of events in this collection\n   *\n   * @return {number} Count of events\n   */\n\n\n  size() {\n    return this._eventList.size;\n  }\n  /**\n   * Returns the number of valid items in this collection.\n   *\n   * Uses the fieldPath to look up values in all events.\n   * It then counts the number that are considered valid, which\n   * specifically are not NaN, undefined or null.\n   *\n   * @return {number} Count of valid events\n   */\n\n\n  sizeValid() {\n    var fieldPath = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : \"value\";\n    var count = 0;\n\n    for (var e of this.events()) {\n      if (_event.default.isValidValue(e, fieldPath)) count++;\n    }\n\n    return count;\n  }\n  /**\n   * Returns an event in the Collection by its position.\n   * @example\n   * ```\n   * for (let row=0; row < series.size(); row++) {\n   *   const event = series.at(row);\n   *   console.log(event.toString());\n   * }\n   * ```\n   * @param  {number} pos The position of the event\n   * @return {Event}      Returns the event at the pos specified.\n   */\n\n\n  at(pos) {\n    if (this._eventList.size > 0) {\n      var event = new this._type(this._eventList.get(pos));\n      return event;\n    }\n  }\n  /**\n   * Returns a list of events in the Collection which have\n   * the exact key (time, timerange or index) as the key specified\n   * by 'at'. Note that this is an O(n) search for the time specified,\n   * since collections are an unordered bag of events.\n   *\n   * @param  {Date|string|TimeRange} key The key of the event.\n   * @return {Array} All events at that key\n   */\n\n\n  atKey(k) {\n    var result = [];\n    var key;\n\n    if (k instanceof Date) {\n      key = k.getTime();\n    } else if (_underscore.default.isString(k)) {\n      key = k;\n    } else if (k instanceof _timerange.default) {\n      key = \"\".concat(this.timerange().begin(), \",\").concat(this.timerange().end());\n    }\n\n    for (var e of this.events()) {\n      if (e.key() === key) {\n        result.push(e);\n      }\n    }\n\n    return result;\n  }\n  /**\n   * Returns the first event in the Collection.\n   *\n   * @return {Event}\n   */\n\n\n  atFirst() {\n    if (this.size()) {\n      return this.at(0);\n    }\n  }\n  /**\n   * Returns the last event in the Collection.\n   *\n   * @return {Event}\n   */\n\n\n  atLast() {\n    if (this.size()) {\n      return this.at(this.size() - 1);\n    }\n  }\n  /**\n   * Generator to return all the events in the Collection.\n   *\n   * @example\n   * ```\n   * for (let event of collection.events()) {\n   *     console.log(event.toString());\n   * }\n   * ```\n   */\n\n\n  *events() {\n    for (var i = 0; i < this.size(); i++) {\n      yield this.at(i);\n    }\n  }\n\n  setEvents(events) {\n    var result = new Collection(this);\n    result._eventList = events;\n    return result;\n  }\n  /**\n   * Returns the raw Immutable event list\n   *\n   * @return {Immutable.List} All events as an Immutable List.\n   */\n\n\n  eventList() {\n    return this._eventList;\n  }\n  /**\n   * Returns a Javascript array representation of the event list\n   *\n   * @return {Array} All events as a Javascript Array.\n   */\n\n\n  eventListAsArray() {\n    var events = [];\n\n    for (var e of this.events()) {\n      events.push(e);\n    }\n\n    return events;\n  }\n  /**\n   * Returns the events in the collection as a Javascript Map, where\n   * the key is the timestamp, index or timerange and the\n   * value is an array of events with that key.\n   *\n   * @return {map} The map of events\n   */\n\n\n  eventListAsMap() {\n    var events = {};\n\n    for (var e of this.events()) {\n      var key = e.key();\n\n      if (!_underscore.default.has(events, key)) {\n        events[key] = [];\n      }\n\n      events[key].push(e);\n    }\n\n    return events;\n  } //\n  // De-duplicate\n  //\n\n  /**\n   * Removes duplicates from the Collection. If duplicates\n   * exist in the collection with the same key but with different\n   * values, then later event values will be used.\n   *\n   * @return {Collection} The sorted Collection.\n   */\n\n\n  dedup() {\n    var events = _event.default.merge(this.eventListAsArray());\n\n    return new Collection(events);\n  } //\n  // Sorting\n  //\n\n  /**\n   * Sorts the Collection by the timestamp. In the case\n   * of TimeRangeEvents and IndexedEvents, it will be sorted\n   * by the begin time. This is useful when the collection\n   * will be passed into a TimeSeries.\n   *\n   * See also isChronological().\n   *\n   * @return {Collection} The sorted Collection\n   */\n\n\n  sortByTime() {\n    var sorted = this._eventList.sortBy(event => {\n      var e = new this._type(event);\n      return e.timestamp().getTime();\n    });\n\n    return this.setEvents(sorted);\n  }\n  /**\n   * Sorts the Collection using the value referenced by\n   * the fieldPath.\n   *\n   * @return {Collection} The extents of the Collection\n   */\n\n\n  sort(fieldPath) {\n    var fs = _util.default.fieldPathToArray(fieldPath);\n\n    var sorted = this._eventList.sortBy(event => {\n      var e = new this._type(event);\n      return e.get(fs);\n    });\n\n    return this.setEvents(sorted);\n  } //\n  // Series range\n  //\n\n  /**\n   * From the range of times, or Indexes within the TimeSeries, return\n   * the extents of the TimeSeries as a TimeRange. This is currently implemented\n   * by walking the events.\n   *\n   * @return {TimeRange} The extents of the TimeSeries\n   */\n\n\n  range() {\n    var min;\n    var max;\n\n    for (var e of this.events()) {\n      if (!min || e.begin() < min) min = e.begin();\n      if (!max || e.end() > max) max = e.end();\n    }\n\n    if (min && max) return new _timerange.default(min, max);\n  } //\n  // Collection mutation\n  //\n\n  /**\n   * Adds an event to the collection, returns a new Collection. The event added\n   * can be an Event, TimeRangeEvent or IndexedEvent, but it must be of the\n   * same type as other events within the Collection.\n   *\n   * @param {Event} event The event being added.\n   *\n   * @return {Collection} A new, modified, Collection containing the new event.\n   */\n\n\n  addEvent(event) {\n    this._check(event);\n\n    var result = new Collection(this);\n    result._eventList = this._eventList.push(event._d);\n    return result;\n  }\n  /**\n   * Perform a slice of events within the Collection, returns a new\n   * Collection representing a portion of this TimeSeries from begin up to\n   * but not including end.\n   *\n   * @param {Number} begin   The position to begin slicing\n   * @param {Number} end     The position to end slicing\n   *\n   * @return {Collection}    The new, sliced, Collection.\n   */\n\n\n  slice(begin, end) {\n    return new Collection(this._eventList.slice(begin, end), this._type);\n  }\n  /**\n   * Filter the collection's event list with the supplied function\n   *\n   * @param {function} func The filter function, that should return\n   *                        true or false when passed in an event.\n   *\n   * @return {Collection}   A new, filtered, Collection.\n   */\n\n\n  filter(filterFunc) {\n    var filteredEventList = [];\n\n    for (var e of this.events()) {\n      if (filterFunc(e)) {\n        filteredEventList.push(e);\n      }\n    }\n\n    return new Collection(filteredEventList);\n  }\n  /**\n   * Map the collection's event list to a new event list with\n   * the supplied function.\n   * @param {function} func The mapping function, that should return\n   * a new event when passed in the old event.\n   *\n   * @return {Collection} A new, modified, Collection.\n   */\n\n\n  map(mapFunc) {\n    var result = [];\n\n    for (var e of this.events()) {\n      result.push(mapFunc(e));\n    }\n\n    return new Collection(result);\n  }\n  /**\n   * Returns a new Collection by testing the fieldPath\n   * values for being valid (not NaN, null or undefined).\n   *\n   * The resulting Collection will be clean (for that fieldPath).\n   *\n   * @param  {string}      fieldPath  Name of value to look up. If not supplied,\n   *                                  defaults to ['value']. \"Deep\" syntax is\n   *                                  ['deep', 'value'] or 'deep.value'\n   *\n   * @return {Collection}             A new, modified, Collection.\n   */\n\n\n  clean(fieldPath) {\n    var fs = _util.default.fieldPathToArray(fieldPath);\n\n    var filteredEvents = [];\n\n    for (var e of this.events()) {\n      if (_event.default.isValidValue(e, fs)) {\n        filteredEvents.push(e);\n      }\n    }\n\n    return new Collection(filteredEvents);\n  } //\n  // Aggregate the event list to a single value\n  //\n\n  /**\n   * Returns the number of events in this collection\n   *\n   * @return {number} The number of events\n   */\n\n\n  count() {\n    return this.size();\n  }\n  /**\n   * Returns the first value in the Collection for the fieldspec\n   *\n   * @param {string} fieldPath  Column to find the first value of. A deep value can be referenced with a\n   *                            string.like.this.  If not supplied the `value` column will be\n   *                            aggregated.\n   * @param {function} filter   Optional filter function used to clean data before aggregating\n   *\n   * @return {number}           The first value\n   */\n\n\n  first(fieldPath, filter) {\n    return this.aggregate((0, _functions.first)(filter), fieldPath);\n  }\n  /**\n   * Returns the last value in the Collection for the fieldspec\n   *\n   * @param {string} fieldPath  Column to find the last value of. A deep value can be referenced with a\n   *                            string.like.this.  If not supplied the `value` column will be\n   *                            aggregated.\n   * @param {function} filter   Optional filter function used to clean data before aggregating\n   *\n   * @return {number}           The last value\n   */\n\n\n  last(fieldPath, filter) {\n    return this.aggregate((0, _functions.last)(filter), fieldPath);\n  }\n  /**\n   * Returns the sum of the Collection for the fieldspec\n   *\n   * @param {string} fieldPath  Column to find the sum of. A deep value can be referenced with a\n   *                            string.like.this.  If not supplied the `value` column will be\n   *                            aggregated.\n   * @param {function} filter   Optional filter function used to clean data before aggregating\n   *\n   * @return {number}           The sum\n   */\n\n\n  sum(fieldPath, filter) {\n    return this.aggregate((0, _functions.sum)(filter), fieldPath);\n  }\n  /**\n   * Aggregates the events down to their average(s)\n   *\n   * @param {string} fieldPath  Column to find the avg of. A deep value can be referenced with a\n   *                            string.like.this.  If not supplied the `value` column will be\n   *                            aggregated.\n   * @param {function} filter   Optional filter function used to clean data before aggregating\n   *\n   * @return {number}           The average\n   */\n\n\n  avg(fieldPath, filter) {\n    return this.aggregate((0, _functions.avg)(filter), fieldPath);\n  }\n  /**\n   * Aggregates the events down to their maximum value\n   *\n   * @param {string} fieldPath  Column to find the max of. A deep value can be referenced with a\n   *                            string.like.this.  If not supplied the `value` column will be\n   *                            aggregated.\n   * @param {function} filter   Optional filter function used to clean data before aggregating\n   *\n   * @return {number}           The max value for the field\n   */\n\n\n  max(fieldPath, filter) {\n    return this.aggregate((0, _functions.max)(filter), fieldPath);\n  }\n  /**\n   * Aggregates the events down to their minimum value\n   *\n   * @param {string} fieldPath  Column to find the min of. A deep value can be referenced with a\n   *                            string.like.this.  If not supplied the `value` column will be\n   *                            aggregated.\n   * @param {function} filter   Optional filter function used to clean data before aggregating\n   *\n   * @return {number}           The min value for the field\n   */\n\n\n  min(fieldPath, filter) {\n    return this.aggregate((0, _functions.min)(filter), fieldPath);\n  }\n  /**\n   * Aggregates the events down to their mean (same as avg)\n   *\n   * @param {string} fieldPath  Column to find the mean of. A deep value can be referenced with a\n   *                            string.like.this.  If not supplied the `value` column will be\n   *                            aggregated.\n   * @param {function} filter   Optional filter function used to clean data before aggregating\n   *\n   * @return {number}           The mean\n   */\n\n\n  mean(fieldPath, filter) {\n    return this.avg(fieldPath, filter);\n  }\n  /**\n   * Aggregates the events down to their minimum value\n   *\n   * @param {string} fieldPath  Column to find the median of. A deep value can be referenced with a\n   *                            string.like.this.  If not supplied the `value` column will be\n   *                            aggregated.\n   * @param {function} filter   Optional filter function used to clean data before aggregating\n   *\n   * @return {number}           The median value\n   */\n\n\n  median(fieldPath, filter) {\n    return this.aggregate((0, _functions.median)(filter), fieldPath);\n  }\n  /**\n   * Aggregates the events down to their stdev\n   *\n   * @param {string} fieldPath  Column to find the stdev of. A deep value can be referenced with a\n   *                            string.like.this.  If not supplied the `value` column will be\n   *                            aggregated.\n   * @param {function} filter   Optional filter function used to clean data before aggregating\n   *\n   * @return {number}           The resulting stdev value\n   */\n\n\n  stdev(fieldPath, filter) {\n    return this.aggregate((0, _functions.stdev)(filter), fieldPath);\n  }\n  /**\n   * Gets percentile q within the Collection. This works the same way as numpy.\n   *\n   * @param  {integer} q        The percentile (should be between 0 and 100)\n   *\n   * @param {string} fieldPath  Column to find the percentile of. A deep value can be referenced with a\n   *                            string.like.this.  If not supplied the `value` column will be\n   *                            aggregated.\n   *\n   * @param  {string} interp    Specifies the interpolation method\n   *                            to use when the desired quantile lies between\n   *                            two data points. Options are:\n   *                            options are:\n   *                             * linear: i + (j - i) * fraction, where fraction is the fractional part of the index surrounded by i and j.\n   *                             * lower: i.\n   *                             * higher: j.\n   *                             * nearest: i or j whichever is nearest.\n   *                             * midpoint: (i + j) / 2.\n   * @param {function} filter   Optional filter function used to clean data before aggregating\n   *\n   * @return {number}           The percentile\n   */\n\n\n  percentile(q, fieldPath) {\n    var interp = arguments.length > 2 && arguments[2] !== undefined ? arguments[2] : \"linear\";\n    var filter = arguments.length > 3 ? arguments[3] : undefined;\n    return this.aggregate((0, _functions.percentile)(q, interp, filter), fieldPath);\n  }\n  /**\n   * Aggregates the events down using a user defined function to\n   * do the reduction.\n   *\n   * @param  {function} func    User defined reduction function. Will be\n   *                            passed a list of values. Should return a\n   *                            singe value.\n   *\n   * @param  {String} fieldPath The field to aggregate over\n   *\n   * @return {number}           The resulting value\n   */\n\n\n  aggregate(func, fieldPath) {\n    var options = arguments.length > 2 && arguments[2] !== undefined ? arguments[2] : {};\n    var fpath;\n\n    if (!_underscore.default.isFunction(func)) {\n      throw new Error(\"First arg to aggregate() must be a function\");\n    }\n\n    if (_underscore.default.isString(fieldPath)) {\n      fpath = fieldPath;\n    } else if (_underscore.default.isArray(fieldPath)) {\n      // if the ['array', 'style', 'fieldpath'] is being used,\n      // we need to turn it back into a string since we are\n      // using a subset of the the map() functionality on\n      // a single column\n      fpath = fieldPath.split(\".\");\n    } else if (_underscore.default.isUndefined(fieldPath)) {\n      // map() needs a field name to use as a key. Normally\n      // this case is normally handled by _field_spec_to_array()\n      // inside get(). Also, if map(func, field_spec=None) then\n      // it will map all the columns.\n      fpath = \"value\";\n    } else {\n      throw new Error(\"Collection.aggregate() takes a string/array fieldPath\");\n    }\n\n    var result = _event.default.mapReduce(this.eventListAsArray(), fpath, func, options);\n\n    return result[fpath];\n  }\n  /**\n   * Gets n quantiles within the Collection. This works the same way as numpy.\n   *\n   * @param  {integer} n        The number of quantiles to divide the\n   *                            Collection into.\n   *\n   * @param  {string} column    The field to return as the quantile\n   *\n   * @param  {string} interp    Specifies the interpolation method\n   *                            to use when the desired quantile lies between\n   *                            two data points. Options are:\n   *                            options are:\n   *                             * linear: i + (j - i) * fraction, where fraction is the fractional part of the index surrounded by i and j.\n   *                             * lower: i.\n   *                             * higher: j.\n   *                             * nearest: i or j whichever is nearest.\n   *                             * midpoint: (i + j) / 2.\n   *\n   * @return {array}            An array of n quantiles\n   */\n\n\n  quantile(n) {\n    var column = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : \"value\";\n    var interp = arguments.length > 2 && arguments[2] !== undefined ? arguments[2] : \"linear\";\n    var results = [];\n    var sorted = this.sort(column);\n    var subsets = 1.0 / n;\n\n    if (n > this.length) {\n      throw new Error(\"Subset n is greater than the Collection length\");\n    }\n\n    for (var i = subsets; i < 1; i += subsets) {\n      var index = Math.floor((sorted.size() - 1) * i);\n\n      if (index < sorted.size() - 1) {\n        var fraction = (sorted.size() - 1) * i - index;\n        var v0 = sorted.at(index).get(column);\n        var v1 = sorted.at(index + 1).get(column);\n        var v = void 0;\n\n        if (interp === \"lower\" || fraction === 0) {\n          v = v0;\n        } else if (interp === \"linear\") {\n          v = v0 + (v1 - v0) * fraction;\n        } else if (interp === \"higher\") {\n          v = v1;\n        } else if (interp === \"nearest\") {\n          v = fraction < 0.5 ? v0 : v1;\n        } else if (interp === \"midpoint\") {\n          v = (v0 + v1) / 2;\n        }\n\n        results.push(v);\n      }\n    }\n\n    return results;\n  }\n  /**\n   * Returns true if all events in this Collection are in chronological order.\n   * @return {Boolean} True if all events are in order, oldest events to newest.\n   */\n\n\n  isChronological() {\n    var result = true;\n    var t;\n\n    for (var e of this.events()) {\n      if (!t) {\n        t = e.timestamp().getTime();\n      } else {\n        if (e.timestamp() < t) {\n          result = false;\n        }\n\n        t = e.timestamp();\n      }\n    }\n\n    return result;\n  }\n  /**\n   * STATIC\n   */\n\n  /**\n    * Static function to compare two collections to each other. If the collections\n    * are of the same instance as each other then equals will return true.\n    *\n    * @param  {Collection} collection1\n    * @param  {Collection} collection2\n    *\n    * @return {bool} result\n    */\n\n\n  static equal(collection1, collection2) {\n    return collection1._type === collection2._type && collection1._eventList === collection2._eventList;\n  }\n  /**\n    * Static function to compare two collections to each other. If the collections\n    * are of the same value as each other then equals will return true.\n    *\n    * @param  {Collection} collection1\n    * @param  {Collection} collection2\n    *\n    * @return {bool} result\n    */\n\n\n  static is(collection1, collection2) {\n    return collection1._type === collection2._type && _immutable.default.is(collection1._eventList, collection2._eventList);\n  }\n\n}\n\nvar _default = Collection;\nexports.default = _default;"]},"metadata":{},"sourceType":"script"}