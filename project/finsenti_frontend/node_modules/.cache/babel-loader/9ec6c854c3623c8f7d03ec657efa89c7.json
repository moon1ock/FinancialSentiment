{"ast":null,"code":"\"use strict\";\n\nvar _interopRequireDefault = require(\"@babel/runtime/helpers/interopRequireDefault\");\n\nObject.defineProperty(exports, \"__esModule\", {\n  value: true\n});\nexports.default = void 0;\n\nvar _underscore = _interopRequireDefault(require(\"underscore\"));\n\nvar _processor = _interopRequireDefault(require(\"./processor\"));\n\nvar _pipeline = require(\"../pipeline\");\n\nvar _util = _interopRequireDefault(require(\"../base/util\"));\n/**\n *  Copyright (c) 2016-2017, The Regents of the University of California,\n *  through Lawrence Berkeley National Laboratory (subject to receipt\n *  of any required approvals from the U.S. Dept. of Energy).\n *  All rights reserved.\n *\n *  This source code is licensed under the BSD-style license found in the\n *  LICENSE file in the root directory of this source tree.\n */\n\n/*eslint no-console: 0 */\n\n/**\n * A processor that fills missing/invalid values in the event with\n * new values (zero, interpolated or padded).\n *\n * When doing a linear fill, Filler instances should be chained.\n *\n * If no fieldSpec is supplied, the default field \"value\" will be used.\n */\n\n\nclass Filler extends _processor.default {\n  constructor(arg1, options) {\n    super(arg1, options);\n\n    if (arg1 instanceof Filler) {\n      var other = arg1;\n      this._fieldSpec = other._fieldSpec;\n      this._method = other._method;\n      this._limit = other._limit;\n    } else if ((0, _pipeline.isPipeline)(arg1)) {\n      var {\n        fieldSpec = null,\n        method = \"zero\",\n        limit = null\n      } = options;\n      this._fieldSpec = fieldSpec;\n      this._method = method;\n      this._limit = limit;\n    } else {\n      throw new Error(\"Unknown arg to Filler constructor\", arg1);\n    } //\n    // Internal members\n    //\n    // state for pad to refer to previous event\n\n\n    this._previousEvent = null; // key count for zero and pad fill\n\n    this._keyCount = {}; // special state for linear fill\n\n    this._lastGoodLinear = null; // cache of events pending linear fill\n\n    this._linearFillCache = []; //\n    // Sanity checks\n    //\n\n    if (!_underscore.default.contains([\"zero\", \"pad\", \"linear\"], this._method)) {\n      throw new Error(\"Unknown method \".concat(this._method, \" passed to Filler\"));\n    }\n\n    if (this._limit && !_underscore.default.isNumber(this._limit)) {\n      throw new Error(\"Limit supplied to fill() should be a number\");\n    }\n\n    if (_underscore.default.isString(this._fieldSpec)) {\n      this._fieldSpec = [this._fieldSpec];\n    } else if (_underscore.default.isNull(this._fieldSpec)) {\n      this._fieldSpec = [\"value\"];\n    } // Special case: when using linear mode, only a single\n    // column will be processed per instance\n\n\n    if (this._method === \"linear\" && this._fieldSpec.length > 1) {\n      throw new Error(\"Linear fill takes a path to a single column\");\n    }\n  }\n\n  clone() {\n    return new Filler(this);\n  }\n  /**\n   * Process and fill the values at the paths as apropos when the fill\n   * method is either pad or zero.\n   */\n\n\n  constFill(data) {\n    var newData = data;\n\n    for (var path of this._fieldSpec) {\n      var fieldPath = _util.default.fieldPathToArray(path);\n\n      var pathKey = fieldPath.join(\":\"); //initialize a counter for this column\n\n      if (!_underscore.default.has(this._keyCount, pathKey)) {\n        this._keyCount[pathKey] = 0;\n      } // this is pointing at a path that does not exist\n\n\n      if (!newData.hasIn(fieldPath)) {\n        continue;\n      } // Get the next value using the fieldPath\n\n\n      var val = newData.getIn(fieldPath);\n\n      if (_util.default.isMissing(val)) {\n        // Have we hit the limit?\n        if (this._limit && this._keyCount[pathKey] >= this._limit) {\n          continue;\n        }\n\n        if (this._method === \"zero\") {\n          // set to zero\n          newData = newData.setIn(fieldPath, 0);\n          this._keyCount[pathKey]++;\n        } else if (this._method === \"pad\") {\n          // set to previous value\n          if (!_underscore.default.isNull(this._previousEvent)) {\n            var prevVal = this._previousEvent.data().getIn(fieldPath);\n\n            if (!_util.default.isMissing(prevVal)) {\n              newData = newData.setIn(fieldPath, prevVal);\n              this._keyCount[pathKey]++;\n            }\n          }\n        } else if (this._method === \"linear\") {//noop\n        }\n      } else {\n        this._keyCount[pathKey] = 0;\n      }\n    }\n\n    return newData;\n  }\n  /**\n   * Check to see if an event has good values when doing\n   * linear fill since we need to keep a completely intact\n   * event for the values.\n   * While we are inspecting the data payload, make a note if\n   * any of the paths are pointing at a list. Then it\n   * will trigger that filling code later.\n   */\n\n\n  isValidLinearEvent(event) {\n    var valid = true;\n\n    var fieldPath = _util.default.fieldPathToArray(this._fieldSpec[0]); // Detect path that doesn't exist\n\n\n    if (!event.data().hasIn(fieldPath)) {\n      console.warn(\"path does not exist: \".concat(fieldPath));\n      return valid;\n    }\n\n    var val = event.data().getIn(fieldPath); // Detect if missing or not a number\n\n    if (_util.default.isMissing(val) || !_underscore.default.isNumber(val)) {\n      valid = false;\n    }\n\n    return valid;\n  }\n  /**\n   * This handles the linear filling. It returns a list of\n   * zero or more events to be emitted.\n   *\n   * If an event is valid - it has valid values for all of\n   * the field paths - it is cached as \"last good\" and\n   * returned to be emitted. The return value is then a list\n   * of one event.\n   *\n   * If an event has invalid values, it is cached to be\n   * processed later and an empty list is returned.\n   *\n   * Additional invalid events will continue to be cached until\n   * a new valid value is seen, then the cached events will\n   * be filled and returned. That will be a list of indeterminate\n   * length.\n   */\n\n\n  linearFill(event) {\n    // See if the event is valid and also if it has any\n    // list values to be filled.\n    var isValidEvent = this.isValidLinearEvent(event);\n    var events = [];\n\n    if (isValidEvent && !this._linearFillCache.length) {\n      // Valid event, no cached events, use as last good val\n      this._lastGoodLinear = event;\n      events.push(event);\n    } else if (!isValidEvent && !_underscore.default.isNull(this._lastGoodLinear)) {\n      this._linearFillCache.push(event); // Check limit\n\n\n      if (!_underscore.default.isNull(this._limit) && this._linearFillCache.length >= this._limit) {\n        // Flush the cache now because limit is reached\n        this._linearFillCache.forEach(e => {\n          this.emit(e);\n        }); // Reset\n\n\n        this._linearFillCache = [];\n        this._lastGoodLinear = null;\n      }\n    } else if (!isValidEvent && _underscore.default.isNull(this._lastGoodLinear)) {\n      //\n      // An invalid event but we have not seen a good\n      // event yet so there is nothing to start filling \"from\"\n      // so just return and live with it.\n      //\n      events.push(event);\n    } else if (isValidEvent && this._linearFillCache) {\n      // Linear interpolation between last good and this event\n      var eventList = [this._lastGoodLinear, ...this._linearFillCache, event];\n      var interpolatedEvents = this.interpolateEventList(eventList); //\n      // The first event in the returned list from interpolatedEvents\n      // is our last good event. This event has already been emitted so\n      // it is sliced off.\n      //\n\n      interpolatedEvents.slice(1).forEach(e => {\n        events.push(e);\n      }); // Reset\n\n      this._linearFillCache = [];\n      this._lastGoodLinear = event;\n    }\n\n    return events;\n  }\n  /**\n   * The fundamental linear interpolation workhorse code.  Process\n   * a list of events and return a new list. Does a pass for\n   * every fieldSpec.\n   *\n   * This is abstracted out like this because we probably want\n   * to interpolate a list of events not tied to a Collection.\n   * A Pipeline result list, etc etc.\n   *\n  **/\n\n\n  interpolateEventList(events) {\n    var prevValue;\n    var prevTime; // new array of interpolated events for each field path\n\n    var newEvents = [];\n\n    var fieldPath = _util.default.fieldPathToArray(this._fieldSpec[0]); // setup done, loop through the events\n\n\n    for (var i = 0; i < events.length; i++) {\n      var e = events[i]; // Can't interpolate first or last event so just save it\n      // as is and move on.\n\n      if (i === 0) {\n        prevValue = e.get(fieldPath);\n        prevTime = e.timestamp().getTime();\n        newEvents.push(e);\n        continue;\n      }\n\n      if (i === events.length - 1) {\n        newEvents.push(e);\n        continue;\n      } // Detect non-numeric value\n\n\n      if (!_util.default.isMissing(e.get(fieldPath)) && !_underscore.default.isNumber(e.get(fieldPath))) {\n        console.warn(\"linear requires numeric values - skipping this field_spec\");\n        return events;\n      } // Found a missing value so start calculating.\n\n\n      if (_util.default.isMissing(e.get(fieldPath))) {\n        // Find the next valid value in the original events\n        var ii = i + 1;\n        var nextValue = null;\n        var nextTime = null;\n\n        while (_underscore.default.isNull(nextValue) && ii < events.length) {\n          var val = events[ii].get(fieldPath);\n\n          if (!_util.default.isMissing(val)) {\n            nextValue = val; // exits loop\n\n            nextTime = events[ii].timestamp().getTime();\n          }\n\n          ii++;\n        } // Interpolate a new value to fill\n\n\n        if (!_underscore.default.isNull(prevValue) && ~_underscore.default.isNull(nextValue)) {\n          var currentTime = e.timestamp().getTime();\n\n          if (nextTime === prevTime) {\n            // If times are the same, just avg\n            var newValue = (prevValue + nextValue) / 2;\n            newEvents.push(e.setData(newValue));\n          } else {\n            var f = (currentTime - prevTime) / (nextTime - prevTime);\n\n            var _newValue = prevValue + f * (nextValue - prevValue);\n\n            var d = e.data().setIn(fieldPath, _newValue);\n            newEvents.push(e.setData(d));\n          }\n        } else {\n          newEvents.push(e);\n        }\n      } else {\n        newEvents.push(e);\n      }\n    }\n\n    return newEvents;\n  }\n  /**\n   * Perform the fill operation on the event and emit.\n   */\n\n\n  addEvent(event) {\n    if (this.hasObservers()) {\n      var emitList = [];\n      var d = event.data();\n\n      if (this._method === \"zero\" || this._method === \"pad\") {\n        var dd = this.constFill(d);\n        var e = event.setData(dd);\n        emitList.push(e);\n        this._previousEvent = e;\n      } else if (this._method === \"linear\") {\n        this.linearFill(event).forEach(e => {\n          emitList.push(e);\n        });\n      }\n\n      for (var _event of emitList) {\n        this.emit(_event);\n      }\n    }\n  }\n\n  flush() {\n    if (this.hasObservers() && this._method == \"linear\") {\n      for (var event of this._linearFillCache) {\n        this.emit(event);\n      }\n    }\n\n    super.flush();\n  }\n\n}\n\nexports.default = Filler;","map":{"version":3,"sources":["/Users/nicholasraffone/Documents/swefall2021/finalproj/FinancialSentiment/fin_sentiment_front/node_modules/pondjs/lib/lib/processors/filler.js"],"names":["_interopRequireDefault","require","Object","defineProperty","exports","value","default","_underscore","_processor","_pipeline","_util","Filler","constructor","arg1","options","other","_fieldSpec","_method","_limit","isPipeline","fieldSpec","method","limit","Error","_previousEvent","_keyCount","_lastGoodLinear","_linearFillCache","contains","concat","isNumber","isString","isNull","length","clone","constFill","data","newData","path","fieldPath","fieldPathToArray","pathKey","join","has","hasIn","val","getIn","isMissing","setIn","prevVal","isValidLinearEvent","event","valid","console","warn","linearFill","isValidEvent","events","push","forEach","e","emit","eventList","interpolatedEvents","interpolateEventList","slice","prevValue","prevTime","newEvents","i","get","timestamp","getTime","ii","nextValue","nextTime","currentTime","newValue","setData","f","_newValue","d","addEvent","hasObservers","emitList","dd","_event","flush"],"mappings":"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","sourcesContent":["\"use strict\";\n\nvar _interopRequireDefault = require(\"@babel/runtime/helpers/interopRequireDefault\");\n\nObject.defineProperty(exports, \"__esModule\", {\n  value: true\n});\nexports.default = void 0;\n\nvar _underscore = _interopRequireDefault(require(\"underscore\"));\n\nvar _processor = _interopRequireDefault(require(\"./processor\"));\n\nvar _pipeline = require(\"../pipeline\");\n\nvar _util = _interopRequireDefault(require(\"../base/util\"));\n\n/**\n *  Copyright (c) 2016-2017, The Regents of the University of California,\n *  through Lawrence Berkeley National Laboratory (subject to receipt\n *  of any required approvals from the U.S. Dept. of Energy).\n *  All rights reserved.\n *\n *  This source code is licensed under the BSD-style license found in the\n *  LICENSE file in the root directory of this source tree.\n */\n\n/*eslint no-console: 0 */\n\n/**\n * A processor that fills missing/invalid values in the event with\n * new values (zero, interpolated or padded).\n *\n * When doing a linear fill, Filler instances should be chained.\n *\n * If no fieldSpec is supplied, the default field \"value\" will be used.\n */\nclass Filler extends _processor.default {\n  constructor(arg1, options) {\n    super(arg1, options);\n\n    if (arg1 instanceof Filler) {\n      var other = arg1;\n      this._fieldSpec = other._fieldSpec;\n      this._method = other._method;\n      this._limit = other._limit;\n    } else if ((0, _pipeline.isPipeline)(arg1)) {\n      var {\n        fieldSpec = null,\n        method = \"zero\",\n        limit = null\n      } = options;\n      this._fieldSpec = fieldSpec;\n      this._method = method;\n      this._limit = limit;\n    } else {\n      throw new Error(\"Unknown arg to Filler constructor\", arg1);\n    } //\n    // Internal members\n    //\n    // state for pad to refer to previous event\n\n\n    this._previousEvent = null; // key count for zero and pad fill\n\n    this._keyCount = {}; // special state for linear fill\n\n    this._lastGoodLinear = null; // cache of events pending linear fill\n\n    this._linearFillCache = []; //\n    // Sanity checks\n    //\n\n    if (!_underscore.default.contains([\"zero\", \"pad\", \"linear\"], this._method)) {\n      throw new Error(\"Unknown method \".concat(this._method, \" passed to Filler\"));\n    }\n\n    if (this._limit && !_underscore.default.isNumber(this._limit)) {\n      throw new Error(\"Limit supplied to fill() should be a number\");\n    }\n\n    if (_underscore.default.isString(this._fieldSpec)) {\n      this._fieldSpec = [this._fieldSpec];\n    } else if (_underscore.default.isNull(this._fieldSpec)) {\n      this._fieldSpec = [\"value\"];\n    } // Special case: when using linear mode, only a single\n    // column will be processed per instance\n\n\n    if (this._method === \"linear\" && this._fieldSpec.length > 1) {\n      throw new Error(\"Linear fill takes a path to a single column\");\n    }\n  }\n\n  clone() {\n    return new Filler(this);\n  }\n  /**\n   * Process and fill the values at the paths as apropos when the fill\n   * method is either pad or zero.\n   */\n\n\n  constFill(data) {\n    var newData = data;\n\n    for (var path of this._fieldSpec) {\n      var fieldPath = _util.default.fieldPathToArray(path);\n\n      var pathKey = fieldPath.join(\":\"); //initialize a counter for this column\n\n      if (!_underscore.default.has(this._keyCount, pathKey)) {\n        this._keyCount[pathKey] = 0;\n      } // this is pointing at a path that does not exist\n\n\n      if (!newData.hasIn(fieldPath)) {\n        continue;\n      } // Get the next value using the fieldPath\n\n\n      var val = newData.getIn(fieldPath);\n\n      if (_util.default.isMissing(val)) {\n        // Have we hit the limit?\n        if (this._limit && this._keyCount[pathKey] >= this._limit) {\n          continue;\n        }\n\n        if (this._method === \"zero\") {\n          // set to zero\n          newData = newData.setIn(fieldPath, 0);\n          this._keyCount[pathKey]++;\n        } else if (this._method === \"pad\") {\n          // set to previous value\n          if (!_underscore.default.isNull(this._previousEvent)) {\n            var prevVal = this._previousEvent.data().getIn(fieldPath);\n\n            if (!_util.default.isMissing(prevVal)) {\n              newData = newData.setIn(fieldPath, prevVal);\n              this._keyCount[pathKey]++;\n            }\n          }\n        } else if (this._method === \"linear\") {//noop\n        }\n      } else {\n        this._keyCount[pathKey] = 0;\n      }\n    }\n\n    return newData;\n  }\n  /**\n   * Check to see if an event has good values when doing\n   * linear fill since we need to keep a completely intact\n   * event for the values.\n   * While we are inspecting the data payload, make a note if\n   * any of the paths are pointing at a list. Then it\n   * will trigger that filling code later.\n   */\n\n\n  isValidLinearEvent(event) {\n    var valid = true;\n\n    var fieldPath = _util.default.fieldPathToArray(this._fieldSpec[0]); // Detect path that doesn't exist\n\n\n    if (!event.data().hasIn(fieldPath)) {\n      console.warn(\"path does not exist: \".concat(fieldPath));\n      return valid;\n    }\n\n    var val = event.data().getIn(fieldPath); // Detect if missing or not a number\n\n    if (_util.default.isMissing(val) || !_underscore.default.isNumber(val)) {\n      valid = false;\n    }\n\n    return valid;\n  }\n  /**\n   * This handles the linear filling. It returns a list of\n   * zero or more events to be emitted.\n   *\n   * If an event is valid - it has valid values for all of\n   * the field paths - it is cached as \"last good\" and\n   * returned to be emitted. The return value is then a list\n   * of one event.\n   *\n   * If an event has invalid values, it is cached to be\n   * processed later and an empty list is returned.\n   *\n   * Additional invalid events will continue to be cached until\n   * a new valid value is seen, then the cached events will\n   * be filled and returned. That will be a list of indeterminate\n   * length.\n   */\n\n\n  linearFill(event) {\n    // See if the event is valid and also if it has any\n    // list values to be filled.\n    var isValidEvent = this.isValidLinearEvent(event);\n    var events = [];\n\n    if (isValidEvent && !this._linearFillCache.length) {\n      // Valid event, no cached events, use as last good val\n      this._lastGoodLinear = event;\n      events.push(event);\n    } else if (!isValidEvent && !_underscore.default.isNull(this._lastGoodLinear)) {\n      this._linearFillCache.push(event); // Check limit\n\n\n      if (!_underscore.default.isNull(this._limit) && this._linearFillCache.length >= this._limit) {\n        // Flush the cache now because limit is reached\n        this._linearFillCache.forEach(e => {\n          this.emit(e);\n        }); // Reset\n\n\n        this._linearFillCache = [];\n        this._lastGoodLinear = null;\n      }\n    } else if (!isValidEvent && _underscore.default.isNull(this._lastGoodLinear)) {\n      //\n      // An invalid event but we have not seen a good\n      // event yet so there is nothing to start filling \"from\"\n      // so just return and live with it.\n      //\n      events.push(event);\n    } else if (isValidEvent && this._linearFillCache) {\n      // Linear interpolation between last good and this event\n      var eventList = [this._lastGoodLinear, ...this._linearFillCache, event];\n      var interpolatedEvents = this.interpolateEventList(eventList); //\n      // The first event in the returned list from interpolatedEvents\n      // is our last good event. This event has already been emitted so\n      // it is sliced off.\n      //\n\n      interpolatedEvents.slice(1).forEach(e => {\n        events.push(e);\n      }); // Reset\n\n      this._linearFillCache = [];\n      this._lastGoodLinear = event;\n    }\n\n    return events;\n  }\n  /**\n   * The fundamental linear interpolation workhorse code.  Process\n   * a list of events and return a new list. Does a pass for\n   * every fieldSpec.\n   *\n   * This is abstracted out like this because we probably want\n   * to interpolate a list of events not tied to a Collection.\n   * A Pipeline result list, etc etc.\n   *\n  **/\n\n\n  interpolateEventList(events) {\n    var prevValue;\n    var prevTime; // new array of interpolated events for each field path\n\n    var newEvents = [];\n\n    var fieldPath = _util.default.fieldPathToArray(this._fieldSpec[0]); // setup done, loop through the events\n\n\n    for (var i = 0; i < events.length; i++) {\n      var e = events[i]; // Can't interpolate first or last event so just save it\n      // as is and move on.\n\n      if (i === 0) {\n        prevValue = e.get(fieldPath);\n        prevTime = e.timestamp().getTime();\n        newEvents.push(e);\n        continue;\n      }\n\n      if (i === events.length - 1) {\n        newEvents.push(e);\n        continue;\n      } // Detect non-numeric value\n\n\n      if (!_util.default.isMissing(e.get(fieldPath)) && !_underscore.default.isNumber(e.get(fieldPath))) {\n        console.warn(\"linear requires numeric values - skipping this field_spec\");\n        return events;\n      } // Found a missing value so start calculating.\n\n\n      if (_util.default.isMissing(e.get(fieldPath))) {\n        // Find the next valid value in the original events\n        var ii = i + 1;\n        var nextValue = null;\n        var nextTime = null;\n\n        while (_underscore.default.isNull(nextValue) && ii < events.length) {\n          var val = events[ii].get(fieldPath);\n\n          if (!_util.default.isMissing(val)) {\n            nextValue = val; // exits loop\n\n            nextTime = events[ii].timestamp().getTime();\n          }\n\n          ii++;\n        } // Interpolate a new value to fill\n\n\n        if (!_underscore.default.isNull(prevValue) && ~_underscore.default.isNull(nextValue)) {\n          var currentTime = e.timestamp().getTime();\n\n          if (nextTime === prevTime) {\n            // If times are the same, just avg\n            var newValue = (prevValue + nextValue) / 2;\n            newEvents.push(e.setData(newValue));\n          } else {\n            var f = (currentTime - prevTime) / (nextTime - prevTime);\n\n            var _newValue = prevValue + f * (nextValue - prevValue);\n\n            var d = e.data().setIn(fieldPath, _newValue);\n            newEvents.push(e.setData(d));\n          }\n        } else {\n          newEvents.push(e);\n        }\n      } else {\n        newEvents.push(e);\n      }\n    }\n\n    return newEvents;\n  }\n  /**\n   * Perform the fill operation on the event and emit.\n   */\n\n\n  addEvent(event) {\n    if (this.hasObservers()) {\n      var emitList = [];\n      var d = event.data();\n\n      if (this._method === \"zero\" || this._method === \"pad\") {\n        var dd = this.constFill(d);\n        var e = event.setData(dd);\n        emitList.push(e);\n        this._previousEvent = e;\n      } else if (this._method === \"linear\") {\n        this.linearFill(event).forEach(e => {\n          emitList.push(e);\n        });\n      }\n\n      for (var _event of emitList) {\n        this.emit(_event);\n      }\n    }\n  }\n\n  flush() {\n    if (this.hasObservers() && this._method == \"linear\") {\n      for (var event of this._linearFillCache) {\n        this.emit(event);\n      }\n    }\n\n    super.flush();\n  }\n\n}\n\nexports.default = Filler;"]},"metadata":{},"sourceType":"script"}