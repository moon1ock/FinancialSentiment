{"ast":null,"code":"\"use strict\";\n\nvar _interopRequireDefault = require(\"@babel/runtime/helpers/interopRequireDefault\");\n\nObject.defineProperty(exports, \"__esModule\", {\n  value: true\n});\nexports.Pipeline = pipeline;\nexports.isPipeline = is;\n\nvar _defineProperty2 = _interopRequireDefault(require(\"@babel/runtime/helpers/defineProperty\"));\n\nvar _immutable = _interopRequireDefault(require(\"immutable\"));\n\nvar _underscore = _interopRequireDefault(require(\"underscore\"));\n\nvar _timeevent = _interopRequireDefault(require(\"./timeevent\"));\n\nvar _indexedevent = _interopRequireDefault(require(\"./indexedevent\"));\n\nvar _timerangeevent = _interopRequireDefault(require(\"./timerangeevent\"));\n\nvar _timeseries = _interopRequireDefault(require(\"./timeseries\"));\n\nvar _bounded = _interopRequireDefault(require(\"./io/bounded\"));\n\nvar _collectionout = _interopRequireDefault(require(\"./io/collectionout\"));\n\nvar _eventout = _interopRequireDefault(require(\"./io/eventout\"));\n\nvar _stream = _interopRequireDefault(require(\"./io/stream\"));\n\nvar _aggregator = _interopRequireDefault(require(\"./processors/aggregator\"));\n\nvar _aligner = _interopRequireDefault(require(\"./processors/aligner\"));\n\nvar _collapser = _interopRequireDefault(require(\"./processors/collapser\"));\n\nvar _converter = _interopRequireDefault(require(\"./processors/converter\"));\n\nvar _derivator = _interopRequireDefault(require(\"./processors/derivator\"));\n\nvar _filler = _interopRequireDefault(require(\"./processors/filler\"));\n\nvar _filter = _interopRequireDefault(require(\"./processors/filter\"));\n\nvar _mapper = _interopRequireDefault(require(\"./processors/mapper\"));\n\nvar _offset = _interopRequireDefault(require(\"./processors/offset\"));\n\nvar _processor = _interopRequireDefault(require(\"./processors/processor\"));\n\nvar _selector = _interopRequireDefault(require(\"./processors/selector\"));\n\nvar _taker = _interopRequireDefault(require(\"./processors/taker\"));\n\nfunction ownKeys(object, enumerableOnly) {\n  var keys = Object.keys(object);\n\n  if (Object.getOwnPropertySymbols) {\n    var symbols = Object.getOwnPropertySymbols(object);\n    if (enumerableOnly) symbols = symbols.filter(function (sym) {\n      return Object.getOwnPropertyDescriptor(object, sym).enumerable;\n    });\n    keys.push.apply(keys, symbols);\n  }\n\n  return keys;\n}\n\nfunction _objectSpread(target) {\n  for (var i = 1; i < arguments.length; i++) {\n    var source = arguments[i] != null ? arguments[i] : {};\n\n    if (i % 2) {\n      ownKeys(source, true).forEach(function (key) {\n        (0, _defineProperty2.default)(target, key, source[key]);\n      });\n    } else if (Object.getOwnPropertyDescriptors) {\n      Object.defineProperties(target, Object.getOwnPropertyDescriptors(source));\n    } else {\n      ownKeys(source).forEach(function (key) {\n        Object.defineProperty(target, key, Object.getOwnPropertyDescriptor(source, key));\n      });\n    }\n  }\n\n  return target;\n}\n/**\n * A runner is used to extract the chain of processing operations\n * from a Pipeline given an Output. The idea here is to traverse\n * back up the Pipeline(s) and build an execution chain.\n *\n * When the runner is started, events from the \"in\" are streamed\n * into the execution chain and outputed into the \"out\".\n *\n * Rebuilding in this way enables us to handle connected pipelines:\n *\n *                     |--\n *  in --> pipeline ---.\n *                     |----pipeline ---| -> out\n *\n * The runner breaks this into the following for execution:\n *\n *   _input        - the \"in\" or from() bounded input of\n *                   the upstream pipeline\n *   _processChain - the process nodes in the pipelines\n *                   leading to the out\n *   _output       - the supplied output destination for\n *                   the batch process\n *\n * NOTE: There's no current way to merge multiple sources, though\n *       a time series has a TimeSeries.merge() static method for\n *       this purpose.\n */\n\n\nclass Runner {\n  /**\n   * Create a new batch runner.\n   * @param  {Pipeline} pipeline The pipeline to run\n   * @param  {PipelineOut} output   The output driving this runner\n   */\n  constructor(pipeline, output) {\n    this._output = output;\n    this._pipeline = pipeline; //\n    // We use the pipeline's chain() function to walk the\n    // DAG back up the tree to the \"in\" to:\n    // 1) assemble a list of process nodes that feed into\n    //    this pipeline, the processChain\n    // 2) determine the _input\n    //\n    // TODO: we do not currently support merging, so this is\n    // a linear chain.\n    //\n\n    var processChain = [];\n\n    if (pipeline.last()) {\n      processChain = pipeline.last().chain();\n      this._input = processChain[0].pipeline().in();\n    } else {\n      this._input = pipeline.in();\n    } //\n    // Using the list of nodes in the tree that will be involved in\n    // our processing we can build an execution chain. This is the\n    // chain of processor clones, linked together, for our specific\n    // processing pipeline. We run this execution chain later by\n    // evoking start().\n    //\n\n\n    this._executionChain = [this._output];\n    var prev = this._output;\n    processChain.forEach(p => {\n      if (p instanceof _processor.default) {\n        var processor = p.clone();\n        if (prev) processor.addObserver(prev);\n\n        this._executionChain.push(processor);\n\n        prev = processor;\n      }\n    });\n  }\n  /**\n   * Start the runner\n   * @param  {Boolean} force Force a flush at the end of the batch source\n   *                         to cause any buffers to emit.\n   */\n\n\n  start() {\n    var force = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : false; // Clear any results ready for the run\n\n    this._pipeline.clearResults(); //\n    // The head is the first process node in the execution chain.\n    // To process the source through the execution chain we add\n    // each event from the input to the head.\n    //\n\n\n    var head = this._executionChain.pop();\n\n    for (var e of this._input.events()) {\n      head.addEvent(e);\n    } //\n    // The runner indicates that it is finished with the bounded\n    // data by sending a flush() call down the chain. If force is\n    // set to false (the default) this is never called.\n    //\n\n\n    if (force) {\n      head.flush();\n    }\n  }\n\n}\n/**\n * A pipeline manages a processing chain, for either batch or stream processing\n * of collection data.\n */\n\n\nclass Pipeline {\n  /**\n   * Build a new Pipeline.\n   *\n   * @param  {Pipeline|Immutable.Map|null} [arg] May be either:\n   *  * a Pipeline (copy contructor)\n   *  * an Immutable.Map, in which case the internal state of the\n   *    Pipeline will be contructed from the Map\n   *  * not specified\n   *\n   * Usually you would initialize a Pipeline using the factory\n   * function, rather than this object directly with `new`.\n   *\n   * @example\n   * ```\n   * import { Pipeline } from \"pondjs\";\n   * const p = Pipeline()...`\n   * ```\n   *\n   * @return {Pipeline} The Pipeline\n   */\n  constructor(arg) {\n    if (arg instanceof Pipeline) {\n      var other = arg;\n      this._d = other._d;\n    } else if (arg instanceof _immutable.default.Map) {\n      this._d = arg;\n    } else {\n      this._d = new _immutable.default.Map({\n        type: null,\n        in: null,\n        first: null,\n        last: null,\n        groupBy: () => \"\",\n        windowType: \"global\",\n        windowDuration: null,\n        emitOn: \"eachEvent\"\n      });\n    }\n\n    this._results = [];\n  } //\n  // Accessors to the current Pipeline state\n  //\n\n\n  in() {\n    return this._d.get(\"in\");\n  }\n\n  mode() {\n    return this._d.get(\"mode\");\n  }\n\n  first() {\n    return this._d.get(\"first\");\n  }\n\n  last() {\n    return this._d.get(\"last\");\n  }\n\n  getWindowType() {\n    return this._d.get(\"windowType\");\n  }\n\n  getWindowDuration() {\n    return this._d.get(\"windowDuration\");\n  }\n\n  getGroupBy() {\n    return this._d.get(\"groupBy\");\n  }\n\n  getEmitOn() {\n    return this._d.get(\"emitOn\");\n  } //\n  // Results\n  //\n\n\n  clearResults() {\n    this._resultsDone = false;\n    this._results = null;\n  }\n\n  addResult(arg1, arg2) {\n    if (!this._results) {\n      if (_underscore.default.isString(arg1) && arg2) {\n        this._results = {};\n      } else {\n        this._results = [];\n      }\n    }\n\n    if (_underscore.default.isString(arg1) && arg2) {\n      this._results[arg1] = arg2;\n    } else {\n      this._results.push(arg1);\n    }\n\n    this._resultsDone = false;\n  }\n\n  resultsDone() {\n    this._resultsDone = true;\n  } //\n  // Pipeline mutations\n  //\n\n  /**\n   * Setting the In for the Pipeline returns a new Pipeline\n   *\n   * @private\n   */\n\n\n  _setIn(input) {\n    var mode;\n    var source = input;\n\n    if (input instanceof _timeseries.default) {\n      mode = \"batch\";\n      source = input.collection();\n    } else if (input instanceof _bounded.default) {\n      mode = \"batch\";\n    } else if (input instanceof _stream.default) {\n      mode = \"stream\";\n    } else {\n      throw new Error(\"Unknown input type\", input);\n    }\n\n    var d = this._d.withMutations(map => {\n      map.set(\"in\", source).set(\"mode\", mode);\n    });\n\n    return new Pipeline(d);\n  }\n  /**\n   * Set the first processing node pointed to, returning\n   * a new Pipeline. The original pipeline will still point\n   * to its orginal processing node.\n   *\n   * @private\n   */\n\n\n  _setFirst(n) {\n    var d = this._d.set(\"first\", n);\n\n    return new Pipeline(d);\n  }\n  /**\n   * Set the last processing node pointed to, returning\n   * a new Pipeline. The original pipeline will still point\n   * to its orginal processing node.\n   *\n   * @private\n   */\n\n\n  _setLast(n) {\n    var d = this._d.set(\"last\", n);\n\n    return new Pipeline(d);\n  }\n  /**\n   * @private\n   */\n\n\n  _append(processor) {\n    var first = this.first();\n    var last = this.last();\n    if (!first) first = processor;\n    if (last) last.addObserver(processor);\n    last = processor;\n\n    var d = this._d.withMutations(map => {\n      map.set(\"first\", first).set(\"last\", last);\n    });\n\n    return new Pipeline(d);\n  }\n\n  _chainPrev() {\n    return this.last() || this;\n  } //\n  // Pipeline state chained methods\n  //\n\n  /**\n   * Set the window, returning a new Pipeline. A new window will\n   * have a type and duration associated with it. Current available\n   * types are:\n   *   * fixed (e.g. every 5m)\n   *   * calendar based windows (e.g. every month)\n   *\n   * Windows are a type of grouping. Typically you'd define a window\n   * on the pipeline before doing an aggregation or some other operation\n   * on the resulting grouped collection. You can combine window-based\n   * grouping with key-grouping (see groupBy()).\n   *\n   * There are several ways to define a window. The general format is\n   * an options object containing a `type` field and a `duration` field.\n   *\n   * Currently the only accepted type is `fixed`, but others are planned.\n   * For duration, this is a duration string, for example \"30s\" or \"1d\".\n   * Supported are: seconds (s), minutes (m), hours (h) and days (d).\n   *\n   * If no arg is supplied, the window type is set to 'global' and there\n   * is no duration.\n   *\n   * There is also a short-cut notation for a fixed window or a calendar\n   * window. Simply supplying the duration string (\"30s\" for example) will\n   * result in a `fixed` window type with the supplied duration.\n   *\n   * Calendar types are specified by simply specifying \"daily\", \"monthly\"\n   * or \"yearly\".\n   *\n   * @param {string|object} w Window or duration - See above\n   * @return {Pipeline} The Pipeline\n   */\n\n\n  windowBy(w) {\n    var type, duration;\n\n    if (_underscore.default.isString(w)) {\n      if (w === \"daily\" || w === \"monthly\" || w === \"yearly\") {\n        type = w;\n      } else {\n        // assume fixed window with size w\n        type = \"fixed\";\n        duration = w;\n      }\n    } else if (_underscore.default.isObject(w)) {\n      type = w.type;\n      duration = w.duration;\n    } else {\n      type = \"global\";\n      duration = null;\n    }\n\n    var d = this._d.withMutations(map => {\n      map.set(\"windowType\", type).set(\"windowDuration\", duration);\n    });\n\n    return new Pipeline(d);\n  }\n  /**\n   * Remove windowing from the Pipeline. This will\n   * return the pipeline to no window grouping. This is\n   * useful if you have first done some aggregated by\n   * some window size and then wish to collect together\n   * the all resulting events.\n   *\n   * @return {Pipeline} The Pipeline\n   */\n\n\n  clearWindow() {\n    return this.windowBy();\n  }\n  /**\n   * Sets a new key grouping. Returns a new Pipeline.\n   *\n   * Grouping is a state set on the Pipeline. Operations downstream\n   * of the group specification will use that state. For example, an\n   * aggregation would occur over any grouping specified. You can\n   * combine a key grouping with windowing (see windowBy()).\n   *\n   * Note: the key, if it is a field path, is not a list of multiple\n   * columns, it is the path to a single column to pull group by keys\n   * from. For example, a column called 'status' that contains the\n   * values 'OK' and 'FAIL' - then the key would be 'status' and two\n   * collections OK and FAIL will be generated.\n   *\n   * @param {function|array|string}   k   The key to group by.\n   *                                      You can groupBy using a function\n   *                                      `(event) => return key`,\n   *                                      a field path (a field name, or dot\n   *                                      delimitted path to a field),\n   *                                      or a array of field paths.\n   *\n   * @return {Pipeline}                   The Pipeline\n   */\n\n\n  groupBy(k) {\n    var grp;\n    var groupBy = k || \"value\";\n\n    if (_underscore.default.isFunction(groupBy)) {\n      // group using a user defined function\n      // (event) => key\n      grp = groupBy;\n    } else if (_underscore.default.isArray(groupBy)) {\n      // group by several column values\n      grp = e => _underscore.default.map(groupBy, c => \"\".concat(e.get(c))).join(\"::\");\n    } else if (_underscore.default.isString(groupBy)) {\n      // group by a column value\n      grp = e => \"\".concat(e.get(groupBy));\n    } else {\n      // Reset to no grouping\n      grp = () => \"\";\n    }\n\n    var d = this._d.withMutations(map => {\n      map.set(\"groupBy\", grp);\n    });\n\n    return new Pipeline(d);\n  }\n  /**\n   * Remove the grouping from the pipeline. In other words\n   * recombine the events.\n   *\n   * @return {Pipeline} The Pipeline\n   */\n\n\n  clearGroupBy() {\n    return this.groupBy();\n  }\n  /**\n   * Sets the condition under which an accumulated collection will\n   * be emitted. If specified before an aggregation this will control\n   * when the resulting event will be emitted relative to the\n   * window accumulation. Current options are:\n   *  * to emit on every event, or\n   *  * just when the collection is complete, or\n   *  * when a flush signal is received, either manually calling done(),\n   *    or at the end of a bounded source\n   *\n   * The difference will depend on the output you want, how often\n   * you want to get updated, and if you need to get a partial state.\n   * There's currently no support for late data or watermarks. If an\n   * event passes comes in after a collection window, that collection\n   * is considered finished.\n   *\n   * @param {string} trigger A string indicating how to trigger a\n   * Collection should be emitted. May be:\n   *     * \"eachEvent\" - when a new event comes in, all currently\n   *                     maintained collections will emit their result\n   *     * \"discard\"   - when a collection is to be discarded,\n   *                     first it will emit. But only then.\n   *     * \"flush\"     - when a flush signal is received\n   *\n   * @return {Pipeline} The Pipeline\n   */\n\n\n  emitOn(trigger) {\n    var d = this._d.set(\"emitOn\", trigger);\n\n    return new Pipeline(d);\n  } //\n  // I/O\n  //\n\n  /**\n   * The source to get events from. The source needs to be able to\n   * iterate its events using `for..of` loop for bounded Ins, or\n   * be able to emit() for unbounded Ins. The actual batch, or stream\n   * connection occurs when an output is defined with `to()`.\n   *\n   * Pipelines can be chained together since a source may be another\n   * Pipeline.\n   *\n   * @param {Bounded|Stream} src The source for the Pipeline\n   * @return {Pipeline} The Pipeline\n   */\n\n\n  from(src) {\n    return this._setIn(src);\n  }\n  /**\n   * Directly return the results from the processor rather than\n   * feeding to a callback. This breaks the chain, causing a result to\n   * be returned (the array of events) rather than a reference to the\n   * Pipeline itself. This function is only available for sync batch\n   * processing.\n   *\n   * @return {array|map}     Returns the _results attribute from a Pipeline\n   *                         object after processing. Will contain Collection\n   *                         objects.\n   */\n\n\n  toEventList() {\n    return this.to(_eventout.default);\n  }\n  /**\n   * Directly return the results from the processor rather than\n   * passing a callback in. This breaks the chain, causing a result to\n   * be returned (the collections) rather than a reference to the\n   * Pipeline itself. This function is only available for sync batch\n   * processing.\n   *\n   * @return {array|map}     Returns the _results attribute from a Pipeline\n   *                         object after processing. Will contain Collection\n   *                         objects.\n   */\n\n\n  toKeyedCollections() {\n    var result = this.to(_collectionout.default);\n\n    if (result) {\n      return result;\n    } else {\n      return {};\n    }\n  }\n  /**\n   * Sets up the destination sink for the pipeline.\n   *\n   * For a batch mode connection, i.e. one with a Bounded source,\n   * the output is connected to a clone of the parts of the Pipeline dependencies\n   * that lead to this output. This is done by a Runner. The source input is\n   * then iterated over to process all events into the pipeline and though to the Out.\n   *\n   * For stream mode connections, the output is connected and from then on\n   * any events added to the input will be processed down the pipeline to\n   * the out.\n   *\n   * @example\n   * ```\n   * const p = Pipeline()\n   *  ...\n   *  .to(EventOut, {}, event => {\n   *      result[`${event.index()}`] = event;\n   *  });\n   * ```\n   * @return {Pipeline} The Pipeline\n   */\n\n\n  to(arg1, arg2, arg3) {\n    var Out = arg1;\n    var observer;\n    var options = {};\n\n    if (_underscore.default.isFunction(arg2)) {\n      observer = arg2;\n    } else if (_underscore.default.isObject(arg2)) {\n      options = arg2;\n      observer = arg3;\n    }\n\n    if (!this.in()) {\n      throw new Error(\"Tried to eval pipeline without a In. Missing from() in chain?\");\n    }\n\n    var out = new Out(this, options, observer);\n\n    if (this.mode() === \"batch\") {\n      var runner = new Runner(this, out);\n      runner.start(true);\n\n      if (this._resultsDone && !observer) {\n        return this._results;\n      }\n    } else if (this.mode() === \"stream\") {\n      var _out = new Out(this, options, observer);\n\n      if (this.first()) {\n        this.in().addObserver(this.first());\n      }\n\n      if (this.last()) {\n        this.last().addObserver(_out);\n      } else {\n        this.in().addObserver(_out);\n      }\n    }\n\n    return this;\n  }\n  /**\n   * Outputs the count of events\n   *\n   * @param  {function}  observer The callback function. This will be\n   *                              passed the count, the windowKey and\n   *                              the groupByKey\n   * @param  {Boolean} force    Flush at the end of processing batch\n   *                            events, output again with possibly partial\n   *                            result.\n   * @return {Pipeline} The Pipeline\n   */\n\n\n  count(observer) {\n    var force = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : true;\n    return this.to(_collectionout.default, (collection, windowKey, groupByKey) => {\n      observer(collection.size(), windowKey, groupByKey);\n    }, force);\n  } //\n  // Processors\n  //\n\n  /**\n   * Processor to offset a set of fields by a value. Mostly used for\n   * testing processor and pipeline operations with a simple operation.\n   *\n   * @param  {number} by              The amount to offset by\n   * @param  {string|array} fieldSpec The field(s)\n   *\n   * @return {Pipeline}               The modified Pipeline\n   */\n\n\n  offsetBy(by, fieldSpec) {\n    var p = new _offset.default(this, {\n      by,\n      fieldSpec,\n      prev: this._chainPrev()\n    });\n    return this._append(p);\n  }\n  /**\n   * Uses the current Pipeline windowing and grouping\n   * state to build collections of events and aggregate them.\n   *\n   * `IndexedEvent`s will be emitted out of the aggregator based\n   * on the `emitOn` state of the Pipeline.\n   *\n   * To specify what part of the incoming events should\n   * be aggregated together you specify a `fields`\n   * object. This is a map from fieldName to operator.\n   *\n   * @example\n   *\n   * ```\n   * import { Pipeline, EventOut, functions } from \"pondjs\";\n   * const { avg } = functions;\n   *\n   * const p = Pipeline()\n   *   .from(input)\n   *   .windowBy(\"1h\")           // 1 day fixed windows\n   *   .emitOn(\"eachEvent\")      // emit result on each event\n   *   .aggregate({\n   *      in_avg: {in: avg},\n   *      out_avg: {in: avg}\n   *   })\n   *   .asTimeEvents()\n   *   .to(EventOut, {}, event => {\n   *      result[`${event.index()}`] = event; // Result\n   *   });\n   * ```\n   *\n   * @param  {object} fields Fields and operators to be aggregated\n   *\n   * @return {Pipeline} The Pipeline\n   */\n\n\n  aggregate(fields) {\n    var p = new _aggregator.default(this, {\n      fields,\n      prev: this._chainPrev()\n    });\n    return this._append(p);\n  }\n  /**\n   * Converts incoming TimeRangeEvents or IndexedEvents to\n   * TimeEvents. This is helpful since some processors,\n   * especially aggregators, will emit TimeRangeEvents or\n   * IndexedEvents, which may be unsuitable for some applications.\n   *\n   * @param  {object} options To convert to an TimeEvent you need\n   * to convert a time range to a single time. There are three options:\n   *  1. use the beginning time (options = {alignment: \"lag\"})\n   *  2. use the center time (options = {alignment: \"center\"})\n   *  3. use the end time (options = {alignment: \"lead\"})\n   *\n   * @return {Pipeline} The Pipeline\n   */\n\n\n  asTimeEvents(options) {\n    var type = _timeevent.default;\n    var p = new _converter.default(this, _objectSpread({\n      type\n    }, options, {\n      prev: this._chainPrev()\n    }));\n    return this._append(p);\n  }\n  /**\n   * Map the event stream using an operator\n   *\n   * @param  {function} op A function that returns a new Event\n   *\n   * @return {Pipeline} The Pipeline\n   */\n\n\n  map(op) {\n    var p = new _mapper.default(this, {\n      op,\n      prev: this._chainPrev()\n    });\n    return this._append(p);\n  }\n  /**\n   * Filter the event stream using an operator\n   *\n   * @param  {function} op A function that returns true or false\n   *\n   * @return {Pipeline} The Pipeline\n   */\n\n\n  filter(op) {\n    var p = new _filter.default(this, {\n      op,\n      prev: this._chainPrev()\n    });\n    return this._append(p);\n  }\n  /**\n   * Select a subset of columns\n   *\n   * @param {string|array} fieldSpec  Column or columns to look up. If you need\n   *                                  to retrieve multiple deep nested values that\n   *                                  ['can.be', 'done.with', 'this.notation'].\n   *                                  A single deep value with a string.like.this.\n   *                                  If not supplied, the 'value' column will be used.\n   *\n   * @return {Pipeline} The Pipeline\n   */\n\n\n  select(fieldSpec) {\n    var p = new _selector.default(this, {\n      fieldSpec,\n      prev: this._chainPrev()\n    });\n    return this._append(p);\n  }\n  /**\n   * Collapse a subset of columns using a reducer function\n   *\n   * @example\n   *\n   * ```\n   *  const timeseries = new TimeSeries(inOutData);\n   *  Pipeline()\n   *      .from(timeseries)\n   *      .collapse([\"in\", \"out\"], \"in_out_sum\", sum)\n   *      .emitOn(\"flush\")\n   *      .to(CollectionOut, c => {\n   *           const ts = new TimeSeries({name: \"subset\", collection: c});\n   *           ...\n   *      }, true);\n   * ```\n   * @param {string|array} fieldSpecList  Column or columns to collapse. If you need\n   *                                      to retrieve multiple deep nested values that\n   *                                      ['can.be', 'done.with', 'this.notation'].\n   * @param {string}       name       The resulting output column's name\n   * @param {function}     reducer    Function to use to do the reduction\n   * @param {boolean}      append     Add the new column to the existing ones,\n   *                                  or replace them.\n   *\n   * @return {Pipeline}               The Pipeline\n   */\n\n\n  collapse(fieldSpecList, name, reducer, append) {\n    var p = new _collapser.default(this, {\n      fieldSpecList,\n      name,\n      reducer,\n      append,\n      prev: this._chainPrev()\n    });\n    return this._append(p);\n  }\n  /**\n   * Take the data in this event steam and \"fill\" any missing\n   * or invalid values. This could be setting `null` values to `0`\n   * so mathematical operations will succeed, interpolate a new\n   * value, or pad with the previously given value.\n   *\n   * If one wishes to limit the number of filled events in the result\n   * set, use Pipeline.keep() in the chain. See: TimeSeries.fill()\n   * for an example.\n   *\n   * Fill takes a single arg `options` which should be composed of:\n   *  * fieldSpec - Column or columns to look up. If you need\n   *                to retrieve multiple deep nested values that\n   *                ['can.be', 'done.with', 'this.notation'].\n   *                A single deep value with a string.like.this.\n   *  * method -    Filling method: zero | linear | pad\n   *\n   * @return {Pipeline}               The Pipeline\n   */\n\n\n  fill(_ref) {\n    var {\n      fieldSpec = null,\n      method = \"linear\",\n      limit = null\n    } = _ref;\n\n    var prev = this._chainPrev();\n\n    return this._append(new _filler.default(this, {\n      fieldSpec,\n      method,\n      limit,\n      prev\n    }));\n  }\n\n  align(fieldSpec, window, method, limit) {\n    var prev = this._chainPrev();\n\n    return this._append(new _aligner.default(this, {\n      fieldSpec,\n      window,\n      method,\n      limit,\n      prev\n    }));\n  }\n\n  rate(fieldSpec) {\n    var allowNegative = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : true;\n    var p = new _derivator.default(this, {\n      fieldSpec,\n      allowNegative,\n      prev: this._chainPrev()\n    });\n    return this._append(p);\n  }\n  /**\n   * Take events up to the supplied limit, per key.\n   *\n   * @param  {number} limit Integer number of events to take\n   *\n   * @return {Pipeline} The Pipeline\n   */\n\n\n  take(limit) {\n    var p = new _taker.default(this, {\n      limit,\n      prev: this._chainPrev()\n    });\n    return this._append(p);\n  }\n  /**\n   * Converts incoming Events or IndexedEvents to TimeRangeEvents.\n   *\n   * @param {object} options To convert from an Event you need\n   * to convert a single time to a time range. To control this you\n   * need to specify the duration of that time range, along with\n   * the positioning (alignment) of the time range with respect to\n   * the time stamp of the Event.\n   *\n   * There are three option for alignment:\n   *  1. time range will be in front of the timestamp (options = {alignment: \"front\"})\n   *  2. time range will be centered on the timestamp (options = {alignment: \"center\"})\n   *  3. time range will be positoned behind the timestamp (options = {alignment: \"behind\"})\n   *\n   * The duration is of the form \"1h\" for one hour, \"30s\" for 30 seconds and so on.\n   *\n   * @return {Pipeline} The Pipeline\n   */\n\n\n  asTimeRangeEvents(options) {\n    var type = _timerangeevent.default;\n    var p = new _converter.default(this, _objectSpread({\n      type\n    }, options, {\n      prev: this._chainPrev()\n    }));\n    return this._append(p);\n  }\n  /**\n   * Converts incoming Events to IndexedEvents.\n   *\n   * Note: It isn't possible to convert TimeRangeEvents to IndexedEvents.\n   *\n   * @param {Object} options            An object containing the conversion\n   * options. In this case the duration string of the Index is expected.\n   * @param {string} options.duration   The duration string is of the form \"1h\" for one hour, \"30s\"\n   * for 30 seconds and so on.\n   *\n   * @return {Pipeline} The Pipeline\n   */\n\n\n  asIndexedEvents(options) {\n    var type = _indexedevent.default;\n    var p = new _converter.default(this, _objectSpread({\n      type\n    }, options, {\n      prev: this._chainPrev()\n    }));\n    return this._append(p);\n  }\n\n}\n\nfunction pipeline(args) {\n  return new Pipeline(args);\n}\n\nfunction is(p) {\n  return p instanceof Pipeline;\n}","map":{"version":3,"sources":["/Users/nicholasraffone/Documents/swefall2021/finalproj/FinancialSentiment/fin_sentiment_front/node_modules/pondjs/lib/lib/pipeline.js"],"names":["_interopRequireDefault","require","Object","defineProperty","exports","value","Pipeline","pipeline","isPipeline","is","_defineProperty2","_immutable","_underscore","_timeevent","_indexedevent","_timerangeevent","_timeseries","_bounded","_collectionout","_eventout","_stream","_aggregator","_aligner","_collapser","_converter","_derivator","_filler","_filter","_mapper","_offset","_processor","_selector","_taker","ownKeys","object","enumerableOnly","keys","getOwnPropertySymbols","symbols","filter","sym","getOwnPropertyDescriptor","enumerable","push","apply","_objectSpread","target","i","arguments","length","source","forEach","key","default","getOwnPropertyDescriptors","defineProperties","Runner","constructor","output","_output","_pipeline","processChain","last","chain","_input","in","_executionChain","prev","p","processor","clone","addObserver","start","force","undefined","clearResults","head","pop","e","events","addEvent","flush","arg","other","_d","Map","type","first","groupBy","windowType","windowDuration","emitOn","_results","get","mode","getWindowType","getWindowDuration","getGroupBy","getEmitOn","_resultsDone","addResult","arg1","arg2","isString","resultsDone","_setIn","input","collection","Error","d","withMutations","map","set","_setFirst","n","_setLast","_append","_chainPrev","windowBy","w","duration","isObject","clearWindow","k","grp","isFunction","isArray","c","concat","join","clearGroupBy","trigger","from","src","toEventList","to","toKeyedCollections","result","arg3","Out","observer","options","out","runner","_out","count","windowKey","groupByKey","size","offsetBy","by","fieldSpec","aggregate","fields","asTimeEvents","op","select","collapse","fieldSpecList","name","reducer","append","fill","_ref","method","limit","align","window","rate","allowNegative","take","asTimeRangeEvents","asIndexedEvents","args"],"mappings":"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","sourcesContent":["\"use strict\";\n\nvar _interopRequireDefault = require(\"@babel/runtime/helpers/interopRequireDefault\");\n\nObject.defineProperty(exports, \"__esModule\", {\n  value: true\n});\nexports.Pipeline = pipeline;\nexports.isPipeline = is;\n\nvar _defineProperty2 = _interopRequireDefault(require(\"@babel/runtime/helpers/defineProperty\"));\n\nvar _immutable = _interopRequireDefault(require(\"immutable\"));\n\nvar _underscore = _interopRequireDefault(require(\"underscore\"));\n\nvar _timeevent = _interopRequireDefault(require(\"./timeevent\"));\n\nvar _indexedevent = _interopRequireDefault(require(\"./indexedevent\"));\n\nvar _timerangeevent = _interopRequireDefault(require(\"./timerangeevent\"));\n\nvar _timeseries = _interopRequireDefault(require(\"./timeseries\"));\n\nvar _bounded = _interopRequireDefault(require(\"./io/bounded\"));\n\nvar _collectionout = _interopRequireDefault(require(\"./io/collectionout\"));\n\nvar _eventout = _interopRequireDefault(require(\"./io/eventout\"));\n\nvar _stream = _interopRequireDefault(require(\"./io/stream\"));\n\nvar _aggregator = _interopRequireDefault(require(\"./processors/aggregator\"));\n\nvar _aligner = _interopRequireDefault(require(\"./processors/aligner\"));\n\nvar _collapser = _interopRequireDefault(require(\"./processors/collapser\"));\n\nvar _converter = _interopRequireDefault(require(\"./processors/converter\"));\n\nvar _derivator = _interopRequireDefault(require(\"./processors/derivator\"));\n\nvar _filler = _interopRequireDefault(require(\"./processors/filler\"));\n\nvar _filter = _interopRequireDefault(require(\"./processors/filter\"));\n\nvar _mapper = _interopRequireDefault(require(\"./processors/mapper\"));\n\nvar _offset = _interopRequireDefault(require(\"./processors/offset\"));\n\nvar _processor = _interopRequireDefault(require(\"./processors/processor\"));\n\nvar _selector = _interopRequireDefault(require(\"./processors/selector\"));\n\nvar _taker = _interopRequireDefault(require(\"./processors/taker\"));\n\nfunction ownKeys(object, enumerableOnly) { var keys = Object.keys(object); if (Object.getOwnPropertySymbols) { var symbols = Object.getOwnPropertySymbols(object); if (enumerableOnly) symbols = symbols.filter(function (sym) { return Object.getOwnPropertyDescriptor(object, sym).enumerable; }); keys.push.apply(keys, symbols); } return keys; }\n\nfunction _objectSpread(target) { for (var i = 1; i < arguments.length; i++) { var source = arguments[i] != null ? arguments[i] : {}; if (i % 2) { ownKeys(source, true).forEach(function (key) { (0, _defineProperty2.default)(target, key, source[key]); }); } else if (Object.getOwnPropertyDescriptors) { Object.defineProperties(target, Object.getOwnPropertyDescriptors(source)); } else { ownKeys(source).forEach(function (key) { Object.defineProperty(target, key, Object.getOwnPropertyDescriptor(source, key)); }); } } return target; }\n\n/**\n * A runner is used to extract the chain of processing operations\n * from a Pipeline given an Output. The idea here is to traverse\n * back up the Pipeline(s) and build an execution chain.\n *\n * When the runner is started, events from the \"in\" are streamed\n * into the execution chain and outputed into the \"out\".\n *\n * Rebuilding in this way enables us to handle connected pipelines:\n *\n *                     |--\n *  in --> pipeline ---.\n *                     |----pipeline ---| -> out\n *\n * The runner breaks this into the following for execution:\n *\n *   _input        - the \"in\" or from() bounded input of\n *                   the upstream pipeline\n *   _processChain - the process nodes in the pipelines\n *                   leading to the out\n *   _output       - the supplied output destination for\n *                   the batch process\n *\n * NOTE: There's no current way to merge multiple sources, though\n *       a time series has a TimeSeries.merge() static method for\n *       this purpose.\n */\nclass Runner {\n  /**\n   * Create a new batch runner.\n   * @param  {Pipeline} pipeline The pipeline to run\n   * @param  {PipelineOut} output   The output driving this runner\n   */\n  constructor(pipeline, output) {\n    this._output = output;\n    this._pipeline = pipeline; //\n    // We use the pipeline's chain() function to walk the\n    // DAG back up the tree to the \"in\" to:\n    // 1) assemble a list of process nodes that feed into\n    //    this pipeline, the processChain\n    // 2) determine the _input\n    //\n    // TODO: we do not currently support merging, so this is\n    // a linear chain.\n    //\n\n    var processChain = [];\n\n    if (pipeline.last()) {\n      processChain = pipeline.last().chain();\n      this._input = processChain[0].pipeline().in();\n    } else {\n      this._input = pipeline.in();\n    } //\n    // Using the list of nodes in the tree that will be involved in\n    // our processing we can build an execution chain. This is the\n    // chain of processor clones, linked together, for our specific\n    // processing pipeline. We run this execution chain later by\n    // evoking start().\n    //\n\n\n    this._executionChain = [this._output];\n    var prev = this._output;\n    processChain.forEach(p => {\n      if (p instanceof _processor.default) {\n        var processor = p.clone();\n        if (prev) processor.addObserver(prev);\n\n        this._executionChain.push(processor);\n\n        prev = processor;\n      }\n    });\n  }\n  /**\n   * Start the runner\n   * @param  {Boolean} force Force a flush at the end of the batch source\n   *                         to cause any buffers to emit.\n   */\n\n\n  start() {\n    var force = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : false;\n\n    // Clear any results ready for the run\n    this._pipeline.clearResults(); //\n    // The head is the first process node in the execution chain.\n    // To process the source through the execution chain we add\n    // each event from the input to the head.\n    //\n\n\n    var head = this._executionChain.pop();\n\n    for (var e of this._input.events()) {\n      head.addEvent(e);\n    } //\n    // The runner indicates that it is finished with the bounded\n    // data by sending a flush() call down the chain. If force is\n    // set to false (the default) this is never called.\n    //\n\n\n    if (force) {\n      head.flush();\n    }\n  }\n\n}\n/**\n * A pipeline manages a processing chain, for either batch or stream processing\n * of collection data.\n */\n\n\nclass Pipeline {\n  /**\n   * Build a new Pipeline.\n   *\n   * @param  {Pipeline|Immutable.Map|null} [arg] May be either:\n   *  * a Pipeline (copy contructor)\n   *  * an Immutable.Map, in which case the internal state of the\n   *    Pipeline will be contructed from the Map\n   *  * not specified\n   *\n   * Usually you would initialize a Pipeline using the factory\n   * function, rather than this object directly with `new`.\n   *\n   * @example\n   * ```\n   * import { Pipeline } from \"pondjs\";\n   * const p = Pipeline()...`\n   * ```\n   *\n   * @return {Pipeline} The Pipeline\n   */\n  constructor(arg) {\n    if (arg instanceof Pipeline) {\n      var other = arg;\n      this._d = other._d;\n    } else if (arg instanceof _immutable.default.Map) {\n      this._d = arg;\n    } else {\n      this._d = new _immutable.default.Map({\n        type: null,\n        in: null,\n        first: null,\n        last: null,\n        groupBy: () => \"\",\n        windowType: \"global\",\n        windowDuration: null,\n        emitOn: \"eachEvent\"\n      });\n    }\n\n    this._results = [];\n  } //\n  // Accessors to the current Pipeline state\n  //\n\n\n  in() {\n    return this._d.get(\"in\");\n  }\n\n  mode() {\n    return this._d.get(\"mode\");\n  }\n\n  first() {\n    return this._d.get(\"first\");\n  }\n\n  last() {\n    return this._d.get(\"last\");\n  }\n\n  getWindowType() {\n    return this._d.get(\"windowType\");\n  }\n\n  getWindowDuration() {\n    return this._d.get(\"windowDuration\");\n  }\n\n  getGroupBy() {\n    return this._d.get(\"groupBy\");\n  }\n\n  getEmitOn() {\n    return this._d.get(\"emitOn\");\n  } //\n  // Results\n  //\n\n\n  clearResults() {\n    this._resultsDone = false;\n    this._results = null;\n  }\n\n  addResult(arg1, arg2) {\n    if (!this._results) {\n      if (_underscore.default.isString(arg1) && arg2) {\n        this._results = {};\n      } else {\n        this._results = [];\n      }\n    }\n\n    if (_underscore.default.isString(arg1) && arg2) {\n      this._results[arg1] = arg2;\n    } else {\n      this._results.push(arg1);\n    }\n\n    this._resultsDone = false;\n  }\n\n  resultsDone() {\n    this._resultsDone = true;\n  } //\n  // Pipeline mutations\n  //\n\n  /**\n   * Setting the In for the Pipeline returns a new Pipeline\n   *\n   * @private\n   */\n\n\n  _setIn(input) {\n    var mode;\n    var source = input;\n\n    if (input instanceof _timeseries.default) {\n      mode = \"batch\";\n      source = input.collection();\n    } else if (input instanceof _bounded.default) {\n      mode = \"batch\";\n    } else if (input instanceof _stream.default) {\n      mode = \"stream\";\n    } else {\n      throw new Error(\"Unknown input type\", input);\n    }\n\n    var d = this._d.withMutations(map => {\n      map.set(\"in\", source).set(\"mode\", mode);\n    });\n\n    return new Pipeline(d);\n  }\n  /**\n   * Set the first processing node pointed to, returning\n   * a new Pipeline. The original pipeline will still point\n   * to its orginal processing node.\n   *\n   * @private\n   */\n\n\n  _setFirst(n) {\n    var d = this._d.set(\"first\", n);\n\n    return new Pipeline(d);\n  }\n  /**\n   * Set the last processing node pointed to, returning\n   * a new Pipeline. The original pipeline will still point\n   * to its orginal processing node.\n   *\n   * @private\n   */\n\n\n  _setLast(n) {\n    var d = this._d.set(\"last\", n);\n\n    return new Pipeline(d);\n  }\n  /**\n   * @private\n   */\n\n\n  _append(processor) {\n    var first = this.first();\n    var last = this.last();\n    if (!first) first = processor;\n    if (last) last.addObserver(processor);\n    last = processor;\n\n    var d = this._d.withMutations(map => {\n      map.set(\"first\", first).set(\"last\", last);\n    });\n\n    return new Pipeline(d);\n  }\n\n  _chainPrev() {\n    return this.last() || this;\n  } //\n  // Pipeline state chained methods\n  //\n\n  /**\n   * Set the window, returning a new Pipeline. A new window will\n   * have a type and duration associated with it. Current available\n   * types are:\n   *   * fixed (e.g. every 5m)\n   *   * calendar based windows (e.g. every month)\n   *\n   * Windows are a type of grouping. Typically you'd define a window\n   * on the pipeline before doing an aggregation or some other operation\n   * on the resulting grouped collection. You can combine window-based\n   * grouping with key-grouping (see groupBy()).\n   *\n   * There are several ways to define a window. The general format is\n   * an options object containing a `type` field and a `duration` field.\n   *\n   * Currently the only accepted type is `fixed`, but others are planned.\n   * For duration, this is a duration string, for example \"30s\" or \"1d\".\n   * Supported are: seconds (s), minutes (m), hours (h) and days (d).\n   *\n   * If no arg is supplied, the window type is set to 'global' and there\n   * is no duration.\n   *\n   * There is also a short-cut notation for a fixed window or a calendar\n   * window. Simply supplying the duration string (\"30s\" for example) will\n   * result in a `fixed` window type with the supplied duration.\n   *\n   * Calendar types are specified by simply specifying \"daily\", \"monthly\"\n   * or \"yearly\".\n   *\n   * @param {string|object} w Window or duration - See above\n   * @return {Pipeline} The Pipeline\n   */\n\n\n  windowBy(w) {\n    var type, duration;\n\n    if (_underscore.default.isString(w)) {\n      if (w === \"daily\" || w === \"monthly\" || w === \"yearly\") {\n        type = w;\n      } else {\n        // assume fixed window with size w\n        type = \"fixed\";\n        duration = w;\n      }\n    } else if (_underscore.default.isObject(w)) {\n      type = w.type;\n      duration = w.duration;\n    } else {\n      type = \"global\";\n      duration = null;\n    }\n\n    var d = this._d.withMutations(map => {\n      map.set(\"windowType\", type).set(\"windowDuration\", duration);\n    });\n\n    return new Pipeline(d);\n  }\n  /**\n   * Remove windowing from the Pipeline. This will\n   * return the pipeline to no window grouping. This is\n   * useful if you have first done some aggregated by\n   * some window size and then wish to collect together\n   * the all resulting events.\n   *\n   * @return {Pipeline} The Pipeline\n   */\n\n\n  clearWindow() {\n    return this.windowBy();\n  }\n  /**\n   * Sets a new key grouping. Returns a new Pipeline.\n   *\n   * Grouping is a state set on the Pipeline. Operations downstream\n   * of the group specification will use that state. For example, an\n   * aggregation would occur over any grouping specified. You can\n   * combine a key grouping with windowing (see windowBy()).\n   *\n   * Note: the key, if it is a field path, is not a list of multiple\n   * columns, it is the path to a single column to pull group by keys\n   * from. For example, a column called 'status' that contains the\n   * values 'OK' and 'FAIL' - then the key would be 'status' and two\n   * collections OK and FAIL will be generated.\n   *\n   * @param {function|array|string}   k   The key to group by.\n   *                                      You can groupBy using a function\n   *                                      `(event) => return key`,\n   *                                      a field path (a field name, or dot\n   *                                      delimitted path to a field),\n   *                                      or a array of field paths.\n   *\n   * @return {Pipeline}                   The Pipeline\n   */\n\n\n  groupBy(k) {\n    var grp;\n    var groupBy = k || \"value\";\n\n    if (_underscore.default.isFunction(groupBy)) {\n      // group using a user defined function\n      // (event) => key\n      grp = groupBy;\n    } else if (_underscore.default.isArray(groupBy)) {\n      // group by several column values\n      grp = e => _underscore.default.map(groupBy, c => \"\".concat(e.get(c))).join(\"::\");\n    } else if (_underscore.default.isString(groupBy)) {\n      // group by a column value\n      grp = e => \"\".concat(e.get(groupBy));\n    } else {\n      // Reset to no grouping\n      grp = () => \"\";\n    }\n\n    var d = this._d.withMutations(map => {\n      map.set(\"groupBy\", grp);\n    });\n\n    return new Pipeline(d);\n  }\n  /**\n   * Remove the grouping from the pipeline. In other words\n   * recombine the events.\n   *\n   * @return {Pipeline} The Pipeline\n   */\n\n\n  clearGroupBy() {\n    return this.groupBy();\n  }\n  /**\n   * Sets the condition under which an accumulated collection will\n   * be emitted. If specified before an aggregation this will control\n   * when the resulting event will be emitted relative to the\n   * window accumulation. Current options are:\n   *  * to emit on every event, or\n   *  * just when the collection is complete, or\n   *  * when a flush signal is received, either manually calling done(),\n   *    or at the end of a bounded source\n   *\n   * The difference will depend on the output you want, how often\n   * you want to get updated, and if you need to get a partial state.\n   * There's currently no support for late data or watermarks. If an\n   * event passes comes in after a collection window, that collection\n   * is considered finished.\n   *\n   * @param {string} trigger A string indicating how to trigger a\n   * Collection should be emitted. May be:\n   *     * \"eachEvent\" - when a new event comes in, all currently\n   *                     maintained collections will emit their result\n   *     * \"discard\"   - when a collection is to be discarded,\n   *                     first it will emit. But only then.\n   *     * \"flush\"     - when a flush signal is received\n   *\n   * @return {Pipeline} The Pipeline\n   */\n\n\n  emitOn(trigger) {\n    var d = this._d.set(\"emitOn\", trigger);\n\n    return new Pipeline(d);\n  } //\n  // I/O\n  //\n\n  /**\n   * The source to get events from. The source needs to be able to\n   * iterate its events using `for..of` loop for bounded Ins, or\n   * be able to emit() for unbounded Ins. The actual batch, or stream\n   * connection occurs when an output is defined with `to()`.\n   *\n   * Pipelines can be chained together since a source may be another\n   * Pipeline.\n   *\n   * @param {Bounded|Stream} src The source for the Pipeline\n   * @return {Pipeline} The Pipeline\n   */\n\n\n  from(src) {\n    return this._setIn(src);\n  }\n  /**\n   * Directly return the results from the processor rather than\n   * feeding to a callback. This breaks the chain, causing a result to\n   * be returned (the array of events) rather than a reference to the\n   * Pipeline itself. This function is only available for sync batch\n   * processing.\n   *\n   * @return {array|map}     Returns the _results attribute from a Pipeline\n   *                         object after processing. Will contain Collection\n   *                         objects.\n   */\n\n\n  toEventList() {\n    return this.to(_eventout.default);\n  }\n  /**\n   * Directly return the results from the processor rather than\n   * passing a callback in. This breaks the chain, causing a result to\n   * be returned (the collections) rather than a reference to the\n   * Pipeline itself. This function is only available for sync batch\n   * processing.\n   *\n   * @return {array|map}     Returns the _results attribute from a Pipeline\n   *                         object after processing. Will contain Collection\n   *                         objects.\n   */\n\n\n  toKeyedCollections() {\n    var result = this.to(_collectionout.default);\n\n    if (result) {\n      return result;\n    } else {\n      return {};\n    }\n  }\n  /**\n   * Sets up the destination sink for the pipeline.\n   *\n   * For a batch mode connection, i.e. one with a Bounded source,\n   * the output is connected to a clone of the parts of the Pipeline dependencies\n   * that lead to this output. This is done by a Runner. The source input is\n   * then iterated over to process all events into the pipeline and though to the Out.\n   *\n   * For stream mode connections, the output is connected and from then on\n   * any events added to the input will be processed down the pipeline to\n   * the out.\n   *\n   * @example\n   * ```\n   * const p = Pipeline()\n   *  ...\n   *  .to(EventOut, {}, event => {\n   *      result[`${event.index()}`] = event;\n   *  });\n   * ```\n   * @return {Pipeline} The Pipeline\n   */\n\n\n  to(arg1, arg2, arg3) {\n    var Out = arg1;\n    var observer;\n    var options = {};\n\n    if (_underscore.default.isFunction(arg2)) {\n      observer = arg2;\n    } else if (_underscore.default.isObject(arg2)) {\n      options = arg2;\n      observer = arg3;\n    }\n\n    if (!this.in()) {\n      throw new Error(\"Tried to eval pipeline without a In. Missing from() in chain?\");\n    }\n\n    var out = new Out(this, options, observer);\n\n    if (this.mode() === \"batch\") {\n      var runner = new Runner(this, out);\n      runner.start(true);\n\n      if (this._resultsDone && !observer) {\n        return this._results;\n      }\n    } else if (this.mode() === \"stream\") {\n      var _out = new Out(this, options, observer);\n\n      if (this.first()) {\n        this.in().addObserver(this.first());\n      }\n\n      if (this.last()) {\n        this.last().addObserver(_out);\n      } else {\n        this.in().addObserver(_out);\n      }\n    }\n\n    return this;\n  }\n  /**\n   * Outputs the count of events\n   *\n   * @param  {function}  observer The callback function. This will be\n   *                              passed the count, the windowKey and\n   *                              the groupByKey\n   * @param  {Boolean} force    Flush at the end of processing batch\n   *                            events, output again with possibly partial\n   *                            result.\n   * @return {Pipeline} The Pipeline\n   */\n\n\n  count(observer) {\n    var force = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : true;\n    return this.to(_collectionout.default, (collection, windowKey, groupByKey) => {\n      observer(collection.size(), windowKey, groupByKey);\n    }, force);\n  } //\n  // Processors\n  //\n\n  /**\n   * Processor to offset a set of fields by a value. Mostly used for\n   * testing processor and pipeline operations with a simple operation.\n   *\n   * @param  {number} by              The amount to offset by\n   * @param  {string|array} fieldSpec The field(s)\n   *\n   * @return {Pipeline}               The modified Pipeline\n   */\n\n\n  offsetBy(by, fieldSpec) {\n    var p = new _offset.default(this, {\n      by,\n      fieldSpec,\n      prev: this._chainPrev()\n    });\n    return this._append(p);\n  }\n  /**\n   * Uses the current Pipeline windowing and grouping\n   * state to build collections of events and aggregate them.\n   *\n   * `IndexedEvent`s will be emitted out of the aggregator based\n   * on the `emitOn` state of the Pipeline.\n   *\n   * To specify what part of the incoming events should\n   * be aggregated together you specify a `fields`\n   * object. This is a map from fieldName to operator.\n   *\n   * @example\n   *\n   * ```\n   * import { Pipeline, EventOut, functions } from \"pondjs\";\n   * const { avg } = functions;\n   *\n   * const p = Pipeline()\n   *   .from(input)\n   *   .windowBy(\"1h\")           // 1 day fixed windows\n   *   .emitOn(\"eachEvent\")      // emit result on each event\n   *   .aggregate({\n   *      in_avg: {in: avg},\n   *      out_avg: {in: avg}\n   *   })\n   *   .asTimeEvents()\n   *   .to(EventOut, {}, event => {\n   *      result[`${event.index()}`] = event; // Result\n   *   });\n   * ```\n   *\n   * @param  {object} fields Fields and operators to be aggregated\n   *\n   * @return {Pipeline} The Pipeline\n   */\n\n\n  aggregate(fields) {\n    var p = new _aggregator.default(this, {\n      fields,\n      prev: this._chainPrev()\n    });\n    return this._append(p);\n  }\n  /**\n   * Converts incoming TimeRangeEvents or IndexedEvents to\n   * TimeEvents. This is helpful since some processors,\n   * especially aggregators, will emit TimeRangeEvents or\n   * IndexedEvents, which may be unsuitable for some applications.\n   *\n   * @param  {object} options To convert to an TimeEvent you need\n   * to convert a time range to a single time. There are three options:\n   *  1. use the beginning time (options = {alignment: \"lag\"})\n   *  2. use the center time (options = {alignment: \"center\"})\n   *  3. use the end time (options = {alignment: \"lead\"})\n   *\n   * @return {Pipeline} The Pipeline\n   */\n\n\n  asTimeEvents(options) {\n    var type = _timeevent.default;\n    var p = new _converter.default(this, _objectSpread({\n      type\n    }, options, {\n      prev: this._chainPrev()\n    }));\n    return this._append(p);\n  }\n  /**\n   * Map the event stream using an operator\n   *\n   * @param  {function} op A function that returns a new Event\n   *\n   * @return {Pipeline} The Pipeline\n   */\n\n\n  map(op) {\n    var p = new _mapper.default(this, {\n      op,\n      prev: this._chainPrev()\n    });\n    return this._append(p);\n  }\n  /**\n   * Filter the event stream using an operator\n   *\n   * @param  {function} op A function that returns true or false\n   *\n   * @return {Pipeline} The Pipeline\n   */\n\n\n  filter(op) {\n    var p = new _filter.default(this, {\n      op,\n      prev: this._chainPrev()\n    });\n    return this._append(p);\n  }\n  /**\n   * Select a subset of columns\n   *\n   * @param {string|array} fieldSpec  Column or columns to look up. If you need\n   *                                  to retrieve multiple deep nested values that\n   *                                  ['can.be', 'done.with', 'this.notation'].\n   *                                  A single deep value with a string.like.this.\n   *                                  If not supplied, the 'value' column will be used.\n   *\n   * @return {Pipeline} The Pipeline\n   */\n\n\n  select(fieldSpec) {\n    var p = new _selector.default(this, {\n      fieldSpec,\n      prev: this._chainPrev()\n    });\n    return this._append(p);\n  }\n  /**\n   * Collapse a subset of columns using a reducer function\n   *\n   * @example\n   *\n   * ```\n   *  const timeseries = new TimeSeries(inOutData);\n   *  Pipeline()\n   *      .from(timeseries)\n   *      .collapse([\"in\", \"out\"], \"in_out_sum\", sum)\n   *      .emitOn(\"flush\")\n   *      .to(CollectionOut, c => {\n   *           const ts = new TimeSeries({name: \"subset\", collection: c});\n   *           ...\n   *      }, true);\n   * ```\n   * @param {string|array} fieldSpecList  Column or columns to collapse. If you need\n   *                                      to retrieve multiple deep nested values that\n   *                                      ['can.be', 'done.with', 'this.notation'].\n   * @param {string}       name       The resulting output column's name\n   * @param {function}     reducer    Function to use to do the reduction\n   * @param {boolean}      append     Add the new column to the existing ones,\n   *                                  or replace them.\n   *\n   * @return {Pipeline}               The Pipeline\n   */\n\n\n  collapse(fieldSpecList, name, reducer, append) {\n    var p = new _collapser.default(this, {\n      fieldSpecList,\n      name,\n      reducer,\n      append,\n      prev: this._chainPrev()\n    });\n    return this._append(p);\n  }\n  /**\n   * Take the data in this event steam and \"fill\" any missing\n   * or invalid values. This could be setting `null` values to `0`\n   * so mathematical operations will succeed, interpolate a new\n   * value, or pad with the previously given value.\n   *\n   * If one wishes to limit the number of filled events in the result\n   * set, use Pipeline.keep() in the chain. See: TimeSeries.fill()\n   * for an example.\n   *\n   * Fill takes a single arg `options` which should be composed of:\n   *  * fieldSpec - Column or columns to look up. If you need\n   *                to retrieve multiple deep nested values that\n   *                ['can.be', 'done.with', 'this.notation'].\n   *                A single deep value with a string.like.this.\n   *  * method -    Filling method: zero | linear | pad\n   *\n   * @return {Pipeline}               The Pipeline\n   */\n\n\n  fill(_ref) {\n    var {\n      fieldSpec = null,\n      method = \"linear\",\n      limit = null\n    } = _ref;\n\n    var prev = this._chainPrev();\n\n    return this._append(new _filler.default(this, {\n      fieldSpec,\n      method,\n      limit,\n      prev\n    }));\n  }\n\n  align(fieldSpec, window, method, limit) {\n    var prev = this._chainPrev();\n\n    return this._append(new _aligner.default(this, {\n      fieldSpec,\n      window,\n      method,\n      limit,\n      prev\n    }));\n  }\n\n  rate(fieldSpec) {\n    var allowNegative = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : true;\n    var p = new _derivator.default(this, {\n      fieldSpec,\n      allowNegative,\n      prev: this._chainPrev()\n    });\n    return this._append(p);\n  }\n  /**\n   * Take events up to the supplied limit, per key.\n   *\n   * @param  {number} limit Integer number of events to take\n   *\n   * @return {Pipeline} The Pipeline\n   */\n\n\n  take(limit) {\n    var p = new _taker.default(this, {\n      limit,\n      prev: this._chainPrev()\n    });\n    return this._append(p);\n  }\n  /**\n   * Converts incoming Events or IndexedEvents to TimeRangeEvents.\n   *\n   * @param {object} options To convert from an Event you need\n   * to convert a single time to a time range. To control this you\n   * need to specify the duration of that time range, along with\n   * the positioning (alignment) of the time range with respect to\n   * the time stamp of the Event.\n   *\n   * There are three option for alignment:\n   *  1. time range will be in front of the timestamp (options = {alignment: \"front\"})\n   *  2. time range will be centered on the timestamp (options = {alignment: \"center\"})\n   *  3. time range will be positoned behind the timestamp (options = {alignment: \"behind\"})\n   *\n   * The duration is of the form \"1h\" for one hour, \"30s\" for 30 seconds and so on.\n   *\n   * @return {Pipeline} The Pipeline\n   */\n\n\n  asTimeRangeEvents(options) {\n    var type = _timerangeevent.default;\n    var p = new _converter.default(this, _objectSpread({\n      type\n    }, options, {\n      prev: this._chainPrev()\n    }));\n    return this._append(p);\n  }\n  /**\n   * Converts incoming Events to IndexedEvents.\n   *\n   * Note: It isn't possible to convert TimeRangeEvents to IndexedEvents.\n   *\n   * @param {Object} options            An object containing the conversion\n   * options. In this case the duration string of the Index is expected.\n   * @param {string} options.duration   The duration string is of the form \"1h\" for one hour, \"30s\"\n   * for 30 seconds and so on.\n   *\n   * @return {Pipeline} The Pipeline\n   */\n\n\n  asIndexedEvents(options) {\n    var type = _indexedevent.default;\n    var p = new _converter.default(this, _objectSpread({\n      type\n    }, options, {\n      prev: this._chainPrev()\n    }));\n    return this._append(p);\n  }\n\n}\n\nfunction pipeline(args) {\n  return new Pipeline(args);\n}\n\nfunction is(p) {\n  return p instanceof Pipeline;\n}"]},"metadata":{},"sourceType":"script"}