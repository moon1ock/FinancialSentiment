{"ast":null,"code":"\"use strict\";\n\nvar _interopRequireDefault = require(\"@babel/runtime/helpers/interopRequireDefault\");\n\nObject.defineProperty(exports, \"__esModule\", {\n  value: true\n});\nexports.default = void 0;\n\nvar _defineProperty2 = _interopRequireDefault(require(\"@babel/runtime/helpers/defineProperty\"));\n\nvar _objectWithoutProperties2 = _interopRequireDefault(require(\"@babel/runtime/helpers/objectWithoutProperties\"));\n\nvar _underscore = _interopRequireDefault(require(\"underscore\"));\n\nvar _immutable = _interopRequireDefault(require(\"immutable\"));\n\nvar _collection = _interopRequireDefault(require(\"./collection\"));\n\nvar _index = _interopRequireDefault(require(\"./index\"));\n\nvar _event = _interopRequireDefault(require(\"./event\"));\n\nvar _timeevent = _interopRequireDefault(require(\"./timeevent\"));\n\nvar _timerangeevent = _interopRequireDefault(require(\"./timerangeevent\"));\n\nvar _indexedevent = _interopRequireDefault(require(\"./indexedevent\"));\n\nvar _pipeline = require(\"./pipeline.js\");\n\nfunction ownKeys(object, enumerableOnly) {\n  var keys = Object.keys(object);\n\n  if (Object.getOwnPropertySymbols) {\n    var symbols = Object.getOwnPropertySymbols(object);\n    if (enumerableOnly) symbols = symbols.filter(function (sym) {\n      return Object.getOwnPropertyDescriptor(object, sym).enumerable;\n    });\n    keys.push.apply(keys, symbols);\n  }\n\n  return keys;\n}\n\nfunction _objectSpread(target) {\n  for (var i = 1; i < arguments.length; i++) {\n    var source = arguments[i] != null ? arguments[i] : {};\n\n    if (i % 2) {\n      ownKeys(source, true).forEach(function (key) {\n        (0, _defineProperty2.default)(target, key, source[key]);\n      });\n    } else if (Object.getOwnPropertyDescriptors) {\n      Object.defineProperties(target, Object.getOwnPropertyDescriptors(source));\n    } else {\n      ownKeys(source).forEach(function (key) {\n        Object.defineProperty(target, key, Object.getOwnPropertyDescriptor(source, key));\n      });\n    }\n  }\n\n  return target;\n}\n\nfunction buildMetaData(meta) {\n  var d = meta ? meta : {}; // Name\n\n  d.name = meta.name ? meta.name : \"\"; // Index\n\n  if (meta.index) {\n    if (_underscore.default.isString(meta.index)) {\n      d.index = new _index.default(meta.index);\n    } else if (meta.index instanceof _index.default) {\n      d.index = meta.index;\n    }\n  } // UTC or Local time\n\n\n  d.utc = true;\n\n  if (_underscore.default.isBoolean(meta.utc)) {\n    d.utc = meta.utc;\n  }\n\n  return new _immutable.default.Map(d);\n}\n/**\n * A `TimeSeries` represents a series of events, with each event being a combination of:\n *\n *  - time (or `TimeRange`, or `Index`)\n *  - data - corresponding set of key/values.\n *\n * ### Construction\n *\n * Currently you can initialize a `TimeSeries` with either a list of events, or with a data format that looks like this:\n *\n * ```javascript\n * const data = {\n *     name: \"trafficc\",\n *     columns: [\"time\", \"value\"],\n *     points: [\n *         [1400425947000, 52],\n *         [1400425948000, 18],\n *         [1400425949000, 26],\n *         [1400425950000, 93],\n *         ...\n *     ]\n * };\n * ```\n *\n * To create a new TimeSeries object from the above format, simply use the constructor:\n *\n * ```javascript\n * const series = new TimeSeries(data);\n * ```\n *\n * The format of the data is as follows:\n *\n *  - **name** - optional, but a good practice\n *  - **columns** - are necessary and give labels to the data in the points.\n *  - **points** - are an array of tuples. Each row is at a different time (or timerange), and each value corresponds to the column labels.\n *\n * As just hinted at, the first column may actually be:\n *\n *  - \"time\"\n *  - \"timeRange\" represented by a `TimeRange`\n *  - \"index\" - a time range represented by an `Index`. By using an index it is possible, for example, to refer to a specific month:\n *\n * ```javascript\n * const availabilityData = {\n *     name: \"Last 3 months availability\",\n *     columns: [\"index\", \"uptime\"],\n *     points: [\n *         [\"2015-06\", \"100%\"], // <-- 2015-06 specified here represents June 2015\n *         [\"2015-05\", \"92%\"],\n *         [\"2015-04\", \"87%\"],\n *     ]\n * };\n * ```\n *\n * Alternatively, you can construct a `TimeSeries` with a list of events.\n * These may be `TimeEvents`, `TimeRangeEvents` or `IndexedEvents`. Here's an example of that:\n *\n * ```javascript\n * const events = [];\n * events.push(new TimeEvent(new Date(2015, 7, 1), {value: 27}));\n * events.push(new TimeEvent(new Date(2015, 8, 1), {value: 29}));\n * const series = new TimeSeries({\n *     name: \"avg temps\",\n *     events: events\n * });\n * ```\n *\n * ### Nested data\n *\n * The values do not have to be simple types like the above examples. Here's an\n * example where each value is itself an object with \"in\" and \"out\" keys:\n *\n * ```javascript\n * const series = new TimeSeries({\n *     name: \"Map Traffic\",\n *     columns: [\"time\", \"NASA_north\", \"NASA_south\"],\n *     points: [\n *         [1400425951000, {in: 100, out: 200}, {in: 145, out: 135}],\n *         [1400425952000, {in: 200, out: 400}, {in: 146, out: 142}],\n *         [1400425953000, {in: 300, out: 600}, {in: 147, out: 158}],\n *         [1400425954000, {in: 400, out: 800}, {in: 155, out: 175}],\n *     ]\n * });\n * ```\n *\n * Complex data is stored in an Immutable structure. To get a value out of nested\n * data like this you will get the event you want (by row), as usual, and then use\n * `get()` to fetch the value by column name. The result of this call will be a\n * JSON copy of the Immutable data so you can query deeper in the usual way:\n *\n * ```javascript\n * series.at(0).get(\"NASA_north\")[\"in\"]  // 200`\n * ```\n *\n * It is then possible to use a value mapper function when calculating different\n * properties. For example, to get the average \"in\" value of the NASA_north column:\n *\n * ```javascript\n * series.avg(\"NASA_north\", d => d.in);  // 250\n * ```\n */\n\n\nclass TimeSeries {\n  constructor(arg) {\n    this._collection = null; // Collection\n\n    this._data = null; // Meta data\n\n    if (arg instanceof TimeSeries) {\n      //\n      // Copy another TimeSeries\n      //\n      var other = arg;\n      this._data = other._data;\n      this._collection = other._collection;\n    } else if (_underscore.default.isObject(arg)) {\n      //\n      // TimeSeries(object data) where data may be:\n      //    { \"events\": [event-1, event-2, ..., event-n]}\n      // or\n      //    { \"columns\": [time|timerange|index, column-1, ..., column-n]\n      //      \"points\": [\n      //         [t1, v1, v2, ..., v2],\n      //         [t2, v1, v2, ..., vn],\n      //         ...\n      //      ]\n      //    }\n      var obj = arg;\n\n      if (_underscore.default.has(obj, \"events\")) {\n        //\n        // Initialized from an event list\n        //\n        var {\n          events\n        } = obj,\n            meta1 = (0, _objectWithoutProperties2.default)(obj, [\"events\"]); //eslint-disable-line\n\n        this._collection = new _collection.default(events);\n        this._data = buildMetaData(meta1);\n      } else if (_underscore.default.has(obj, \"collection\")) {\n        //\n        // Initialized from a Collection\n        //\n        var {\n          collection\n        } = obj,\n            meta3 = (0, _objectWithoutProperties2.default)(obj, [\"collection\"]); //eslint-disable-line\n\n        this._collection = collection;\n        this._data = buildMetaData(meta3);\n      } else if (_underscore.default.has(obj, \"columns\") && _underscore.default.has(obj, \"points\")) {\n        //\n        // Initialized from the wire format\n        //\n        var {\n          columns,\n          points,\n          utc = true\n        } = obj,\n            meta2 = (0, _objectWithoutProperties2.default)(obj, [\"columns\", \"points\", \"utc\"]); //eslint-disable-line\n\n        var [eventKey, ...eventFields] = columns;\n\n        var _events = points.map(point => {\n          var [t, ...eventValues] = point;\n\n          var d = _underscore.default.object(eventFields, eventValues);\n\n          var options = utc;\n\n          switch (eventKey) {\n            case \"time\":\n              return new _timeevent.default(t, d, options);\n\n            case \"index\":\n              return new _indexedevent.default(t, d, options);\n\n            case \"timerange\":\n              return new _timerangeevent.default(t, d, options);\n\n            default:\n              throw new Error(\"Unknown event type\");\n          }\n        });\n\n        this._collection = new _collection.default(_events);\n        this._data = buildMetaData(meta2);\n      }\n\n      if (!this._collection.isChronological()) {\n        throw new Error(\"TimeSeries was passed non-chronological events\");\n      }\n    }\n  } //\n  // Serialize\n  //\n\n  /**\n   * Turn the TimeSeries into regular javascript objects\n   */\n\n\n  toJSON() {\n    var e = this.atFirst();\n\n    if (!e) {\n      return;\n    }\n\n    var columnList = this.columns();\n    var columns;\n\n    if (e instanceof _timeevent.default) {\n      columns = [\"time\", ...columnList];\n    } else if (e instanceof _timerangeevent.default) {\n      columns = [\"timerange\", ...columnList];\n    } else if (e instanceof _indexedevent.default) {\n      columns = [\"index\", ...columnList];\n    }\n\n    var points = [];\n\n    for (var _e of this._collection.events()) {\n      points.push(_e.toPoint(columnList));\n    }\n\n    return _underscore.default.extend(this._data.toJSON(), {\n      columns,\n      points\n    });\n  }\n  /**\n   * Represent the TimeSeries as a string\n   */\n\n\n  toString() {\n    return JSON.stringify(this.toJSON());\n  }\n  /**\n   * Returns the extents of the TimeSeries as a TimeRange.\n   */\n\n\n  timerange() {\n    return this._collection.range();\n  }\n  /**\n   * Alias for `timerange()`\n   */\n\n\n  range() {\n    return this.timerange();\n  }\n  /**\n   * Gets the earliest time represented in the TimeSeries.\n   *\n   * @return {Date} Begin time\n   */\n\n\n  begin() {\n    return this.range().begin();\n  }\n  /**\n   * Gets the latest time represented in the TimeSeries.\n   *\n   * @return {Date} End time\n   */\n\n\n  end() {\n    return this.range().end();\n  }\n  /**\n   * Access a specific TimeSeries event via its position\n   *\n   * @param {number} pos The event position\n   */\n\n\n  at(pos) {\n    return this._collection.at(pos);\n  }\n  /**\n   * Returns an event in the series by its time. This is the same\n   * as calling `bisect` first and then using `at` with the index.\n   *\n   * @param  {Date} time The time of the event.\n   * @return {TimeEvent|IndexedEvent|TimeRangeEvent}\n   */\n\n\n  atTime(time) {\n    var pos = this.bisect(time);\n\n    if (pos >= 0 && pos < this.size()) {\n      return this.at(pos);\n    }\n  }\n  /**\n   * Returns the first event in the series.\n   *\n   * @return {TimeEvent|IndexedEvent|TimeRangeEvent}\n   */\n\n\n  atFirst() {\n    return this._collection.atFirst();\n  }\n  /**\n   * Returns the last event in the series.\n   *\n   * @return {TimeEvent|IndexedEvent|TimeRangeEvent}\n   */\n\n\n  atLast() {\n    return this._collection.atLast();\n  }\n  /**\n   * Generator to return all the events in the series\n   *\n   * @example\n   * ```\n   * for (let event of series.events()) {\n   *     console.log(event.toString());\n   * }\n   * ```\n   */\n\n\n  *events() {\n    for (var i = 0; i < this.size(); i++) {\n      yield this.at(i);\n    }\n  }\n  /**\n   * Sets a new underlying collection for this TimeSeries.\n   *\n   * @param {Collection}  collection       The new collection\n   * @param {boolean}     isChronological  Causes the chronological\n   *                                       order of the events to\n   *                                       not be checked\n   *\n   * @return {TimeSeries}                  A new TimeSeries\n   */\n\n\n  setCollection(collection) {\n    var isChronological = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : false;\n\n    if (!isChronological && !collection.isChronological()) {\n      throw new Error(\"Collection supplied is not chronological\");\n    }\n\n    var result = new TimeSeries(this);\n\n    if (collection) {\n      result._collection = collection;\n    } else {\n      result._collection = new _collection.default();\n    }\n\n    return result;\n  }\n  /**\n   * Returns the index that bisects the TimeSeries at the time specified.\n   *\n   * @param  {Date}    t   The time to bisect the TimeSeries with\n   * @param  {number}  b   The position to begin searching at\n   *\n   * @return {number}      The row number that is the greatest, but still below t.\n   */\n\n\n  bisect(t, b) {\n    var tms = t.getTime();\n    var size = this.size();\n    var i = b || 0;\n\n    if (!size) {\n      return undefined;\n    }\n\n    for (; i < size; i++) {\n      var ts = this.at(i).timestamp().getTime();\n\n      if (ts > tms) {\n        return i - 1 >= 0 ? i - 1 : 0;\n      } else if (ts === tms) {\n        return i;\n      }\n    }\n\n    return i - 1;\n  }\n  /**\n   * Perform a slice of events within the TimeSeries, returns a new\n   * TimeSeries representing a portion of this TimeSeries from\n   * begin up to but not including end.\n   *\n   * @param {Number} begin   The position to begin slicing\n   * @param {Number} end     The position to end slicing\n   *\n   * @return {TimeSeries}    The new, sliced, TimeSeries.\n   */\n\n\n  slice(begin, end) {\n    var sliced = this._collection.slice(begin, end);\n\n    return this.setCollection(sliced, true);\n  }\n  /**\n   * Crop the TimeSeries to the specified TimeRange and\n   * return a new TimeSeries.\n   *\n   * @param {TimeRange} timerange   The bounds of the new TimeSeries\n   *\n   * @return {TimeSeries}    The new, cropped, TimeSeries.\n   */\n\n\n  crop(timerange) {\n    var timerangeBegin = timerange.begin();\n    var beginPos = this.bisect(timerangeBegin);\n    var bisectedEventOutsideRange = this.at(beginPos).timestamp() < timerangeBegin;\n    beginPos = bisectedEventOutsideRange ? beginPos + 1 : beginPos;\n    var endPos = this.bisect(timerange.end(), beginPos);\n    return this.slice(beginPos, endPos + 1);\n  }\n  /**\n   * Returns a new TimeSeries by testing the fieldPath\n   * values for being valid (not NaN, null or undefined).\n   *\n   * The resulting TimeSeries will be clean (for that fieldPath).\n   *\n   * @param  {string}      fieldPath  Name of value to look up. If not supplied,\n   *                                  defaults to ['value']. \"Deep\" syntax is\n   *                                  ['deep', 'value'] or 'deep.value'\n   *\n   * @return {TimeSeries}             A new, modified, TimeSeries.\n   */\n\n\n  clean(fieldSpec) {\n    var cleaned = this._collection.clean(fieldSpec);\n\n    return this.setCollection(cleaned, true);\n  }\n  /**\n   * Generator to return all the events in the collection.\n   *\n   * @example\n   * ```\n   * for (let event of timeseries.events()) {\n   *     console.log(event.toString());\n   * }\n   * ```\n   */\n\n\n  *events() {\n    for (var i = 0; i < this.size(); i++) {\n      yield this.at(i);\n    }\n  } //\n  // Access meta data about the series\n  //\n\n  /**\n   * Fetch the timeseries name\n   *\n   * @return {string} The name given to this TimeSeries\n   */\n\n\n  name() {\n    return this._data.get(\"name\");\n  }\n  /**\n   * Rename the timeseries\n   */\n\n\n  setName(name) {\n    return this.setMeta(\"name\", name);\n  }\n  /**\n   * Fetch the timeseries Index, if it has one.\n   *\n   * @return {Index} The Index given to this TimeSeries\n   */\n\n\n  index() {\n    return this._data.get(\"index\");\n  }\n  /**\n   * Fetch the timeseries Index, as a string, if it has one.\n   *\n   * @return {string} The Index, as a string, given to this TimeSeries\n   */\n\n\n  indexAsString() {\n    return this.index() ? this.index().asString() : undefined;\n  }\n  /**\n   * Fetch the timeseries `Index`, as a `TimeRange`, if it has one.\n   *\n   * @return {TimeRange} The `Index`, as a `TimeRange`, given to this `TimeSeries`\n   */\n\n\n  indexAsRange() {\n    return this.index() ? this.index().asTimerange() : undefined;\n  }\n  /**\n   * Fetch the UTC flag, i.e. are the events in this `TimeSeries` in\n   * UTC or local time (if they are `IndexedEvent`s an event might be\n   * \"2014-08-31\". The actual time range of that representation\n   * depends on where you are. Pond supports thinking about that in\n   * either as a UTC day, or a local day).\n   *\n   * @return {TimeRange} The Index, as a TimeRange, given to this TimeSeries\n   */\n\n\n  isUTC() {\n    return this._data.get(\"utc\");\n  }\n  /**\n   * Fetch the list of column names. This is determined by\n   * traversing though the events and collecting the set.\n   *\n   * Note: the order is not defined\n   *\n   * @return {array} List of columns\n   */\n\n\n  columns() {\n    var c = {};\n\n    for (var e of this._collection.events()) {\n      var d = e.toJSON().data;\n\n      _underscore.default.each(d, (val, key) => {\n        c[key] = true;\n      });\n    }\n\n    return _underscore.default.keys(c);\n  }\n  /**\n   * Returns the internal `Collection` of events for this `TimeSeries`\n   *\n   * @return {Collection} The collection backing this `TimeSeries`\n   */\n\n\n  collection() {\n    return this._collection;\n  }\n  /**\n   * Returns the meta data about this TimeSeries as a JSON object.\n   * Any extra data supplied to the TimeSeries constructor will be\n   * placed in the meta data object. This returns either all of that\n   * data as a JSON object, or a specific key if `key` is supplied.\n   *\n   * @param {string}   key   Optional specific part of the meta data\n   * @return {object}        The meta data\n   */\n\n\n  meta(key) {\n    if (!key) {\n      return this._data.toJSON();\n    } else {\n      return this._data.get(key);\n    }\n  }\n  /**\n   * Set new meta data for the TimeSeries. The result will\n   * be a new TimeSeries.\n   */\n\n\n  setMeta(key, value) {\n    var newTimeSeries = new TimeSeries(this);\n    var d = newTimeSeries._data;\n    var dd = d.set(key, value);\n    newTimeSeries._data = dd;\n    return newTimeSeries;\n  } //\n  // Access the series itself\n  //\n\n  /**\n   * Returns the number of events in this TimeSeries\n   *\n   * @return {number} Count of events\n   */\n\n\n  size() {\n    return this._collection ? this._collection.size() : 0;\n  }\n  /**\n   * Returns the number of valid items in this TimeSeries.\n   *\n   * Uses the fieldSpec to look up values in all events.\n   * It then counts the number that are considered valid, which\n   * specifically are not NaN, undefined or null.\n   *\n   * @return {number} Count of valid events\n   */\n\n\n  sizeValid(fieldSpec) {\n    return this._collection.sizeValid(fieldSpec);\n  }\n  /**\n   * Returns the number of events in this TimeSeries. Alias\n   * for size().\n   *\n   * @return {number} Count of events\n   */\n\n\n  count() {\n    return this.size();\n  }\n  /**\n   * Returns the sum for the fieldspec\n   *\n   * @param {string} fieldPath  Column to find the stdev of. A deep value can\n   *                            be referenced with a string.like.this.  If not supplied\n   *                            the `value` column will be aggregated.\n   * @param {function} filter   Optional filter function used to clean data before aggregating\n   *\n   * @return {number}           The sum\n   */\n\n\n  sum(fieldPath, filter) {\n    return this._collection.sum(fieldPath, filter);\n  }\n  /**\n   * Aggregates the events down to their maximum value\n   *\n   * @param {string} fieldPath  Column to find the max of. A deep value can\n   *                            be referenced with a string.like.this.  If not supplied\n   *                            the `value` column will be aggregated.\n   *\n   * @return {number}           The max value for the field\n   */\n\n\n  max(fieldPath, filter) {\n    return this._collection.max(fieldPath, filter);\n  }\n  /**\n   * Aggregates the events down to their minimum value\n   *\n   * @param {string} fieldPath  Column to find the min of. A deep value can\n   *                            be referenced with a string.like.this.  If not supplied\n   *                            the `value` column will be aggregated.\n   * @param {function} filter   Optional filter function used to clean data before aggregating\n   *\n   * @return {number}           The min value for the field\n   */\n\n\n  min(fieldPath, filter) {\n    return this._collection.min(fieldPath, filter);\n  }\n  /**\n   * Aggregates the events in the TimeSeries down to their average\n   *\n   * @param {string} fieldPath  Column to find the avg of. A deep value can\n   *                            be referenced with a string.like.this.  If not supplied\n   *                            the `value` column will be aggregated.\n   * @param {function} filter   Optional filter function used to clean data before aggregating\n   *\n   * @return {number}           The average\n   */\n\n\n  avg(fieldPath, filter) {\n    return this._collection.avg(fieldPath, filter);\n  }\n  /**\n   * Aggregates the events in the TimeSeries down to their mean (same as avg)\n   *\n   * @param {string} fieldPath  Column to find the mean of. A deep value can\n   *                            be referenced with a string.like.this.  If not supplied\n   *                            the `value` column will be aggregated.\n   * @param {function} filter   Optional filter function used to clean data before aggregating\n   *\n   * @return {number}           The mean\n   */\n\n\n  mean(fieldPath, filter) {\n    return this._collection.mean(fieldPath, filter);\n  }\n  /**\n   * Aggregates the events down to their medium value\n   *\n   * @param {string} fieldPath  Column to find the median of. A deep value can\n   *                            be referenced with a string.like.this.  If not supplied\n   *                            the `value` column will be aggregated.\n   * @param {function} filter   Optional filter function used to clean data before aggregating\n   *\n   * @return {number}           The resulting median value\n   */\n\n\n  median(fieldPath, filter) {\n    return this._collection.median(fieldPath, filter);\n  }\n  /**\n   * Aggregates the events down to their stdev\n   *\n   * @param {string} fieldPath  Column to find the stdev of. A deep value can\n   *                            be referenced with a string.like.this.  If not supplied\n   *                            the `value` column will be aggregated.\n   * @param {function} filter   Optional filter function used to clean data before aggregating\n   *\n   * @return {number}           The resulting stdev value\n   */\n\n\n  stdev(fieldPath, filter) {\n    return this._collection.stdev(fieldPath, filter);\n  }\n  /**\n   * Gets percentile q within the TimeSeries. This works the same way as numpy.\n   *\n   * @param  {integer} q         The percentile (should be between 0 and 100)\n   *\n   * @param {string} fieldPath   Column to find the qth percentile of. A deep value can\n   *                             be referenced with a string.like.this.  If not supplied\n   *                             the `value` column will be aggregated.\n   *\n   * @param  {string}  interp    Specifies the interpolation method\n   *                             to use when the desired quantile lies between\n   *                             two data points. Options are: \"linear\", \"lower\", \"higher\",\n   *                             \"nearest\", \"midpoint\"\n   * @param {function} filter    Optional filter function used to clean data before aggregating\n   *\n   * @return {number}            The percentile\n   */\n\n\n  percentile(q, fieldPath) {\n    var interp = arguments.length > 2 && arguments[2] !== undefined ? arguments[2] : \"linear\";\n    var filter = arguments.length > 3 ? arguments[3] : undefined;\n    return this._collection.percentile(q, fieldPath, interp, filter);\n  }\n  /**\n   * Aggregates the events down using a user defined function to\n   * do the reduction.\n   *\n   * @param  {function} func    User defined reduction function. Will be\n   *                            passed a list of values. Should return a\n   *                            singe value.\n   * @param {string} fieldPath  Column to aggregate over. A deep value can\n   *                            be referenced with a string.like.this.  If not supplied\n   *                            the `value` column will be aggregated.\n   *\n   * @return {number}           The resulting value\n   */\n\n\n  aggregate(func, fieldPath) {\n    return this._collection.aggregate(func, fieldPath);\n  }\n  /**\n   * Gets n quantiles within the TimeSeries. This works the same way as numpy's percentile().\n   * For example `timeseries.quantile(4)` would be the same as using percentile with q = 0.25, 0.5 and 0.75.\n   *\n   * @param  {integer} n        The number of quantiles to divide the\n   *                            TimeSeries into.\n   * @param {string} fieldPath  Column to calculate over. A deep value can\n   *                            be referenced with a string.like.this.  If not supplied\n   *                            the `value` column will be aggregated.\n   * @param  {string} interp    Specifies the interpolation method\n   *                            to use when the desired quantile lies between\n   *                            two data points. Options are: \"linear\", \"lower\", \"higher\",\n   *                            \"nearest\", \"midpoint\".\n   * @return {array}            An array of n quantiles\n   */\n\n\n  quantile(quantity) {\n    var fieldPath = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : \"value\";\n    var interp = arguments.length > 2 && arguments[2] !== undefined ? arguments[2] : \"linear\";\n    return this._collection.quantile(quantity, fieldPath, interp);\n  }\n  /**\n   * Returns a new Pipeline with input source being initialized to\n   * this TimeSeries collection. This allows pipeline operations\n   * to be chained directly onto the TimeSeries to produce a new\n   * TimeSeries or event result.\n   *\n   * @example\n   *\n   * ```\n   * timeseries.pipeline()\n   *     .offsetBy(1)\n   *     .offsetBy(2)\n   *     .to(CollectionOut, c => out = c);\n   * ```\n   *\n   * @return {Pipeline} The Pipeline.\n   */\n\n\n  pipeline() {\n    return new _pipeline.Pipeline().from(this._collection);\n  }\n  /**\n   * Takes an operator that is used to remap events from this TimeSeries to\n   * a new set of events.\n   *\n   * @param  {function}   operator      An operator which will be passed each\n   *                                    event and which should return a new event.\n   * @return {TimeSeries}               A TimeSeries containing the remapped events\n   */\n\n\n  map(op) {\n    var collections = this.pipeline().map(op).toKeyedCollections();\n    return this.setCollection(collections[\"all\"], true);\n  }\n  /**\n   * Takes a fieldSpec (list of column names) and outputs to the callback just those\n   * columns in a new TimeSeries.\n   *\n   * @example\n   *\n   * ```\n   *     const ts = timeseries.select({fieldSpec: [\"uptime\", \"notes\"]});\n   * ```\n   *\n   * @param                options           An object containing options for the command\n   * @param {string|array} options.fieldSpec Column or columns to select into the new TimeSeries.\n   *                                         If you need to retrieve multiple deep nested values\n   *                                         that ['can.be', 'done.with', 'this.notation'].\n   *                                         A single deep value with a string.like.this.\n   *\n   * @return {TimeSeries}                    The resulting TimeSeries with renamed columns\n   */\n\n\n  select(options) {\n    var {\n      fieldSpec\n    } = options;\n    var collections = this.pipeline().select(fieldSpec).toKeyedCollections();\n    return this.setCollection(collections[\"all\"], true);\n  }\n  /**\n   * Takes a `fieldSpecList` (list of column names) and collapses\n   * them to a new column named `name` which is the reduction (using\n   * the `reducer` function) of the matched columns in the `fieldSpecList`.\n   *\n   * The column may be appended to the existing columns, or replace them,\n   * based on the `append` boolean.\n   *\n   * @example\n   *\n   * ```\n   *     const sums = ts.collapse({\n   *          name: \"sum_series\",\n   *          fieldSpecList: [\"in\", \"out\"],\n   *          reducer: sum(),\n   *          append: false\n   *     });\n   * ```\n   *\n   * @param                options                An object containing options:\n   * @param {array}        options.fieldSpecList  The list of columns to collapse. (required)\n   * @param {string}       options.name           The resulting collapsed column name (required)\n   * @param {function}     options.reducer        The reducer function (required)\n   * @param {bool}         options.append         Append the collapsed column, rather\n   *                                              than replace\n   *\n   * @return {TimeSeries}     The resulting collapsed TimeSeries\n   */\n\n\n  collapse(options) {\n    var {\n      fieldSpecList,\n      name,\n      reducer,\n      append\n    } = options;\n    var collections = this.pipeline().collapse(fieldSpecList, name, reducer, append).toKeyedCollections();\n    return this.setCollection(collections[\"all\"], true);\n  }\n  /**\n   * Rename columns in the underlying events.\n   *\n   * Takes a object of columns to rename. Returns a new `TimeSeries` containing\n   * new events. Columns not in the dict will be retained and not renamed.\n   *\n   * @example\n   * ```\n   * new_ts = ts.renameColumns({\n   *     renameMap: {in: \"new_in\", out: \"new_out\"}\n   * });\n   * ```\n   *\n   * @note As the name implies, this will only rename the main\n   * \"top level\" (ie: non-deep) columns. If you need more\n   * extravagant renaming, roll your own using `TimeSeries.map()`.\n   *\n   * @param                options                An object containing options:\n   * @param {Object}       options.renameMap      Columns to rename.\n   *\n   * @return {TimeSeries}     The resulting TimeSeries with renamed columns\n   */\n\n\n  renameColumns(options) {\n    var {\n      renameMap\n    } = options;\n    return this.map(event => {\n      var eventType = event.type();\n      var d = event.data().mapKeys(key => renameMap[key] || key);\n      return new eventType(event.key(), d);\n    });\n  }\n  /**\n   * Take the data in this TimeSeries and \"fill\" any missing or invalid\n   * values. This could be setting `null` values to zero so mathematical\n   * operations will succeed, interpolate a new value, or pad with the\n   * previously given value.\n   *\n   * The `fill()` method takes a single `options` arg.\n   *\n   * @example\n   * ```\n   * const filled = timeseries.fill({\n   *     fieldSpec: [\"direction.in\", \"direction.out\"],\n   *     method: \"zero\",\n   *     limit: 3\n   * });\n   * ```\n   *\n   * @param                options                An object containing options:\n   * @param {string|array} options.fieldSpec      Column or columns to fill. If you need to\n   *                                              retrieve multiple deep nested values\n   *                                              that ['can.be', 'done.with', 'this.notation'].\n   *                                              A single deep value with a string.like.this.\n   * @param {string}       options.method         \"linear\" or \"pad\" or \"zero\" style interpolation\n   * @param {number}       options.limit          The maximum number of points which should be\n   *                                              interpolated onto missing points. You might set this to\n   *                                              2 if you are willing to fill 2 new points,\n   *                                              and then beyond that leave data with missing values.\n   *\n   * @return {TimeSeries}                         The resulting filled TimeSeries\n   */\n\n\n  fill(options) {\n    var {\n      fieldSpec = null,\n      method = \"zero\",\n      limit = null\n    } = options;\n    var pipeline = this.pipeline();\n\n    if (method === \"zero\" || method === \"pad\") {\n      pipeline = pipeline.fill({\n        fieldSpec,\n        method,\n        limit\n      });\n    } else if (method === \"linear\" && _underscore.default.isArray(fieldSpec)) {\n      fieldSpec.forEach(fieldPath => {\n        pipeline = pipeline.fill({\n          fieldSpec: fieldPath,\n          method,\n          limit\n        });\n      });\n    } else {\n      throw new Error(\"Invalid fill method:\", method);\n    }\n\n    var collections = pipeline.toKeyedCollections();\n    return this.setCollection(collections[\"all\"], true);\n  }\n  /**\n   * Align event values to regular time boundaries. The value at\n   * the boundary is interpolated. Only the new interpolated\n   * points are returned. If limit is reached nulls will be\n   * returned at each boundary position.\n   *\n   * One use case for this is to modify irregular data (i.e. data\n   * that falls at slightly irregular times) so that it falls into a\n   * sequence of evenly spaced values. We use this to take data we\n   * get from the network which is approximately every 30 second\n   * (:32, 1:02, 1:34, ...) and output data on exact 30 second\n   * boundaries (:30, 1:00, 1:30, ...).\n   *\n   * Another use case is data that might be already aligned to\n   * some regular interval, but that contains missing points.\n   * While `fill()` can be used to replace `null` values, `align()`\n   * can be used to add in missing points completely. Those points\n   * can have an interpolated value, or by setting limit to 0,\n   * can be filled with nulls. This is really useful when downstream\n   * processing depends on complete sequences.\n   *\n   * @example\n   * ```\n   * const aligned = ts.align({\n   *     fieldSpec: \"value\",\n   *     period: \"1m\",\n   *     method: \"linear\"\n   * });\n   * ```\n   *\n   * @param                options                An object containing options:\n   * @param {string|array} options.fieldSpec      Column or columns to align. If you need to\n   *                                              retrieve multiple deep nested values\n   *                                              that ['can.be', 'done.with', 'this.notation'].\n   *                                              A single deep value with a string.like.this.\n   * @param {string}       options.period         Spacing of aligned values. e.g. \"6h\" or \"5m\"\n   * @param {string}       options.method         \"linear\" or \"pad\" style interpolation to boundaries.\n   * @param {number}       options.limit          The maximum number of points which should be\n   *                                              interpolated onto boundaries. You might set this to\n   *                                              2 if you are willing to interpolate 2 new points,\n   *                                              and then beyond that just emit nulls on the boundaries.\n   *\n   * @return {TimeSeries}     The resulting aligned TimeSeries\n   */\n\n\n  align(options) {\n    var {\n      fieldSpec = \"value\",\n      period = \"5m\",\n      method = \"linear\",\n      limit = null\n    } = options;\n    var collection = this.pipeline().align(fieldSpec, period, method, limit).toKeyedCollections();\n    return this.setCollection(collection[\"all\"], true);\n  }\n  /**\n   * Returns the derivative of the TimeSeries for the given columns. The result will\n   * be per second. Optionally you can substitute in `null` values if the rate\n   * is negative. This is useful when a negative rate would be considered invalid.\n   *\n   * @param                options                An object containing options:\n   * @param {string|array} options.fieldSpec      Column or columns to get the rate of. If you\n   *                                              need to retrieve multiple deep nested values\n   *                                              that ['can.be', 'done.with', 'this.notation'].\n   * @param {bool}         options.allowNegative  Will output null values for negative rates.\n   *                                              This is useful if you are getting the rate\n   *                                              of a counter that always goes up, except\n   *                                              when perhaps it rolls around or resets.\n   *\n   * @return {TimeSeries}                         The resulting `TimeSeries` containing calculated rates.\n   */\n\n\n  rate() {\n    var options = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : {};\n    var {\n      fieldSpec = \"value\",\n      allowNegative = true\n    } = options;\n    var collection = this.pipeline().rate(fieldSpec, allowNegative).toKeyedCollections();\n    return this.setCollection(collection[\"all\"], true);\n  }\n  /**\n   * Builds a new TimeSeries by dividing events within the TimeSeries\n   * across multiple fixed windows of size `windowSize`.\n   *\n   * Note that these are windows defined relative to Jan 1st, 1970,\n   * and are UTC, so this is best suited to smaller window sizes\n   * (hourly, 5m, 30s, 1s etc), or in situations where you don't care\n   * about the specific window, just that the data is smaller.\n   *\n   * Each window then has an aggregation specification applied as\n   * `aggregation`. This specification describes a mapping of output\n   * fieldNames to aggregation functions and their fieldPath. For example:\n   * ```\n   * { in_avg: { in: avg() }, out_avg: { out: avg() } }\n   * ```\n   * will aggregate both \"in\" and \"out\" using the average aggregation\n   * function and return the result as in_avg and out_avg.\n   *\n   * Note that each aggregation function, such as `avg()` also can take a\n   * filter function to apply before the aggregation. A set of filter functions\n   * exists to do common data cleanup such as removing bad values. For example:\n   * ```\n   * { value_avg: { value: avg(filter.ignoreMissing) } }\n   * ```\n   *\n   * @example\n   * ```\n   *     const timeseries = new TimeSeries(data);\n   *     const dailyAvg = timeseries.fixedWindowRollup({\n   *         windowSize: \"1d\",\n   *         aggregation: {value: {value: avg()}}\n   *     });\n   * ```\n   *\n   * @param                options                An object containing options:\n   * @param {string}       options.windowSize     The size of the window. e.g. \"6h\" or \"5m\"\n   * @param {object}       options.aggregation    The aggregation specification (see description above)\n   * @param {bool}         options.toTimeEvents   Output as `TimeEvent`s, rather than `IndexedEvent`s\n   * @return {TimeSeries}                         The resulting rolled up `TimeSeries`\n   */\n\n\n  fixedWindowRollup(options) {\n    var {\n      windowSize,\n      aggregation,\n      toTimeEvents = false\n    } = options;\n\n    if (!windowSize) {\n      throw new Error(\"windowSize must be supplied, for example '5m' for five minute rollups\");\n    }\n\n    if (!aggregation || !_underscore.default.isObject(aggregation)) {\n      throw new Error(\"aggregation object must be supplied, for example: {value: {value: avg()}}\");\n    }\n\n    var aggregatorPipeline = this.pipeline().windowBy(windowSize).emitOn(\"discard\").aggregate(aggregation);\n    var eventTypePipeline = toTimeEvents ? aggregatorPipeline.asTimeEvents() : aggregatorPipeline;\n    var collections = eventTypePipeline.clearWindow().toKeyedCollections();\n    return this.setCollection(collections[\"all\"], true);\n  }\n  /**\n   * Builds a new TimeSeries by dividing events into hours.\n   *\n   * Each window then has an aggregation specification `aggregation`\n   * applied. This specification describes a mapping of output\n   * fieldNames to aggregation functions and their fieldPath. For example:\n   * ```\n   * {in_avg: {in: avg()}, out_avg: {out: avg()}}\n   * ```\n   *\n   * @param                options                An object containing options:\n   * @param {bool}         options.toTimeEvents   Convert the rollup events to `TimeEvent`s, otherwise it\n   *                                              will be returned as a `TimeSeries` of `IndexedEvent`s.\n   * @param {object}       options.aggregation    The aggregation specification (see description above)\n   *\n   * @return {TimeSeries}     The resulting rolled up TimeSeries\n   */\n\n\n  hourlyRollup(options) {\n    var {\n      aggregation,\n      toTimeEvents = false\n    } = options;\n\n    if (!aggregation || !_underscore.default.isObject(aggregation)) {\n      throw new Error(\"aggregation object must be supplied, for example: {value: {value: avg()}}\");\n    }\n\n    return this.fixedWindowRollup(\"1h\", aggregation, toTimeEvents);\n  }\n  /**\n   * Builds a new TimeSeries by dividing events into days.\n   *\n   * Each window then has an aggregation specification `aggregation`\n   * applied. This specification describes a mapping of output\n   * fieldNames to aggregation functions and their fieldPath. For example:\n   * ```\n   * {in_avg: {in: avg()}, out_avg: {out: avg()}}\n   * ```\n   *\n   * @param                options                An object containing options:\n   * @param {bool}         options.toTimeEvents   Convert the rollup events to `TimeEvent`s, otherwise it\n   *                                              will be returned as a `TimeSeries` of `IndexedEvent`s.\n   * @param {object}       options.aggregation    The aggregation specification (see description above)\n   *\n   * @return {TimeSeries}     The resulting rolled up TimeSeries\n   */\n\n\n  dailyRollup(options) {\n    var {\n      aggregation,\n      toTimeEvents = false\n    } = options;\n\n    if (!aggregation || !_underscore.default.isObject(aggregation)) {\n      throw new Error(\"aggregation object must be supplied, for example: {value: {value: avg()}}\");\n    }\n\n    return this._rollup(\"daily\", aggregation, toTimeEvents);\n  }\n  /**\n   * Builds a new TimeSeries by dividing events into months.\n   *\n   * Each window then has an aggregation specification `aggregation`\n   * applied. This specification describes a mapping of output\n   * fieldNames to aggregation functions and their fieldPath. For example:\n   * ```\n   * {in_avg: {in: avg()}, out_avg: {out: avg()}}\n   * ```\n   *\n   * @param                options                An object containing options:\n   * @param {bool}         options.toTimeEvents   Convert the rollup events to `TimeEvent`s, otherwise it\n   *                                              will be returned as a `TimeSeries` of `IndexedEvent`s.\n   * @param {object}       options.aggregation    The aggregation specification (see description above)\n   *\n   * @return {TimeSeries}                         The resulting rolled up `TimeSeries`\n   */\n\n\n  monthlyRollup(options) {\n    var {\n      aggregation,\n      toTimeEvents = false\n    } = options;\n\n    if (!aggregation || !_underscore.default.isObject(aggregation)) {\n      throw new Error(\"aggregation object must be supplied, for example: {value: {value: avg()}}\");\n    }\n\n    return this._rollup(\"monthly\", aggregation, toTimeEvents);\n  }\n  /**\n   * Builds a new TimeSeries by dividing events into years.\n   *\n   * Each window then has an aggregation specification `aggregation`\n   * applied. This specification describes a mapping of output\n   * fieldNames to aggregation functions and their fieldPath. For example:\n   *\n   * ```\n   * {in_avg: {in: avg()}, out_avg: {out: avg()}}\n   * ```\n   *\n   * @param                options                An object containing options:\n   * @param {bool}         options.toTimeEvents   Convert the rollup events to `TimeEvent`s, otherwise it\n   *                                              will be returned as a `TimeSeries` of `IndexedEvent`s.\n   * @param {object}       options.aggregation    The aggregation specification (see description above)\n   *\n   * @return {TimeSeries}                         The resulting rolled up `TimeSeries`\n   */\n\n\n  yearlyRollup(options) {\n    var {\n      aggregation,\n      toTimeEvents = false\n    } = options;\n\n    if (!aggregation || !_underscore.default.isObject(aggregation)) {\n      throw new Error(\"aggregation object must be supplied, for example: {value: {value: avg()}}\");\n    }\n\n    return this._rollup(\"yearly\", aggregation, toTimeEvents);\n  }\n  /**\n   * @private\n   *\n   * Internal function to build the TimeSeries rollup functions using\n   * an aggregator Pipeline.\n   */\n\n\n  _rollup(type, aggregation) {\n    var toTimeEvents = arguments.length > 2 && arguments[2] !== undefined ? arguments[2] : false;\n    var aggregatorPipeline = this.pipeline().windowBy(type).emitOn(\"discard\").aggregate(aggregation);\n    var eventTypePipeline = toTimeEvents ? aggregatorPipeline.asTimeEvents() : aggregatorPipeline;\n    var collections = eventTypePipeline.clearWindow().toKeyedCollections();\n    return this.setCollection(collections[\"all\"], true);\n  }\n  /**\n   * Builds multiple `Collection`s, each collects together\n   * events within a window of size `windowSize`. Note that these\n   * are windows defined relative to Jan 1st, 1970, and are UTC.\n   *\n   * @example\n   * ```\n   * const timeseries = new TimeSeries(data);\n   * const collections = timeseries.collectByFixedWindow({windowSize: \"1d\"});\n   * console.log(collections); // {1d-16314: Collection, 1d-16315: Collection, ...}\n   * ```\n   *\n   * @param                options                An object containing options:\n   * @param {bool}         options.windowSize     The size of the window. e.g. \"6h\" or \"5m\"\n   *\n   * @return {map}    The result is a mapping from window index to a Collection.\n   */\n\n\n  collectByFixedWindow(_ref) {\n    var {\n      windowSize\n    } = _ref;\n    return this.pipeline().windowBy(windowSize).emitOn(\"discard\").toKeyedCollections();\n  }\n  /*\n   * STATIC\n   */\n\n  /**\n   * Defines the event type contained in this TimeSeries. The default here\n   * is to use the supplied type (time, timerange or index) to build either\n   * a TimeEvent, TimeRangeEvent or IndexedEvent. However, you can also\n   * subclass the TimeSeries and reimplement this to return another event\n   * type.\n   */\n\n\n  static event(eventKey) {\n    switch (eventKey) {\n      case \"time\":\n        return _timeevent.default;\n\n      case \"timerange\":\n        return _timerangeevent.default;\n\n      case \"index\":\n        return _indexedevent.default;\n\n      default:\n        throw new Error(\"Unknown event type: \".concat(eventKey));\n    }\n  }\n  /**\n   * Static function to compare two TimeSeries to each other. If the TimeSeries\n   * are of the same instance as each other then equals will return true.\n   * @param  {TimeSeries} series1\n   * @param  {TimeSeries} series2\n   * @return {bool} result\n   */\n\n\n  static equal(series1, series2) {\n    return series1._data === series2._data && series1._collection === series2._collection;\n  }\n  /**\n   * Static function to compare two TimeSeries to each other. If the TimeSeries\n   * are of the same value as each other then equals will return true.\n   * @param  {TimeSeries} series1\n   * @param  {TimeSeries} series2\n   * @return {bool} result\n   */\n\n\n  static is(series1, series2) {\n    return _immutable.default.is(series1._data, series2._data) && _collection.default.is(series1._collection, series2._collection);\n  }\n  /**\n   * Reduces a list of TimeSeries objects using a reducer function. This works\n   * by taking each event in each TimeSeries and collecting them together\n   * based on timestamp. All events for a given time are then merged together\n   * using the reducer function to produce a new event. The reducer function is\n   * applied to all columns in the fieldSpec. Those new events are then\n   * collected together to form a new TimeSeries.\n   *\n   * @example\n   *\n   * For example you might have three TimeSeries with columns \"in\" and \"out\" which\n   * corresponds to two measurements per timestamp. You could use this function to\n   * obtain a new TimeSeries which was the sum of the the three measurements using\n   * the `sum()` reducer function and an [\"in\", \"out\"] fieldSpec.\n   *\n   * ```\n   * const totalSeries = TimeSeries.timeSeriesListReduce({\n   *     name: \"totals\",\n   *     seriesList: [inTraffic, outTraffic],\n   *     reducer: sum(),\n   *     fieldSpec: [ \"in\", \"out\" ]\n   * });\n   * ```\n   *\n   * @param                  options                An object containing options. Additional key\n   *                                                values in the options will be added as meta data\n   *                                                to the resulting TimeSeries.\n   * @param {array}          options.seriesList     A list of `TimeSeries` (required)\n   * @param {function}       options.reducer        The reducer function e.g. `max()` (required)\n   * @param {array | string} options.fieldSpec      Column or columns to reduce. If you\n   *                                                need to retrieve multiple deep\n   *                                                nested values that ['can.be', 'done.with',\n   *                                                'this.notation']. A single deep value with a\n   *                                                string.like.this.\n   *\n   * @return {TimeSeries}                           The reduced TimeSeries\n   */\n\n\n  static timeSeriesListReduce(options) {\n    var {\n      fieldSpec,\n      reducer\n    } = options,\n        data = (0, _objectWithoutProperties2.default)(options, [\"fieldSpec\", \"reducer\"]);\n\n    var combiner = _event.default.combiner(fieldSpec, reducer);\n\n    return TimeSeries.timeSeriesListEventReduce(_objectSpread({\n      fieldSpec,\n      reducer: combiner\n    }, data));\n  }\n  /**\n   * Takes a list of TimeSeries and merges them together to form a new\n   * Timeseries.\n   *\n   * Merging will produce a new Event;\n  only when events are conflict free, so\n   * it is useful in the following cases:\n   *  * to combine multiple TimeSeries which have different time ranges, essentially\n   *  concatenating them together\n   *  * combine TimeSeries which have different columns, for example inTraffic has\n   *  a column \"in\" and outTraffic has a column \"out\" and you want to produce a merged\n   *  trafficSeries with columns \"in\" and \"out\".\n   *\n   * @example\n   * ```\n   * const inTraffic = new TimeSeries(trafficDataIn);\n   * const outTraffic = new TimeSeries(trafficDataOut);\n   * const trafficSeries = TimeSeries.timeSeriesListMerge({\n   *     name: \"traffic\",\n   *     seriesList: [inTraffic, outTraffic]\n   * });\n   * ```\n   *\n   * @param                  options                An object containing options. Additional key\n   *                                                values in the options will be added as meta data\n   *                                                to the resulting TimeSeries.\n   * @param {array}          options.seriesList     A list of `TimeSeries` (required)\n   * @param {array | string} options.fieldSpec      Column or columns to merge. If you\n   *                                                need to retrieve multiple deep\n   *                                                nested values that ['can.be', 'done.with',\n   *                                                'this.notation']. A single deep value with a\n   *                                                string.like.this.\n   *\n   * @return {TimeSeries}                           The merged TimeSeries\n   */\n\n\n  static timeSeriesListMerge(options) {\n    var {\n      fieldSpec\n    } = options,\n        data = (0, _objectWithoutProperties2.default)(options, [\"fieldSpec\"]);\n\n    var merger = _event.default.merger(fieldSpec);\n\n    return TimeSeries.timeSeriesListEventReduce(_objectSpread({\n      fieldSpec,\n      reducer: merger\n    }, data));\n  }\n  /**\n   * @private\n   */\n\n\n  static timeSeriesListEventReduce(options) {\n    var {\n      seriesList,\n      fieldSpec,\n      reducer\n    } = options,\n        data = (0, _objectWithoutProperties2.default)(options, [\"seriesList\", \"fieldSpec\", \"reducer\"]);\n\n    if (!seriesList || !_underscore.default.isArray(seriesList)) {\n      throw new Error(\"A list of TimeSeries must be supplied to reduce\");\n    }\n\n    if (!reducer || !_underscore.default.isFunction(reducer)) {\n      throw new Error(\"reducer function must be supplied, for example avg()\");\n    } // for each series, make a map from timestamp to the\n    // list of events with that timestamp\n\n\n    var eventList = [];\n    seriesList.forEach(series => {\n      for (var event of series.events()) {\n        eventList.push(event);\n      }\n    });\n    var events = reducer(eventList, fieldSpec); // Make a collection. If the events are out of order, sort them.\n    // It's always possible that events are out of order here, depending\n    // on the start times of the series, along with it the series\n    // have missing data, so I think we don't have a choice here.\n\n    var collection = new _collection.default(events);\n\n    if (!collection.isChronological()) {\n      collection = collection.sortByTime();\n    }\n\n    var timeseries = new TimeSeries(_objectSpread({}, data, {\n      collection\n    }));\n    return timeseries;\n  }\n\n}\n\nvar _default = TimeSeries;\nexports.default = _default;","map":{"version":3,"sources":["/Users/nicholasraffone/Documents/swefall2021/finalproj/FinancialSentiment/fin_sentiment_front/node_modules/pondjs/lib/lib/timeseries.js"],"names":["_interopRequireDefault","require","Object","defineProperty","exports","value","default","_defineProperty2","_objectWithoutProperties2","_underscore","_immutable","_collection","_index","_event","_timeevent","_timerangeevent","_indexedevent","_pipeline","ownKeys","object","enumerableOnly","keys","getOwnPropertySymbols","symbols","filter","sym","getOwnPropertyDescriptor","enumerable","push","apply","_objectSpread","target","i","arguments","length","source","forEach","key","getOwnPropertyDescriptors","defineProperties","buildMetaData","meta","d","name","index","isString","utc","isBoolean","Map","TimeSeries","constructor","arg","_data","other","isObject","obj","has","events","meta1","collection","meta3","columns","points","meta2","eventKey","eventFields","_events","map","point","t","eventValues","options","Error","isChronological","toJSON","e","atFirst","columnList","_e","toPoint","extend","toString","JSON","stringify","timerange","range","begin","end","at","pos","atTime","time","bisect","size","atLast","setCollection","undefined","result","b","tms","getTime","ts","timestamp","slice","sliced","crop","timerangeBegin","beginPos","bisectedEventOutsideRange","endPos","clean","fieldSpec","cleaned","get","setName","setMeta","indexAsString","asString","indexAsRange","asTimerange","isUTC","c","data","each","val","newTimeSeries","dd","set","sizeValid","count","sum","fieldPath","max","min","avg","mean","median","stdev","percentile","q","interp","aggregate","func","quantile","quantity","pipeline","Pipeline","from","op","collections","toKeyedCollections","select","collapse","fieldSpecList","reducer","append","renameColumns","renameMap","event","eventType","type","mapKeys","fill","method","limit","isArray","align","period","rate","allowNegative","fixedWindowRollup","windowSize","aggregation","toTimeEvents","aggregatorPipeline","windowBy","emitOn","eventTypePipeline","asTimeEvents","clearWindow","hourlyRollup","dailyRollup","_rollup","monthlyRollup","yearlyRollup","collectByFixedWindow","_ref","concat","equal","series1","series2","is","timeSeriesListReduce","combiner","timeSeriesListEventReduce","timeSeriesListMerge","merger","seriesList","isFunction","eventList","series","sortByTime","timeseries","_default"],"mappings":"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uC,QAApB,CAA6BJ,IAAI,CAACG,KAAlC,CAAJ,EAA8C;AAC5CF,MAAAA,CAAC,CAACE,KAAF,GAAU,IAAIhC,MAAM,CAACN,OAAX,CAAmBmC,IAAI,CAACG,KAAxB,CAAV;AACD,KAFD,MAEO,IAAIH,IAAI,CAACG,KAAL,YAAsBhC,MAAM,CAACN,OAAjC,EAA0C;AAC/CoC,MAAAA,CAAC,CAACE,KAAF,GAAUH,IAAI,CAACG,KAAf;AACD;AACF,GAX0B,CAWzB;;;AAGFF,EAAAA,CAAC,CAACI,GAAF,GAAQ,IAAR;;AAEA,MAAIrC,WAAW,CAACH,OAAZ,CAAoByC,SAApB,CAA8BN,IAAI,CAACK,GAAnC,CAAJ,EAA6C;AAC3CJ,IAAAA,CAAC,CAACI,GAAF,GAAQL,IAAI,CAACK,GAAb;AACD;;AAED,SAAO,IAAIpC,UAAU,CAACJ,OAAX,CAAmB0C,GAAvB,CAA2BN,CAA3B,CAAP;AACD;AACD;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;;AAGA,MAAMO,UAAN,CAAiB;AACfC,EAAAA,WAAW,CAACC,GAAD,EAAM;AACf,SAAKxC,WAAL,GAAmB,IAAnB,CADe,CACU;;AAEzB,SAAKyC,KAAL,GAAa,IAAb,CAHe,CAGI;;AAEnB,QAAID,GAAG,YAAYF,UAAnB,EAA+B;AAC7B;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","sourcesContent":["\"use strict\";\n\nvar _interopRequireDefault = require(\"@babel/runtime/helpers/interopRequireDefault\");\n\nObject.defineProperty(exports, \"__esModule\", {\n  value: true\n});\nexports.default = void 0;\n\nvar _defineProperty2 = _interopRequireDefault(require(\"@babel/runtime/helpers/defineProperty\"));\n\nvar _objectWithoutProperties2 = _interopRequireDefault(require(\"@babel/runtime/helpers/objectWithoutProperties\"));\n\nvar _underscore = _interopRequireDefault(require(\"underscore\"));\n\nvar _immutable = _interopRequireDefault(require(\"immutable\"));\n\nvar _collection = _interopRequireDefault(require(\"./collection\"));\n\nvar _index = _interopRequireDefault(require(\"./index\"));\n\nvar _event = _interopRequireDefault(require(\"./event\"));\n\nvar _timeevent = _interopRequireDefault(require(\"./timeevent\"));\n\nvar _timerangeevent = _interopRequireDefault(require(\"./timerangeevent\"));\n\nvar _indexedevent = _interopRequireDefault(require(\"./indexedevent\"));\n\nvar _pipeline = require(\"./pipeline.js\");\n\nfunction ownKeys(object, enumerableOnly) { var keys = Object.keys(object); if (Object.getOwnPropertySymbols) { var symbols = Object.getOwnPropertySymbols(object); if (enumerableOnly) symbols = symbols.filter(function (sym) { return Object.getOwnPropertyDescriptor(object, sym).enumerable; }); keys.push.apply(keys, symbols); } return keys; }\n\nfunction _objectSpread(target) { for (var i = 1; i < arguments.length; i++) { var source = arguments[i] != null ? arguments[i] : {}; if (i % 2) { ownKeys(source, true).forEach(function (key) { (0, _defineProperty2.default)(target, key, source[key]); }); } else if (Object.getOwnPropertyDescriptors) { Object.defineProperties(target, Object.getOwnPropertyDescriptors(source)); } else { ownKeys(source).forEach(function (key) { Object.defineProperty(target, key, Object.getOwnPropertyDescriptor(source, key)); }); } } return target; }\n\nfunction buildMetaData(meta) {\n  var d = meta ? meta : {}; // Name\n\n  d.name = meta.name ? meta.name : \"\"; // Index\n\n  if (meta.index) {\n    if (_underscore.default.isString(meta.index)) {\n      d.index = new _index.default(meta.index);\n    } else if (meta.index instanceof _index.default) {\n      d.index = meta.index;\n    }\n  } // UTC or Local time\n\n\n  d.utc = true;\n\n  if (_underscore.default.isBoolean(meta.utc)) {\n    d.utc = meta.utc;\n  }\n\n  return new _immutable.default.Map(d);\n}\n/**\n * A `TimeSeries` represents a series of events, with each event being a combination of:\n *\n *  - time (or `TimeRange`, or `Index`)\n *  - data - corresponding set of key/values.\n *\n * ### Construction\n *\n * Currently you can initialize a `TimeSeries` with either a list of events, or with a data format that looks like this:\n *\n * ```javascript\n * const data = {\n *     name: \"trafficc\",\n *     columns: [\"time\", \"value\"],\n *     points: [\n *         [1400425947000, 52],\n *         [1400425948000, 18],\n *         [1400425949000, 26],\n *         [1400425950000, 93],\n *         ...\n *     ]\n * };\n * ```\n *\n * To create a new TimeSeries object from the above format, simply use the constructor:\n *\n * ```javascript\n * const series = new TimeSeries(data);\n * ```\n *\n * The format of the data is as follows:\n *\n *  - **name** - optional, but a good practice\n *  - **columns** - are necessary and give labels to the data in the points.\n *  - **points** - are an array of tuples. Each row is at a different time (or timerange), and each value corresponds to the column labels.\n *\n * As just hinted at, the first column may actually be:\n *\n *  - \"time\"\n *  - \"timeRange\" represented by a `TimeRange`\n *  - \"index\" - a time range represented by an `Index`. By using an index it is possible, for example, to refer to a specific month:\n *\n * ```javascript\n * const availabilityData = {\n *     name: \"Last 3 months availability\",\n *     columns: [\"index\", \"uptime\"],\n *     points: [\n *         [\"2015-06\", \"100%\"], // <-- 2015-06 specified here represents June 2015\n *         [\"2015-05\", \"92%\"],\n *         [\"2015-04\", \"87%\"],\n *     ]\n * };\n * ```\n *\n * Alternatively, you can construct a `TimeSeries` with a list of events.\n * These may be `TimeEvents`, `TimeRangeEvents` or `IndexedEvents`. Here's an example of that:\n *\n * ```javascript\n * const events = [];\n * events.push(new TimeEvent(new Date(2015, 7, 1), {value: 27}));\n * events.push(new TimeEvent(new Date(2015, 8, 1), {value: 29}));\n * const series = new TimeSeries({\n *     name: \"avg temps\",\n *     events: events\n * });\n * ```\n *\n * ### Nested data\n *\n * The values do not have to be simple types like the above examples. Here's an\n * example where each value is itself an object with \"in\" and \"out\" keys:\n *\n * ```javascript\n * const series = new TimeSeries({\n *     name: \"Map Traffic\",\n *     columns: [\"time\", \"NASA_north\", \"NASA_south\"],\n *     points: [\n *         [1400425951000, {in: 100, out: 200}, {in: 145, out: 135}],\n *         [1400425952000, {in: 200, out: 400}, {in: 146, out: 142}],\n *         [1400425953000, {in: 300, out: 600}, {in: 147, out: 158}],\n *         [1400425954000, {in: 400, out: 800}, {in: 155, out: 175}],\n *     ]\n * });\n * ```\n *\n * Complex data is stored in an Immutable structure. To get a value out of nested\n * data like this you will get the event you want (by row), as usual, and then use\n * `get()` to fetch the value by column name. The result of this call will be a\n * JSON copy of the Immutable data so you can query deeper in the usual way:\n *\n * ```javascript\n * series.at(0).get(\"NASA_north\")[\"in\"]  // 200`\n * ```\n *\n * It is then possible to use a value mapper function when calculating different\n * properties. For example, to get the average \"in\" value of the NASA_north column:\n *\n * ```javascript\n * series.avg(\"NASA_north\", d => d.in);  // 250\n * ```\n */\n\n\nclass TimeSeries {\n  constructor(arg) {\n    this._collection = null; // Collection\n\n    this._data = null; // Meta data\n\n    if (arg instanceof TimeSeries) {\n      //\n      // Copy another TimeSeries\n      //\n      var other = arg;\n      this._data = other._data;\n      this._collection = other._collection;\n    } else if (_underscore.default.isObject(arg)) {\n      //\n      // TimeSeries(object data) where data may be:\n      //    { \"events\": [event-1, event-2, ..., event-n]}\n      // or\n      //    { \"columns\": [time|timerange|index, column-1, ..., column-n]\n      //      \"points\": [\n      //         [t1, v1, v2, ..., v2],\n      //         [t2, v1, v2, ..., vn],\n      //         ...\n      //      ]\n      //    }\n      var obj = arg;\n\n      if (_underscore.default.has(obj, \"events\")) {\n        //\n        // Initialized from an event list\n        //\n        var {\n          events\n        } = obj,\n            meta1 = (0, _objectWithoutProperties2.default)(obj, [\"events\"]); //eslint-disable-line\n\n        this._collection = new _collection.default(events);\n        this._data = buildMetaData(meta1);\n      } else if (_underscore.default.has(obj, \"collection\")) {\n        //\n        // Initialized from a Collection\n        //\n        var {\n          collection\n        } = obj,\n            meta3 = (0, _objectWithoutProperties2.default)(obj, [\"collection\"]); //eslint-disable-line\n\n        this._collection = collection;\n        this._data = buildMetaData(meta3);\n      } else if (_underscore.default.has(obj, \"columns\") && _underscore.default.has(obj, \"points\")) {\n        //\n        // Initialized from the wire format\n        //\n        var {\n          columns,\n          points,\n          utc = true\n        } = obj,\n            meta2 = (0, _objectWithoutProperties2.default)(obj, [\"columns\", \"points\", \"utc\"]); //eslint-disable-line\n\n        var [eventKey, ...eventFields] = columns;\n\n        var _events = points.map(point => {\n          var [t, ...eventValues] = point;\n\n          var d = _underscore.default.object(eventFields, eventValues);\n\n          var options = utc;\n\n          switch (eventKey) {\n            case \"time\":\n              return new _timeevent.default(t, d, options);\n\n            case \"index\":\n              return new _indexedevent.default(t, d, options);\n\n            case \"timerange\":\n              return new _timerangeevent.default(t, d, options);\n\n            default:\n              throw new Error(\"Unknown event type\");\n          }\n        });\n\n        this._collection = new _collection.default(_events);\n        this._data = buildMetaData(meta2);\n      }\n\n      if (!this._collection.isChronological()) {\n        throw new Error(\"TimeSeries was passed non-chronological events\");\n      }\n    }\n  } //\n  // Serialize\n  //\n\n  /**\n   * Turn the TimeSeries into regular javascript objects\n   */\n\n\n  toJSON() {\n    var e = this.atFirst();\n\n    if (!e) {\n      return;\n    }\n\n    var columnList = this.columns();\n    var columns;\n\n    if (e instanceof _timeevent.default) {\n      columns = [\"time\", ...columnList];\n    } else if (e instanceof _timerangeevent.default) {\n      columns = [\"timerange\", ...columnList];\n    } else if (e instanceof _indexedevent.default) {\n      columns = [\"index\", ...columnList];\n    }\n\n    var points = [];\n\n    for (var _e of this._collection.events()) {\n      points.push(_e.toPoint(columnList));\n    }\n\n    return _underscore.default.extend(this._data.toJSON(), {\n      columns,\n      points\n    });\n  }\n  /**\n   * Represent the TimeSeries as a string\n   */\n\n\n  toString() {\n    return JSON.stringify(this.toJSON());\n  }\n  /**\n   * Returns the extents of the TimeSeries as a TimeRange.\n   */\n\n\n  timerange() {\n    return this._collection.range();\n  }\n  /**\n   * Alias for `timerange()`\n   */\n\n\n  range() {\n    return this.timerange();\n  }\n  /**\n   * Gets the earliest time represented in the TimeSeries.\n   *\n   * @return {Date} Begin time\n   */\n\n\n  begin() {\n    return this.range().begin();\n  }\n  /**\n   * Gets the latest time represented in the TimeSeries.\n   *\n   * @return {Date} End time\n   */\n\n\n  end() {\n    return this.range().end();\n  }\n  /**\n   * Access a specific TimeSeries event via its position\n   *\n   * @param {number} pos The event position\n   */\n\n\n  at(pos) {\n    return this._collection.at(pos);\n  }\n  /**\n   * Returns an event in the series by its time. This is the same\n   * as calling `bisect` first and then using `at` with the index.\n   *\n   * @param  {Date} time The time of the event.\n   * @return {TimeEvent|IndexedEvent|TimeRangeEvent}\n   */\n\n\n  atTime(time) {\n    var pos = this.bisect(time);\n\n    if (pos >= 0 && pos < this.size()) {\n      return this.at(pos);\n    }\n  }\n  /**\n   * Returns the first event in the series.\n   *\n   * @return {TimeEvent|IndexedEvent|TimeRangeEvent}\n   */\n\n\n  atFirst() {\n    return this._collection.atFirst();\n  }\n  /**\n   * Returns the last event in the series.\n   *\n   * @return {TimeEvent|IndexedEvent|TimeRangeEvent}\n   */\n\n\n  atLast() {\n    return this._collection.atLast();\n  }\n  /**\n   * Generator to return all the events in the series\n   *\n   * @example\n   * ```\n   * for (let event of series.events()) {\n   *     console.log(event.toString());\n   * }\n   * ```\n   */\n\n\n  *events() {\n    for (var i = 0; i < this.size(); i++) {\n      yield this.at(i);\n    }\n  }\n  /**\n   * Sets a new underlying collection for this TimeSeries.\n   *\n   * @param {Collection}  collection       The new collection\n   * @param {boolean}     isChronological  Causes the chronological\n   *                                       order of the events to\n   *                                       not be checked\n   *\n   * @return {TimeSeries}                  A new TimeSeries\n   */\n\n\n  setCollection(collection) {\n    var isChronological = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : false;\n\n    if (!isChronological && !collection.isChronological()) {\n      throw new Error(\"Collection supplied is not chronological\");\n    }\n\n    var result = new TimeSeries(this);\n\n    if (collection) {\n      result._collection = collection;\n    } else {\n      result._collection = new _collection.default();\n    }\n\n    return result;\n  }\n  /**\n   * Returns the index that bisects the TimeSeries at the time specified.\n   *\n   * @param  {Date}    t   The time to bisect the TimeSeries with\n   * @param  {number}  b   The position to begin searching at\n   *\n   * @return {number}      The row number that is the greatest, but still below t.\n   */\n\n\n  bisect(t, b) {\n    var tms = t.getTime();\n    var size = this.size();\n    var i = b || 0;\n\n    if (!size) {\n      return undefined;\n    }\n\n    for (; i < size; i++) {\n      var ts = this.at(i).timestamp().getTime();\n\n      if (ts > tms) {\n        return i - 1 >= 0 ? i - 1 : 0;\n      } else if (ts === tms) {\n        return i;\n      }\n    }\n\n    return i - 1;\n  }\n  /**\n   * Perform a slice of events within the TimeSeries, returns a new\n   * TimeSeries representing a portion of this TimeSeries from\n   * begin up to but not including end.\n   *\n   * @param {Number} begin   The position to begin slicing\n   * @param {Number} end     The position to end slicing\n   *\n   * @return {TimeSeries}    The new, sliced, TimeSeries.\n   */\n\n\n  slice(begin, end) {\n    var sliced = this._collection.slice(begin, end);\n\n    return this.setCollection(sliced, true);\n  }\n  /**\n   * Crop the TimeSeries to the specified TimeRange and\n   * return a new TimeSeries.\n   *\n   * @param {TimeRange} timerange   The bounds of the new TimeSeries\n   *\n   * @return {TimeSeries}    The new, cropped, TimeSeries.\n   */\n\n\n  crop(timerange) {\n    var timerangeBegin = timerange.begin();\n    var beginPos = this.bisect(timerangeBegin);\n    var bisectedEventOutsideRange = this.at(beginPos).timestamp() < timerangeBegin;\n    beginPos = bisectedEventOutsideRange ? beginPos + 1 : beginPos;\n    var endPos = this.bisect(timerange.end(), beginPos);\n    return this.slice(beginPos, endPos + 1);\n  }\n  /**\n   * Returns a new TimeSeries by testing the fieldPath\n   * values for being valid (not NaN, null or undefined).\n   *\n   * The resulting TimeSeries will be clean (for that fieldPath).\n   *\n   * @param  {string}      fieldPath  Name of value to look up. If not supplied,\n   *                                  defaults to ['value']. \"Deep\" syntax is\n   *                                  ['deep', 'value'] or 'deep.value'\n   *\n   * @return {TimeSeries}             A new, modified, TimeSeries.\n   */\n\n\n  clean(fieldSpec) {\n    var cleaned = this._collection.clean(fieldSpec);\n\n    return this.setCollection(cleaned, true);\n  }\n  /**\n   * Generator to return all the events in the collection.\n   *\n   * @example\n   * ```\n   * for (let event of timeseries.events()) {\n   *     console.log(event.toString());\n   * }\n   * ```\n   */\n\n\n  *events() {\n    for (var i = 0; i < this.size(); i++) {\n      yield this.at(i);\n    }\n  } //\n  // Access meta data about the series\n  //\n\n  /**\n   * Fetch the timeseries name\n   *\n   * @return {string} The name given to this TimeSeries\n   */\n\n\n  name() {\n    return this._data.get(\"name\");\n  }\n  /**\n   * Rename the timeseries\n   */\n\n\n  setName(name) {\n    return this.setMeta(\"name\", name);\n  }\n  /**\n   * Fetch the timeseries Index, if it has one.\n   *\n   * @return {Index} The Index given to this TimeSeries\n   */\n\n\n  index() {\n    return this._data.get(\"index\");\n  }\n  /**\n   * Fetch the timeseries Index, as a string, if it has one.\n   *\n   * @return {string} The Index, as a string, given to this TimeSeries\n   */\n\n\n  indexAsString() {\n    return this.index() ? this.index().asString() : undefined;\n  }\n  /**\n   * Fetch the timeseries `Index`, as a `TimeRange`, if it has one.\n   *\n   * @return {TimeRange} The `Index`, as a `TimeRange`, given to this `TimeSeries`\n   */\n\n\n  indexAsRange() {\n    return this.index() ? this.index().asTimerange() : undefined;\n  }\n  /**\n   * Fetch the UTC flag, i.e. are the events in this `TimeSeries` in\n   * UTC or local time (if they are `IndexedEvent`s an event might be\n   * \"2014-08-31\". The actual time range of that representation\n   * depends on where you are. Pond supports thinking about that in\n   * either as a UTC day, or a local day).\n   *\n   * @return {TimeRange} The Index, as a TimeRange, given to this TimeSeries\n   */\n\n\n  isUTC() {\n    return this._data.get(\"utc\");\n  }\n  /**\n   * Fetch the list of column names. This is determined by\n   * traversing though the events and collecting the set.\n   *\n   * Note: the order is not defined\n   *\n   * @return {array} List of columns\n   */\n\n\n  columns() {\n    var c = {};\n\n    for (var e of this._collection.events()) {\n      var d = e.toJSON().data;\n\n      _underscore.default.each(d, (val, key) => {\n        c[key] = true;\n      });\n    }\n\n    return _underscore.default.keys(c);\n  }\n  /**\n   * Returns the internal `Collection` of events for this `TimeSeries`\n   *\n   * @return {Collection} The collection backing this `TimeSeries`\n   */\n\n\n  collection() {\n    return this._collection;\n  }\n  /**\n   * Returns the meta data about this TimeSeries as a JSON object.\n   * Any extra data supplied to the TimeSeries constructor will be\n   * placed in the meta data object. This returns either all of that\n   * data as a JSON object, or a specific key if `key` is supplied.\n   *\n   * @param {string}   key   Optional specific part of the meta data\n   * @return {object}        The meta data\n   */\n\n\n  meta(key) {\n    if (!key) {\n      return this._data.toJSON();\n    } else {\n      return this._data.get(key);\n    }\n  }\n  /**\n   * Set new meta data for the TimeSeries. The result will\n   * be a new TimeSeries.\n   */\n\n\n  setMeta(key, value) {\n    var newTimeSeries = new TimeSeries(this);\n    var d = newTimeSeries._data;\n    var dd = d.set(key, value);\n    newTimeSeries._data = dd;\n    return newTimeSeries;\n  } //\n  // Access the series itself\n  //\n\n  /**\n   * Returns the number of events in this TimeSeries\n   *\n   * @return {number} Count of events\n   */\n\n\n  size() {\n    return this._collection ? this._collection.size() : 0;\n  }\n  /**\n   * Returns the number of valid items in this TimeSeries.\n   *\n   * Uses the fieldSpec to look up values in all events.\n   * It then counts the number that are considered valid, which\n   * specifically are not NaN, undefined or null.\n   *\n   * @return {number} Count of valid events\n   */\n\n\n  sizeValid(fieldSpec) {\n    return this._collection.sizeValid(fieldSpec);\n  }\n  /**\n   * Returns the number of events in this TimeSeries. Alias\n   * for size().\n   *\n   * @return {number} Count of events\n   */\n\n\n  count() {\n    return this.size();\n  }\n  /**\n   * Returns the sum for the fieldspec\n   *\n   * @param {string} fieldPath  Column to find the stdev of. A deep value can\n   *                            be referenced with a string.like.this.  If not supplied\n   *                            the `value` column will be aggregated.\n   * @param {function} filter   Optional filter function used to clean data before aggregating\n   *\n   * @return {number}           The sum\n   */\n\n\n  sum(fieldPath, filter) {\n    return this._collection.sum(fieldPath, filter);\n  }\n  /**\n   * Aggregates the events down to their maximum value\n   *\n   * @param {string} fieldPath  Column to find the max of. A deep value can\n   *                            be referenced with a string.like.this.  If not supplied\n   *                            the `value` column will be aggregated.\n   *\n   * @return {number}           The max value for the field\n   */\n\n\n  max(fieldPath, filter) {\n    return this._collection.max(fieldPath, filter);\n  }\n  /**\n   * Aggregates the events down to their minimum value\n   *\n   * @param {string} fieldPath  Column to find the min of. A deep value can\n   *                            be referenced with a string.like.this.  If not supplied\n   *                            the `value` column will be aggregated.\n   * @param {function} filter   Optional filter function used to clean data before aggregating\n   *\n   * @return {number}           The min value for the field\n   */\n\n\n  min(fieldPath, filter) {\n    return this._collection.min(fieldPath, filter);\n  }\n  /**\n   * Aggregates the events in the TimeSeries down to their average\n   *\n   * @param {string} fieldPath  Column to find the avg of. A deep value can\n   *                            be referenced with a string.like.this.  If not supplied\n   *                            the `value` column will be aggregated.\n   * @param {function} filter   Optional filter function used to clean data before aggregating\n   *\n   * @return {number}           The average\n   */\n\n\n  avg(fieldPath, filter) {\n    return this._collection.avg(fieldPath, filter);\n  }\n  /**\n   * Aggregates the events in the TimeSeries down to their mean (same as avg)\n   *\n   * @param {string} fieldPath  Column to find the mean of. A deep value can\n   *                            be referenced with a string.like.this.  If not supplied\n   *                            the `value` column will be aggregated.\n   * @param {function} filter   Optional filter function used to clean data before aggregating\n   *\n   * @return {number}           The mean\n   */\n\n\n  mean(fieldPath, filter) {\n    return this._collection.mean(fieldPath, filter);\n  }\n  /**\n   * Aggregates the events down to their medium value\n   *\n   * @param {string} fieldPath  Column to find the median of. A deep value can\n   *                            be referenced with a string.like.this.  If not supplied\n   *                            the `value` column will be aggregated.\n   * @param {function} filter   Optional filter function used to clean data before aggregating\n   *\n   * @return {number}           The resulting median value\n   */\n\n\n  median(fieldPath, filter) {\n    return this._collection.median(fieldPath, filter);\n  }\n  /**\n   * Aggregates the events down to their stdev\n   *\n   * @param {string} fieldPath  Column to find the stdev of. A deep value can\n   *                            be referenced with a string.like.this.  If not supplied\n   *                            the `value` column will be aggregated.\n   * @param {function} filter   Optional filter function used to clean data before aggregating\n   *\n   * @return {number}           The resulting stdev value\n   */\n\n\n  stdev(fieldPath, filter) {\n    return this._collection.stdev(fieldPath, filter);\n  }\n  /**\n   * Gets percentile q within the TimeSeries. This works the same way as numpy.\n   *\n   * @param  {integer} q         The percentile (should be between 0 and 100)\n   *\n   * @param {string} fieldPath   Column to find the qth percentile of. A deep value can\n   *                             be referenced with a string.like.this.  If not supplied\n   *                             the `value` column will be aggregated.\n   *\n   * @param  {string}  interp    Specifies the interpolation method\n   *                             to use when the desired quantile lies between\n   *                             two data points. Options are: \"linear\", \"lower\", \"higher\",\n   *                             \"nearest\", \"midpoint\"\n   * @param {function} filter    Optional filter function used to clean data before aggregating\n   *\n   * @return {number}            The percentile\n   */\n\n\n  percentile(q, fieldPath) {\n    var interp = arguments.length > 2 && arguments[2] !== undefined ? arguments[2] : \"linear\";\n    var filter = arguments.length > 3 ? arguments[3] : undefined;\n    return this._collection.percentile(q, fieldPath, interp, filter);\n  }\n  /**\n   * Aggregates the events down using a user defined function to\n   * do the reduction.\n   *\n   * @param  {function} func    User defined reduction function. Will be\n   *                            passed a list of values. Should return a\n   *                            singe value.\n   * @param {string} fieldPath  Column to aggregate over. A deep value can\n   *                            be referenced with a string.like.this.  If not supplied\n   *                            the `value` column will be aggregated.\n   *\n   * @return {number}           The resulting value\n   */\n\n\n  aggregate(func, fieldPath) {\n    return this._collection.aggregate(func, fieldPath);\n  }\n  /**\n   * Gets n quantiles within the TimeSeries. This works the same way as numpy's percentile().\n   * For example `timeseries.quantile(4)` would be the same as using percentile with q = 0.25, 0.5 and 0.75.\n   *\n   * @param  {integer} n        The number of quantiles to divide the\n   *                            TimeSeries into.\n   * @param {string} fieldPath  Column to calculate over. A deep value can\n   *                            be referenced with a string.like.this.  If not supplied\n   *                            the `value` column will be aggregated.\n   * @param  {string} interp    Specifies the interpolation method\n   *                            to use when the desired quantile lies between\n   *                            two data points. Options are: \"linear\", \"lower\", \"higher\",\n   *                            \"nearest\", \"midpoint\".\n   * @return {array}            An array of n quantiles\n   */\n\n\n  quantile(quantity) {\n    var fieldPath = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : \"value\";\n    var interp = arguments.length > 2 && arguments[2] !== undefined ? arguments[2] : \"linear\";\n    return this._collection.quantile(quantity, fieldPath, interp);\n  }\n  /**\n   * Returns a new Pipeline with input source being initialized to\n   * this TimeSeries collection. This allows pipeline operations\n   * to be chained directly onto the TimeSeries to produce a new\n   * TimeSeries or event result.\n   *\n   * @example\n   *\n   * ```\n   * timeseries.pipeline()\n   *     .offsetBy(1)\n   *     .offsetBy(2)\n   *     .to(CollectionOut, c => out = c);\n   * ```\n   *\n   * @return {Pipeline} The Pipeline.\n   */\n\n\n  pipeline() {\n    return new _pipeline.Pipeline().from(this._collection);\n  }\n  /**\n   * Takes an operator that is used to remap events from this TimeSeries to\n   * a new set of events.\n   *\n   * @param  {function}   operator      An operator which will be passed each\n   *                                    event and which should return a new event.\n   * @return {TimeSeries}               A TimeSeries containing the remapped events\n   */\n\n\n  map(op) {\n    var collections = this.pipeline().map(op).toKeyedCollections();\n    return this.setCollection(collections[\"all\"], true);\n  }\n  /**\n   * Takes a fieldSpec (list of column names) and outputs to the callback just those\n   * columns in a new TimeSeries.\n   *\n   * @example\n   *\n   * ```\n   *     const ts = timeseries.select({fieldSpec: [\"uptime\", \"notes\"]});\n   * ```\n   *\n   * @param                options           An object containing options for the command\n   * @param {string|array} options.fieldSpec Column or columns to select into the new TimeSeries.\n   *                                         If you need to retrieve multiple deep nested values\n   *                                         that ['can.be', 'done.with', 'this.notation'].\n   *                                         A single deep value with a string.like.this.\n   *\n   * @return {TimeSeries}                    The resulting TimeSeries with renamed columns\n   */\n\n\n  select(options) {\n    var {\n      fieldSpec\n    } = options;\n    var collections = this.pipeline().select(fieldSpec).toKeyedCollections();\n    return this.setCollection(collections[\"all\"], true);\n  }\n  /**\n   * Takes a `fieldSpecList` (list of column names) and collapses\n   * them to a new column named `name` which is the reduction (using\n   * the `reducer` function) of the matched columns in the `fieldSpecList`.\n   *\n   * The column may be appended to the existing columns, or replace them,\n   * based on the `append` boolean.\n   *\n   * @example\n   *\n   * ```\n   *     const sums = ts.collapse({\n   *          name: \"sum_series\",\n   *          fieldSpecList: [\"in\", \"out\"],\n   *          reducer: sum(),\n   *          append: false\n   *     });\n   * ```\n   *\n   * @param                options                An object containing options:\n   * @param {array}        options.fieldSpecList  The list of columns to collapse. (required)\n   * @param {string}       options.name           The resulting collapsed column name (required)\n   * @param {function}     options.reducer        The reducer function (required)\n   * @param {bool}         options.append         Append the collapsed column, rather\n   *                                              than replace\n   *\n   * @return {TimeSeries}     The resulting collapsed TimeSeries\n   */\n\n\n  collapse(options) {\n    var {\n      fieldSpecList,\n      name,\n      reducer,\n      append\n    } = options;\n    var collections = this.pipeline().collapse(fieldSpecList, name, reducer, append).toKeyedCollections();\n    return this.setCollection(collections[\"all\"], true);\n  }\n  /**\n   * Rename columns in the underlying events.\n   *\n   * Takes a object of columns to rename. Returns a new `TimeSeries` containing\n   * new events. Columns not in the dict will be retained and not renamed.\n   *\n   * @example\n   * ```\n   * new_ts = ts.renameColumns({\n   *     renameMap: {in: \"new_in\", out: \"new_out\"}\n   * });\n   * ```\n   *\n   * @note As the name implies, this will only rename the main\n   * \"top level\" (ie: non-deep) columns. If you need more\n   * extravagant renaming, roll your own using `TimeSeries.map()`.\n   *\n   * @param                options                An object containing options:\n   * @param {Object}       options.renameMap      Columns to rename.\n   *\n   * @return {TimeSeries}     The resulting TimeSeries with renamed columns\n   */\n\n\n  renameColumns(options) {\n    var {\n      renameMap\n    } = options;\n    return this.map(event => {\n      var eventType = event.type();\n      var d = event.data().mapKeys(key => renameMap[key] || key);\n      return new eventType(event.key(), d);\n    });\n  }\n  /**\n   * Take the data in this TimeSeries and \"fill\" any missing or invalid\n   * values. This could be setting `null` values to zero so mathematical\n   * operations will succeed, interpolate a new value, or pad with the\n   * previously given value.\n   *\n   * The `fill()` method takes a single `options` arg.\n   *\n   * @example\n   * ```\n   * const filled = timeseries.fill({\n   *     fieldSpec: [\"direction.in\", \"direction.out\"],\n   *     method: \"zero\",\n   *     limit: 3\n   * });\n   * ```\n   *\n   * @param                options                An object containing options:\n   * @param {string|array} options.fieldSpec      Column or columns to fill. If you need to\n   *                                              retrieve multiple deep nested values\n   *                                              that ['can.be', 'done.with', 'this.notation'].\n   *                                              A single deep value with a string.like.this.\n   * @param {string}       options.method         \"linear\" or \"pad\" or \"zero\" style interpolation\n   * @param {number}       options.limit          The maximum number of points which should be\n   *                                              interpolated onto missing points. You might set this to\n   *                                              2 if you are willing to fill 2 new points,\n   *                                              and then beyond that leave data with missing values.\n   *\n   * @return {TimeSeries}                         The resulting filled TimeSeries\n   */\n\n\n  fill(options) {\n    var {\n      fieldSpec = null,\n      method = \"zero\",\n      limit = null\n    } = options;\n    var pipeline = this.pipeline();\n\n    if (method === \"zero\" || method === \"pad\") {\n      pipeline = pipeline.fill({\n        fieldSpec,\n        method,\n        limit\n      });\n    } else if (method === \"linear\" && _underscore.default.isArray(fieldSpec)) {\n      fieldSpec.forEach(fieldPath => {\n        pipeline = pipeline.fill({\n          fieldSpec: fieldPath,\n          method,\n          limit\n        });\n      });\n    } else {\n      throw new Error(\"Invalid fill method:\", method);\n    }\n\n    var collections = pipeline.toKeyedCollections();\n    return this.setCollection(collections[\"all\"], true);\n  }\n  /**\n   * Align event values to regular time boundaries. The value at\n   * the boundary is interpolated. Only the new interpolated\n   * points are returned. If limit is reached nulls will be\n   * returned at each boundary position.\n   *\n   * One use case for this is to modify irregular data (i.e. data\n   * that falls at slightly irregular times) so that it falls into a\n   * sequence of evenly spaced values. We use this to take data we\n   * get from the network which is approximately every 30 second\n   * (:32, 1:02, 1:34, ...) and output data on exact 30 second\n   * boundaries (:30, 1:00, 1:30, ...).\n   *\n   * Another use case is data that might be already aligned to\n   * some regular interval, but that contains missing points.\n   * While `fill()` can be used to replace `null` values, `align()`\n   * can be used to add in missing points completely. Those points\n   * can have an interpolated value, or by setting limit to 0,\n   * can be filled with nulls. This is really useful when downstream\n   * processing depends on complete sequences.\n   *\n   * @example\n   * ```\n   * const aligned = ts.align({\n   *     fieldSpec: \"value\",\n   *     period: \"1m\",\n   *     method: \"linear\"\n   * });\n   * ```\n   *\n   * @param                options                An object containing options:\n   * @param {string|array} options.fieldSpec      Column or columns to align. If you need to\n   *                                              retrieve multiple deep nested values\n   *                                              that ['can.be', 'done.with', 'this.notation'].\n   *                                              A single deep value with a string.like.this.\n   * @param {string}       options.period         Spacing of aligned values. e.g. \"6h\" or \"5m\"\n   * @param {string}       options.method         \"linear\" or \"pad\" style interpolation to boundaries.\n   * @param {number}       options.limit          The maximum number of points which should be\n   *                                              interpolated onto boundaries. You might set this to\n   *                                              2 if you are willing to interpolate 2 new points,\n   *                                              and then beyond that just emit nulls on the boundaries.\n   *\n   * @return {TimeSeries}     The resulting aligned TimeSeries\n   */\n\n\n  align(options) {\n    var {\n      fieldSpec = \"value\",\n      period = \"5m\",\n      method = \"linear\",\n      limit = null\n    } = options;\n    var collection = this.pipeline().align(fieldSpec, period, method, limit).toKeyedCollections();\n    return this.setCollection(collection[\"all\"], true);\n  }\n  /**\n   * Returns the derivative of the TimeSeries for the given columns. The result will\n   * be per second. Optionally you can substitute in `null` values if the rate\n   * is negative. This is useful when a negative rate would be considered invalid.\n   *\n   * @param                options                An object containing options:\n   * @param {string|array} options.fieldSpec      Column or columns to get the rate of. If you\n   *                                              need to retrieve multiple deep nested values\n   *                                              that ['can.be', 'done.with', 'this.notation'].\n   * @param {bool}         options.allowNegative  Will output null values for negative rates.\n   *                                              This is useful if you are getting the rate\n   *                                              of a counter that always goes up, except\n   *                                              when perhaps it rolls around or resets.\n   *\n   * @return {TimeSeries}                         The resulting `TimeSeries` containing calculated rates.\n   */\n\n\n  rate() {\n    var options = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : {};\n    var {\n      fieldSpec = \"value\",\n      allowNegative = true\n    } = options;\n    var collection = this.pipeline().rate(fieldSpec, allowNegative).toKeyedCollections();\n    return this.setCollection(collection[\"all\"], true);\n  }\n  /**\n   * Builds a new TimeSeries by dividing events within the TimeSeries\n   * across multiple fixed windows of size `windowSize`.\n   *\n   * Note that these are windows defined relative to Jan 1st, 1970,\n   * and are UTC, so this is best suited to smaller window sizes\n   * (hourly, 5m, 30s, 1s etc), or in situations where you don't care\n   * about the specific window, just that the data is smaller.\n   *\n   * Each window then has an aggregation specification applied as\n   * `aggregation`. This specification describes a mapping of output\n   * fieldNames to aggregation functions and their fieldPath. For example:\n   * ```\n   * { in_avg: { in: avg() }, out_avg: { out: avg() } }\n   * ```\n   * will aggregate both \"in\" and \"out\" using the average aggregation\n   * function and return the result as in_avg and out_avg.\n   *\n   * Note that each aggregation function, such as `avg()` also can take a\n   * filter function to apply before the aggregation. A set of filter functions\n   * exists to do common data cleanup such as removing bad values. For example:\n   * ```\n   * { value_avg: { value: avg(filter.ignoreMissing) } }\n   * ```\n   *\n   * @example\n   * ```\n   *     const timeseries = new TimeSeries(data);\n   *     const dailyAvg = timeseries.fixedWindowRollup({\n   *         windowSize: \"1d\",\n   *         aggregation: {value: {value: avg()}}\n   *     });\n   * ```\n   *\n   * @param                options                An object containing options:\n   * @param {string}       options.windowSize     The size of the window. e.g. \"6h\" or \"5m\"\n   * @param {object}       options.aggregation    The aggregation specification (see description above)\n   * @param {bool}         options.toTimeEvents   Output as `TimeEvent`s, rather than `IndexedEvent`s\n   * @return {TimeSeries}                         The resulting rolled up `TimeSeries`\n   */\n\n\n  fixedWindowRollup(options) {\n    var {\n      windowSize,\n      aggregation,\n      toTimeEvents = false\n    } = options;\n\n    if (!windowSize) {\n      throw new Error(\"windowSize must be supplied, for example '5m' for five minute rollups\");\n    }\n\n    if (!aggregation || !_underscore.default.isObject(aggregation)) {\n      throw new Error(\"aggregation object must be supplied, for example: {value: {value: avg()}}\");\n    }\n\n    var aggregatorPipeline = this.pipeline().windowBy(windowSize).emitOn(\"discard\").aggregate(aggregation);\n    var eventTypePipeline = toTimeEvents ? aggregatorPipeline.asTimeEvents() : aggregatorPipeline;\n    var collections = eventTypePipeline.clearWindow().toKeyedCollections();\n    return this.setCollection(collections[\"all\"], true);\n  }\n  /**\n   * Builds a new TimeSeries by dividing events into hours.\n   *\n   * Each window then has an aggregation specification `aggregation`\n   * applied. This specification describes a mapping of output\n   * fieldNames to aggregation functions and their fieldPath. For example:\n   * ```\n   * {in_avg: {in: avg()}, out_avg: {out: avg()}}\n   * ```\n   *\n   * @param                options                An object containing options:\n   * @param {bool}         options.toTimeEvents   Convert the rollup events to `TimeEvent`s, otherwise it\n   *                                              will be returned as a `TimeSeries` of `IndexedEvent`s.\n   * @param {object}       options.aggregation    The aggregation specification (see description above)\n   *\n   * @return {TimeSeries}     The resulting rolled up TimeSeries\n   */\n\n\n  hourlyRollup(options) {\n    var {\n      aggregation,\n      toTimeEvents = false\n    } = options;\n\n    if (!aggregation || !_underscore.default.isObject(aggregation)) {\n      throw new Error(\"aggregation object must be supplied, for example: {value: {value: avg()}}\");\n    }\n\n    return this.fixedWindowRollup(\"1h\", aggregation, toTimeEvents);\n  }\n  /**\n   * Builds a new TimeSeries by dividing events into days.\n   *\n   * Each window then has an aggregation specification `aggregation`\n   * applied. This specification describes a mapping of output\n   * fieldNames to aggregation functions and their fieldPath. For example:\n   * ```\n   * {in_avg: {in: avg()}, out_avg: {out: avg()}}\n   * ```\n   *\n   * @param                options                An object containing options:\n   * @param {bool}         options.toTimeEvents   Convert the rollup events to `TimeEvent`s, otherwise it\n   *                                              will be returned as a `TimeSeries` of `IndexedEvent`s.\n   * @param {object}       options.aggregation    The aggregation specification (see description above)\n   *\n   * @return {TimeSeries}     The resulting rolled up TimeSeries\n   */\n\n\n  dailyRollup(options) {\n    var {\n      aggregation,\n      toTimeEvents = false\n    } = options;\n\n    if (!aggregation || !_underscore.default.isObject(aggregation)) {\n      throw new Error(\"aggregation object must be supplied, for example: {value: {value: avg()}}\");\n    }\n\n    return this._rollup(\"daily\", aggregation, toTimeEvents);\n  }\n  /**\n   * Builds a new TimeSeries by dividing events into months.\n   *\n   * Each window then has an aggregation specification `aggregation`\n   * applied. This specification describes a mapping of output\n   * fieldNames to aggregation functions and their fieldPath. For example:\n   * ```\n   * {in_avg: {in: avg()}, out_avg: {out: avg()}}\n   * ```\n   *\n   * @param                options                An object containing options:\n   * @param {bool}         options.toTimeEvents   Convert the rollup events to `TimeEvent`s, otherwise it\n   *                                              will be returned as a `TimeSeries` of `IndexedEvent`s.\n   * @param {object}       options.aggregation    The aggregation specification (see description above)\n   *\n   * @return {TimeSeries}                         The resulting rolled up `TimeSeries`\n   */\n\n\n  monthlyRollup(options) {\n    var {\n      aggregation,\n      toTimeEvents = false\n    } = options;\n\n    if (!aggregation || !_underscore.default.isObject(aggregation)) {\n      throw new Error(\"aggregation object must be supplied, for example: {value: {value: avg()}}\");\n    }\n\n    return this._rollup(\"monthly\", aggregation, toTimeEvents);\n  }\n  /**\n   * Builds a new TimeSeries by dividing events into years.\n   *\n   * Each window then has an aggregation specification `aggregation`\n   * applied. This specification describes a mapping of output\n   * fieldNames to aggregation functions and their fieldPath. For example:\n   *\n   * ```\n   * {in_avg: {in: avg()}, out_avg: {out: avg()}}\n   * ```\n   *\n   * @param                options                An object containing options:\n   * @param {bool}         options.toTimeEvents   Convert the rollup events to `TimeEvent`s, otherwise it\n   *                                              will be returned as a `TimeSeries` of `IndexedEvent`s.\n   * @param {object}       options.aggregation    The aggregation specification (see description above)\n   *\n   * @return {TimeSeries}                         The resulting rolled up `TimeSeries`\n   */\n\n\n  yearlyRollup(options) {\n    var {\n      aggregation,\n      toTimeEvents = false\n    } = options;\n\n    if (!aggregation || !_underscore.default.isObject(aggregation)) {\n      throw new Error(\"aggregation object must be supplied, for example: {value: {value: avg()}}\");\n    }\n\n    return this._rollup(\"yearly\", aggregation, toTimeEvents);\n  }\n  /**\n   * @private\n   *\n   * Internal function to build the TimeSeries rollup functions using\n   * an aggregator Pipeline.\n   */\n\n\n  _rollup(type, aggregation) {\n    var toTimeEvents = arguments.length > 2 && arguments[2] !== undefined ? arguments[2] : false;\n    var aggregatorPipeline = this.pipeline().windowBy(type).emitOn(\"discard\").aggregate(aggregation);\n    var eventTypePipeline = toTimeEvents ? aggregatorPipeline.asTimeEvents() : aggregatorPipeline;\n    var collections = eventTypePipeline.clearWindow().toKeyedCollections();\n    return this.setCollection(collections[\"all\"], true);\n  }\n  /**\n   * Builds multiple `Collection`s, each collects together\n   * events within a window of size `windowSize`. Note that these\n   * are windows defined relative to Jan 1st, 1970, and are UTC.\n   *\n   * @example\n   * ```\n   * const timeseries = new TimeSeries(data);\n   * const collections = timeseries.collectByFixedWindow({windowSize: \"1d\"});\n   * console.log(collections); // {1d-16314: Collection, 1d-16315: Collection, ...}\n   * ```\n   *\n   * @param                options                An object containing options:\n   * @param {bool}         options.windowSize     The size of the window. e.g. \"6h\" or \"5m\"\n   *\n   * @return {map}    The result is a mapping from window index to a Collection.\n   */\n\n\n  collectByFixedWindow(_ref) {\n    var {\n      windowSize\n    } = _ref;\n    return this.pipeline().windowBy(windowSize).emitOn(\"discard\").toKeyedCollections();\n  }\n  /*\n   * STATIC\n   */\n\n  /**\n   * Defines the event type contained in this TimeSeries. The default here\n   * is to use the supplied type (time, timerange or index) to build either\n   * a TimeEvent, TimeRangeEvent or IndexedEvent. However, you can also\n   * subclass the TimeSeries and reimplement this to return another event\n   * type.\n   */\n\n\n  static event(eventKey) {\n    switch (eventKey) {\n      case \"time\":\n        return _timeevent.default;\n\n      case \"timerange\":\n        return _timerangeevent.default;\n\n      case \"index\":\n        return _indexedevent.default;\n\n      default:\n        throw new Error(\"Unknown event type: \".concat(eventKey));\n    }\n  }\n  /**\n   * Static function to compare two TimeSeries to each other. If the TimeSeries\n   * are of the same instance as each other then equals will return true.\n   * @param  {TimeSeries} series1\n   * @param  {TimeSeries} series2\n   * @return {bool} result\n   */\n\n\n  static equal(series1, series2) {\n    return series1._data === series2._data && series1._collection === series2._collection;\n  }\n  /**\n   * Static function to compare two TimeSeries to each other. If the TimeSeries\n   * are of the same value as each other then equals will return true.\n   * @param  {TimeSeries} series1\n   * @param  {TimeSeries} series2\n   * @return {bool} result\n   */\n\n\n  static is(series1, series2) {\n    return _immutable.default.is(series1._data, series2._data) && _collection.default.is(series1._collection, series2._collection);\n  }\n  /**\n   * Reduces a list of TimeSeries objects using a reducer function. This works\n   * by taking each event in each TimeSeries and collecting them together\n   * based on timestamp. All events for a given time are then merged together\n   * using the reducer function to produce a new event. The reducer function is\n   * applied to all columns in the fieldSpec. Those new events are then\n   * collected together to form a new TimeSeries.\n   *\n   * @example\n   *\n   * For example you might have three TimeSeries with columns \"in\" and \"out\" which\n   * corresponds to two measurements per timestamp. You could use this function to\n   * obtain a new TimeSeries which was the sum of the the three measurements using\n   * the `sum()` reducer function and an [\"in\", \"out\"] fieldSpec.\n   *\n   * ```\n   * const totalSeries = TimeSeries.timeSeriesListReduce({\n   *     name: \"totals\",\n   *     seriesList: [inTraffic, outTraffic],\n   *     reducer: sum(),\n   *     fieldSpec: [ \"in\", \"out\" ]\n   * });\n   * ```\n   *\n   * @param                  options                An object containing options. Additional key\n   *                                                values in the options will be added as meta data\n   *                                                to the resulting TimeSeries.\n   * @param {array}          options.seriesList     A list of `TimeSeries` (required)\n   * @param {function}       options.reducer        The reducer function e.g. `max()` (required)\n   * @param {array | string} options.fieldSpec      Column or columns to reduce. If you\n   *                                                need to retrieve multiple deep\n   *                                                nested values that ['can.be', 'done.with',\n   *                                                'this.notation']. A single deep value with a\n   *                                                string.like.this.\n   *\n   * @return {TimeSeries}                           The reduced TimeSeries\n   */\n\n\n  static timeSeriesListReduce(options) {\n    var {\n      fieldSpec,\n      reducer\n    } = options,\n        data = (0, _objectWithoutProperties2.default)(options, [\"fieldSpec\", \"reducer\"]);\n\n    var combiner = _event.default.combiner(fieldSpec, reducer);\n\n    return TimeSeries.timeSeriesListEventReduce(_objectSpread({\n      fieldSpec,\n      reducer: combiner\n    }, data));\n  }\n  /**\n   * Takes a list of TimeSeries and merges them together to form a new\n   * Timeseries.\n   *\n   * Merging will produce a new Event;\n  only when events are conflict free, so\n   * it is useful in the following cases:\n   *  * to combine multiple TimeSeries which have different time ranges, essentially\n   *  concatenating them together\n   *  * combine TimeSeries which have different columns, for example inTraffic has\n   *  a column \"in\" and outTraffic has a column \"out\" and you want to produce a merged\n   *  trafficSeries with columns \"in\" and \"out\".\n   *\n   * @example\n   * ```\n   * const inTraffic = new TimeSeries(trafficDataIn);\n   * const outTraffic = new TimeSeries(trafficDataOut);\n   * const trafficSeries = TimeSeries.timeSeriesListMerge({\n   *     name: \"traffic\",\n   *     seriesList: [inTraffic, outTraffic]\n   * });\n   * ```\n   *\n   * @param                  options                An object containing options. Additional key\n   *                                                values in the options will be added as meta data\n   *                                                to the resulting TimeSeries.\n   * @param {array}          options.seriesList     A list of `TimeSeries` (required)\n   * @param {array | string} options.fieldSpec      Column or columns to merge. If you\n   *                                                need to retrieve multiple deep\n   *                                                nested values that ['can.be', 'done.with',\n   *                                                'this.notation']. A single deep value with a\n   *                                                string.like.this.\n   *\n   * @return {TimeSeries}                           The merged TimeSeries\n   */\n\n\n  static timeSeriesListMerge(options) {\n    var {\n      fieldSpec\n    } = options,\n        data = (0, _objectWithoutProperties2.default)(options, [\"fieldSpec\"]);\n\n    var merger = _event.default.merger(fieldSpec);\n\n    return TimeSeries.timeSeriesListEventReduce(_objectSpread({\n      fieldSpec,\n      reducer: merger\n    }, data));\n  }\n  /**\n   * @private\n   */\n\n\n  static timeSeriesListEventReduce(options) {\n    var {\n      seriesList,\n      fieldSpec,\n      reducer\n    } = options,\n        data = (0, _objectWithoutProperties2.default)(options, [\"seriesList\", \"fieldSpec\", \"reducer\"]);\n\n    if (!seriesList || !_underscore.default.isArray(seriesList)) {\n      throw new Error(\"A list of TimeSeries must be supplied to reduce\");\n    }\n\n    if (!reducer || !_underscore.default.isFunction(reducer)) {\n      throw new Error(\"reducer function must be supplied, for example avg()\");\n    } // for each series, make a map from timestamp to the\n    // list of events with that timestamp\n\n\n    var eventList = [];\n    seriesList.forEach(series => {\n      for (var event of series.events()) {\n        eventList.push(event);\n      }\n    });\n    var events = reducer(eventList, fieldSpec); // Make a collection. If the events are out of order, sort them.\n    // It's always possible that events are out of order here, depending\n    // on the start times of the series, along with it the series\n    // have missing data, so I think we don't have a choice here.\n\n    var collection = new _collection.default(events);\n\n    if (!collection.isChronological()) {\n      collection = collection.sortByTime();\n    }\n\n    var timeseries = new TimeSeries(_objectSpread({}, data, {\n      collection\n    }));\n    return timeseries;\n  }\n\n}\n\nvar _default = TimeSeries;\nexports.default = _default;"]},"metadata":{},"sourceType":"script"}