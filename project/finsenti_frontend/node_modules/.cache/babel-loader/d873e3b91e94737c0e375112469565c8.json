{"ast":null,"code":"/*! Moment Duration Format v1.3.0\n *  https://github.com/jsmreese/moment-duration-format \n *  Date: 2014-07-15\n *\n *  Duration format plugin function for the Moment.js library\n *  http://momentjs.com/\n *\n *  Copyright 2014 John Madhavan-Reese\n *  Released under the MIT license\n */\n(function (root, undefined) {\n  // repeatZero(qty)\n  // returns \"0\" repeated qty times\n  function repeatZero(qty) {\n    var result = \"\"; // exit early\n    // if qty is 0 or a negative number\n    // or doesn't coerce to an integer\n\n    qty = parseInt(qty, 10);\n\n    if (!qty || qty < 1) {\n      return result;\n    }\n\n    while (qty) {\n      result += \"0\";\n      qty -= 1;\n    }\n\n    return result;\n  } // padZero(str, len [, isRight])\n  // pads a string with zeros up to a specified length\n  // will not pad a string if its length is aready\n  // greater than or equal to the specified length\n  // default output pads with zeros on the left\n  // set isRight to `true` to pad with zeros on the right\n\n\n  function padZero(str, len, isRight) {\n    if (str == null) {\n      str = \"\";\n    }\n\n    str = \"\" + str;\n    return (isRight ? str : \"\") + repeatZero(len - str.length) + (isRight ? \"\" : str);\n  } // isArray\n\n\n  function isArray(array) {\n    return Object.prototype.toString.call(array) === \"[object Array]\";\n  } // isObject\n\n\n  function isObject(obj) {\n    return Object.prototype.toString.call(obj) === \"[object Object]\";\n  } // findLast\n\n\n  function findLast(array, callback) {\n    var index = array.length;\n\n    while (index -= 1) {\n      if (callback(array[index])) {\n        return array[index];\n      }\n    }\n  } // find\n\n\n  function find(array, callback) {\n    var index = 0,\n        max = array.length,\n        match;\n\n    if (typeof callback !== \"function\") {\n      match = callback;\n\n      callback = function (item) {\n        return item === match;\n      };\n    }\n\n    while (index < max) {\n      if (callback(array[index])) {\n        return array[index];\n      }\n\n      index += 1;\n    }\n  } // each\n\n\n  function each(array, callback) {\n    var index = 0,\n        max = array.length;\n\n    if (!array || !max) {\n      return;\n    }\n\n    while (index < max) {\n      if (callback(array[index], index) === false) {\n        return;\n      }\n\n      index += 1;\n    }\n  } // map\n\n\n  function map(array, callback) {\n    var index = 0,\n        max = array.length,\n        ret = [];\n\n    if (!array || !max) {\n      return ret;\n    }\n\n    while (index < max) {\n      ret[index] = callback(array[index], index);\n      index += 1;\n    }\n\n    return ret;\n  } // pluck\n\n\n  function pluck(array, prop) {\n    return map(array, function (item) {\n      return item[prop];\n    });\n  } // compact\n\n\n  function compact(array) {\n    var ret = [];\n    each(array, function (item) {\n      if (item) {\n        ret.push(item);\n      }\n    });\n    return ret;\n  } // unique\n\n\n  function unique(array) {\n    var ret = [];\n    each(array, function (_a) {\n      if (!find(ret, _a)) {\n        ret.push(_a);\n      }\n    });\n    return ret;\n  } // intersection\n\n\n  function intersection(a, b) {\n    var ret = [];\n    each(a, function (_a) {\n      each(b, function (_b) {\n        if (_a === _b) {\n          ret.push(_a);\n        }\n      });\n    });\n    return unique(ret);\n  } // rest\n\n\n  function rest(array, callback) {\n    var ret = [];\n    each(array, function (item, index) {\n      if (!callback(item)) {\n        ret = array.slice(index);\n        return false;\n      }\n    });\n    return ret;\n  } // initial\n\n\n  function initial(array, callback) {\n    var reversed = array.slice().reverse();\n    return rest(reversed, callback).reverse();\n  } // extend\n\n\n  function extend(a, b) {\n    for (var key in b) {\n      if (b.hasOwnProperty(key)) {\n        a[key] = b[key];\n      }\n    }\n\n    return a;\n  } // define internal moment reference\n\n\n  var moment;\n\n  if (typeof require === \"function\") {\n    try {\n      moment = require('moment');\n    } catch (e) {}\n  }\n\n  if (!moment && root.moment) {\n    moment = root.moment;\n  }\n\n  if (!moment) {\n    throw \"Moment Duration Format cannot find Moment.js\";\n  } // moment.duration.format([template] [, precision] [, settings])\n\n\n  moment.duration.fn.format = function () {\n    var tokenizer,\n        tokens,\n        types,\n        typeMap,\n        momentTypes,\n        foundFirst,\n        trimIndex,\n        args = [].slice.call(arguments),\n        settings = extend({}, this.format.defaults),\n        // keep a shadow copy of this moment for calculating remainders\n    remainder = moment.duration(this); // add a reference to this duration object to the settings for use\n    // in a template function\n\n    settings.duration = this; // parse arguments\n\n    each(args, function (arg) {\n      if (typeof arg === \"string\" || typeof arg === \"function\") {\n        settings.template = arg;\n        return;\n      }\n\n      if (typeof arg === \"number\") {\n        settings.precision = arg;\n        return;\n      }\n\n      if (isObject(arg)) {\n        extend(settings, arg);\n      }\n    }); // types\n\n    types = settings.types = isArray(settings.types) ? settings.types : settings.types.split(\" \"); // template\n\n    if (typeof settings.template === \"function\") {\n      settings.template = settings.template.apply(settings);\n    } // tokenizer regexp\n\n\n    tokenizer = new RegExp(map(types, function (type) {\n      return settings[type].source;\n    }).join(\"|\"), \"g\"); // token type map function\n\n    typeMap = function (token) {\n      return find(types, function (type) {\n        return settings[type].test(token);\n      });\n    }; // tokens array\n\n\n    tokens = map(settings.template.match(tokenizer), function (token, index) {\n      var type = typeMap(token),\n          length = token.length;\n      return {\n        index: index,\n        length: length,\n        // replace escaped tokens with the non-escaped token text\n        token: type === \"escape\" ? token.replace(settings.escape, \"$1\") : token,\n        // ignore type on non-moment tokens\n        type: type === \"escape\" || type === \"general\" ? null : type // calculate base value for all moment tokens\n        //baseValue: ((type === \"escape\" || type === \"general\") ? null : this.as(type))\n\n      };\n    }, this); // unique moment token types in the template (in order of descending magnitude)\n\n    momentTypes = intersection(types, unique(compact(pluck(tokens, \"type\")))); // exit early if there are no momentTypes\n\n    if (!momentTypes.length) {\n      return pluck(tokens, \"token\").join(\"\");\n    } // calculate values for each token type in the template\n\n\n    each(momentTypes, function (momentType, index) {\n      var value, wholeValue, decimalValue, isLeast, isMost; // calculate integer and decimal value portions\n\n      value = remainder.as(momentType);\n      wholeValue = value > 0 ? Math.floor(value) : Math.ceil(value);\n      decimalValue = value - wholeValue; // is this the least-significant moment token found?\n\n      isLeast = index + 1 === momentTypes.length; // is this the most-significant moment token found?\n\n      isMost = !index; // update tokens array\n      // using this algorithm to not assume anything about\n      // the order or frequency of any tokens\n\n      each(tokens, function (token) {\n        if (token.type === momentType) {\n          extend(token, {\n            value: value,\n            wholeValue: wholeValue,\n            decimalValue: decimalValue,\n            isLeast: isLeast,\n            isMost: isMost\n          });\n\n          if (isMost) {\n            // note the length of the most-significant moment token:\n            // if it is greater than one and forceLength is not set, default forceLength to `true`\n            if (settings.forceLength == null && token.length > 1) {\n              settings.forceLength = true;\n            } // rationale is this:\n            // if the template is \"h:mm:ss\" and the moment value is 5 minutes, the user-friendly output is \"5:00\", not \"05:00\"\n            // shouldn't pad the `minutes` token even though it has length of two\n            // if the template is \"hh:mm:ss\", the user clearly wanted everything padded so we should output \"05:00\"\n            // if the user wanted the full padded output, they can set `{ trim: false }` to get \"00:05:00\"\n\n          }\n        }\n      }); // update remainder\n\n      remainder.subtract(wholeValue, momentType);\n    }); // trim tokens array\n\n    if (settings.trim) {\n      tokens = (settings.trim === \"left\" ? rest : initial)(tokens, function (token) {\n        // return `true` if:\n        // the token is not the least moment token (don't trim the least moment token)\n        // the token is a moment token that does not have a value (don't trim moment tokens that have a whole value)\n        return !(token.isLeast || token.type != null && token.wholeValue);\n      });\n    } // build output\n    // the first moment token can have special handling\n\n\n    foundFirst = false; // run the map in reverse order if trimming from the right\n\n    if (settings.trim === \"right\") {\n      tokens.reverse();\n    }\n\n    tokens = map(tokens, function (token) {\n      var val, decVal;\n\n      if (!token.type) {\n        // if it is not a moment token, use the token as its own value\n        return token.token;\n      } // apply negative precision formatting to the least-significant moment token\n\n\n      if (token.isLeast && settings.precision < 0) {\n        val = (Math.floor(token.wholeValue * Math.pow(10, settings.precision)) * Math.pow(10, -settings.precision)).toString();\n      } else {\n        val = token.wholeValue.toString();\n      } // remove negative sign from the beginning\n\n\n      val = val.replace(/^\\-/, \"\"); // apply token length formatting\n      // special handling for the first moment token that is not the most significant in a trimmed template\n\n      if (token.length > 1 && (foundFirst || token.isMost || settings.forceLength)) {\n        val = padZero(val, token.length);\n      } // add decimal value if precision > 0\n\n\n      if (token.isLeast && settings.precision > 0) {\n        decVal = token.decimalValue.toString().replace(/^\\-/, \"\").split(/\\.|e\\-/);\n\n        switch (decVal.length) {\n          case 1:\n            val += \".\" + padZero(decVal[0], settings.precision, true).slice(0, settings.precision);\n            break;\n\n          case 2:\n            val += \".\" + padZero(decVal[1], settings.precision, true).slice(0, settings.precision);\n            break;\n\n          case 3:\n            val += \".\" + padZero(repeatZero(+decVal[2] - 1) + (decVal[0] || \"0\") + decVal[1], settings.precision, true).slice(0, settings.precision);\n            break;\n\n          default:\n            throw \"Moment Duration Format: unable to parse token decimal value.\";\n        }\n      } // add a negative sign if the value is negative and token is most significant\n\n\n      if (token.isMost && token.value < 0) {\n        val = \"-\" + val;\n      }\n\n      foundFirst = true;\n      return val;\n    }); // undo the reverse if trimming from the right\n\n    if (settings.trim === \"right\") {\n      tokens.reverse();\n    }\n\n    return tokens.join(\"\");\n  };\n\n  moment.duration.fn.format.defaults = {\n    // token definitions\n    escape: /\\[(.+?)\\]/,\n    years: /[Yy]+/,\n    months: /M+/,\n    weeks: /[Ww]+/,\n    days: /[Dd]+/,\n    hours: /[Hh]+/,\n    minutes: /m+/,\n    seconds: /s+/,\n    milliseconds: /S+/,\n    general: /.+?/,\n    // token type names\n    // in order of descending magnitude\n    // can be a space-separated token name list or an array of token names\n    types: \"escape years months weeks days hours minutes seconds milliseconds general\",\n    // format options\n    // trim\n    // \"left\" - template tokens are trimmed from the left until the first moment token that has a value >= 1\n    // \"right\" - template tokens are trimmed from the right until the first moment token that has a value >= 1\n    // (the final moment token is not trimmed, regardless of value)\n    // `false` - template tokens are not trimmed\n    trim: \"left\",\n    // precision\n    // number of decimal digits to include after (to the right of) the decimal point (positive integer)\n    // or the number of digits to truncate to 0 before (to the left of) the decimal point (negative integer)\n    precision: 0,\n    // force first moment token with a value to render at full length even when template is trimmed and first moment token has length of 1\n    forceLength: null,\n    // template used to format duration\n    // may be a function or a string\n    // template functions are executed with the `this` binding of the settings object\n    // so that template strings may be dynamically generated based on the duration object\n    // (accessible via `this.duration`)\n    // or any of the other settings\n    template: function () {\n      var types = this.types,\n          dur = this.duration,\n          lastType = findLast(types, function (type) {\n        return dur._data[type];\n      }); // default template strings for each duration dimension type\n\n      switch (lastType) {\n        case \"seconds\":\n          return \"h:mm:ss\";\n\n        case \"minutes\":\n          return \"d[d] h:mm\";\n\n        case \"hours\":\n          return \"d[d] h[h]\";\n\n        case \"days\":\n          return \"M[m] d[d]\";\n\n        case \"weeks\":\n          return \"y[y] w[w]\";\n\n        case \"months\":\n          return \"y[y] M[m]\";\n\n        case \"years\":\n          return \"y[y]\";\n\n        default:\n          return \"y[y] M[m] d[d] h:mm:ss\";\n      }\n    }\n  };\n})(this);","map":{"version":3,"sources":["/Users/nicholasraffone/Documents/swefall2021/finalproj/FinancialSentiment/fin_sentiment_front/node_modules/moment-duration-format/lib/moment-duration-format.js"],"names":["root","undefined","repeatZero","qty","result","parseInt","padZero","str","len","isRight","length","isArray","array","Object","prototype","toString","call","isObject","obj","findLast","callback","index","find","max","match","item","each","map","ret","pluck","prop","compact","push","unique","_a","intersection","a","b","_b","rest","slice","initial","reversed","reverse","extend","key","hasOwnProperty","moment","require","e","duration","fn","format","tokenizer","tokens","types","typeMap","momentTypes","foundFirst","trimIndex","args","arguments","settings","defaults","remainder","arg","template","precision","split","apply","RegExp","type","source","join","token","test","replace","escape","momentType","value","wholeValue","decimalValue","isLeast","isMost","as","Math","floor","ceil","forceLength","subtract","trim","val","decVal","pow","years","months","weeks","days","hours","minutes","seconds","milliseconds","general","dur","lastType","_data"],"mappings":"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","sourcesContent":["/*! Moment Duration Format v1.3.0\n *  https://github.com/jsmreese/moment-duration-format \n *  Date: 2014-07-15\n *\n *  Duration format plugin function for the Moment.js library\n *  http://momentjs.com/\n *\n *  Copyright 2014 John Madhavan-Reese\n *  Released under the MIT license\n */\n\n(function (root, undefined) {\n\n\t// repeatZero(qty)\n\t// returns \"0\" repeated qty times\n\tfunction repeatZero(qty) {\n\t\tvar result = \"\";\n\t\t\n\t\t// exit early\n\t\t// if qty is 0 or a negative number\n\t\t// or doesn't coerce to an integer\n\t\tqty = parseInt(qty, 10);\n\t\tif (!qty || qty < 1) { return result; }\n\t\t\n\t\twhile (qty) {\n\t\t\tresult += \"0\";\n\t\t\tqty -= 1;\n\t\t}\n\t\t\n\t\treturn result;\n\t}\n\t\n\t// padZero(str, len [, isRight])\n\t// pads a string with zeros up to a specified length\n\t// will not pad a string if its length is aready\n\t// greater than or equal to the specified length\n\t// default output pads with zeros on the left\n\t// set isRight to `true` to pad with zeros on the right\n\tfunction padZero(str, len, isRight) {\n\t\tif (str == null) { str = \"\"; }\n\t\tstr = \"\" + str;\n\t\t\n\t\treturn (isRight ? str : \"\") + repeatZero(len - str.length) + (isRight ? \"\" : str);\n\t}\n\t\n\t// isArray\n\tfunction isArray(array) {\n\t\treturn Object.prototype.toString.call(array) === \"[object Array]\";\n\t}\n\t\n\t// isObject\n\tfunction isObject(obj) {\n\t\treturn Object.prototype.toString.call(obj) === \"[object Object]\";\n\t}\n\t\n\t// findLast\n\tfunction findLast(array, callback) {\n\t\tvar index = array.length;\n\n\t\twhile (index -= 1) {\n\t\t\tif (callback(array[index])) { return array[index]; }\n\t\t}\n\t}\n\n\t// find\n\tfunction find(array, callback) {\n\t\tvar index = 0,\n\t\t\tmax = array.length,\n\t\t\tmatch;\n\t\t\t\n\t\tif (typeof callback !== \"function\") {\n\t\t\tmatch = callback;\n\t\t\tcallback = function (item) {\n\t\t\t\treturn item === match;\n\t\t\t};\n\t\t}\n\n\t\twhile (index < max) {\n\t\t\tif (callback(array[index])) { return array[index]; }\n\t\t\tindex += 1;\n\t\t}\n\t}\n\t\n\t// each\n\tfunction each(array, callback) {\n\t\tvar index = 0,\n\t\t\tmax = array.length;\n\t\t\t\n\t\tif (!array || !max) { return; }\n\n\t\twhile (index < max) {\n\t\t\tif (callback(array[index], index) === false) { return; }\n\t\t\tindex += 1;\n\t\t}\n\t}\n\t\n\t// map\n\tfunction map(array, callback) {\n\t\tvar index = 0,\n\t\t\tmax = array.length,\n\t\t\tret = [];\n\n\t\tif (!array || !max) { return ret; }\n\t\t\t\t\n\t\twhile (index < max) {\n\t\t\tret[index] = callback(array[index], index);\n\t\t\tindex += 1;\n\t\t}\n\t\t\n\t\treturn ret;\n\t}\n\t\n\t// pluck\n\tfunction pluck(array, prop) {\n\t\treturn map(array, function (item) {\n\t\t\treturn item[prop];\n\t\t});\n\t}\n\t\n\t// compact\n\tfunction compact(array) {\n\t\tvar ret = [];\n\t\t\n\t\teach(array, function (item) {\n\t\t\tif (item) { ret.push(item); }\n\t\t});\n\t\t\n\t\treturn ret;\n\t}\n\t\n\t// unique\n\tfunction unique(array) {\n\t\tvar ret = [];\n\t\t\n\t\teach(array, function (_a) {\n\t\t\tif (!find(ret, _a)) { ret.push(_a); }\n\t\t});\n\t\t\n\t\treturn ret;\n\t}\n\t\n\t// intersection\n\tfunction intersection(a, b) {\n\t\tvar ret = [];\n\t\t\n\t\teach(a, function (_a) {\n\t\t\teach(b, function (_b) {\n\t\t\t\tif (_a === _b) { ret.push(_a); }\n\t\t\t});\n\t\t});\n\t\t\n\t\treturn unique(ret);\n\t}\n\t\n\t// rest\n\tfunction rest(array, callback) {\n\t\tvar ret = [];\n\t\t\n\t\teach(array, function (item, index) {\n\t\t\tif (!callback(item)) {\n\t\t\t\tret = array.slice(index);\n\t\t\t\treturn false;\n\t\t\t}\n\t\t});\n\t\t\n\t\treturn ret;\n\t}\n\n\t// initial\n\tfunction initial(array, callback) {\n\t\tvar reversed = array.slice().reverse();\n\t\t\n\t\treturn rest(reversed, callback).reverse();\n\t}\n\t\n\t// extend\n\tfunction extend(a, b) {\n\t\tfor (var key in b) {\n\t\t\tif (b.hasOwnProperty(key)) { a[key] = b[key]; }\n\t\t}\n\t\t\n\t\treturn a;\n\t}\n\t\t\t\n\t// define internal moment reference\n\tvar moment;\n\n\tif (typeof require === \"function\") {\n\t\ttry { moment = require('moment'); } \n\t\tcatch (e) {}\n\t} \n\t\n\tif (!moment && root.moment) {\n\t\tmoment = root.moment;\n\t}\n\t\n\tif (!moment) {\n\t\tthrow \"Moment Duration Format cannot find Moment.js\";\n\t}\n\t\n\t// moment.duration.format([template] [, precision] [, settings])\n\tmoment.duration.fn.format = function () {\n\n\t\tvar tokenizer, tokens, types, typeMap, momentTypes, foundFirst, trimIndex,\n\t\t\targs = [].slice.call(arguments),\n\t\t\tsettings = extend({}, this.format.defaults),\n\t\t\t// keep a shadow copy of this moment for calculating remainders\n\t\t\tremainder = moment.duration(this);\n\n\t\t// add a reference to this duration object to the settings for use\n\t\t// in a template function\n\t\tsettings.duration = this;\n\n\t\t// parse arguments\n\t\teach(args, function (arg) {\n\t\t\tif (typeof arg === \"string\" || typeof arg === \"function\") {\n\t\t\t\tsettings.template = arg;\n\t\t\t\treturn;\n\t\t\t}\n\n\t\t\tif (typeof arg === \"number\") {\n\t\t\t\tsettings.precision = arg;\n\t\t\t\treturn;\n\t\t\t}\n\n\t\t\tif (isObject(arg)) {\n\t\t\t\textend(settings, arg);\n\t\t\t}\n\t\t});\n\n\t\t// types\n\t\ttypes = settings.types = (isArray(settings.types) ? settings.types : settings.types.split(\" \"));\n\n\t\t// template\n\t\tif (typeof settings.template === \"function\") {\n\t\t\tsettings.template = settings.template.apply(settings);\n\t\t}\n\n\t\t// tokenizer regexp\n\t\ttokenizer = new RegExp(map(types, function (type) {\n\t\t\treturn settings[type].source;\n\t\t}).join(\"|\"), \"g\");\n\n\t\t// token type map function\n\t\ttypeMap = function (token) {\n\t\t\treturn find(types, function (type) {\n\t\t\t\treturn settings[type].test(token);\n\t\t\t});\n\t\t};\n\n\t\t// tokens array\n\t\ttokens = map(settings.template.match(tokenizer), function (token, index) {\n\t\t\tvar type = typeMap(token),\n\t\t\t\tlength = token.length;\n\n\t\t\treturn {\n\t\t\t\tindex: index,\n\t\t\t\tlength: length,\n\n\t\t\t\t// replace escaped tokens with the non-escaped token text\n\t\t\t\ttoken: (type === \"escape\" ? token.replace(settings.escape, \"$1\") : token),\n\n\t\t\t\t// ignore type on non-moment tokens\n\t\t\t\ttype: ((type === \"escape\" || type === \"general\") ? null : type)\n\n\t\t\t\t// calculate base value for all moment tokens\n\t\t\t\t//baseValue: ((type === \"escape\" || type === \"general\") ? null : this.as(type))\n\t\t\t};\n\t\t}, this);\n\n\t\t// unique moment token types in the template (in order of descending magnitude)\n\t\tmomentTypes = intersection(types, unique(compact(pluck(tokens, \"type\"))));\n\n\t\t// exit early if there are no momentTypes\n\t\tif (!momentTypes.length) {\n\t\t\treturn pluck(tokens, \"token\").join(\"\");\n\t\t}\n\n\t\t// calculate values for each token type in the template\n\t\teach(momentTypes, function (momentType, index) {\n\t\t\tvar value, wholeValue, decimalValue, isLeast, isMost;\n\n\t\t\t// calculate integer and decimal value portions\n\t\t\tvalue = remainder.as(momentType);\n\t\t\twholeValue = (value > 0 ? Math.floor(value) : Math.ceil(value));\n\t\t\tdecimalValue = value - wholeValue;\n\n\t\t\t// is this the least-significant moment token found?\n\t\t\tisLeast = ((index + 1) === momentTypes.length);\n\n\t\t\t// is this the most-significant moment token found?\n\t\t\tisMost = (!index);\n\n\t\t\t// update tokens array\n\t\t\t// using this algorithm to not assume anything about\n\t\t\t// the order or frequency of any tokens\n\t\t\teach(tokens, function (token) {\n\t\t\t\tif (token.type === momentType) {\n\t\t\t\t\textend(token, {\n\t\t\t\t\t\tvalue: value,\n\t\t\t\t\t\twholeValue: wholeValue,\n\t\t\t\t\t\tdecimalValue: decimalValue,\n\t\t\t\t\t\tisLeast: isLeast,\n\t\t\t\t\t\tisMost: isMost\n\t\t\t\t\t});\n\n\t\t\t\t\tif (isMost) {\n\t\t\t\t\t\t// note the length of the most-significant moment token:\n\t\t\t\t\t\t// if it is greater than one and forceLength is not set, default forceLength to `true`\n\t\t\t\t\t\tif (settings.forceLength == null && token.length > 1) {\n\t\t\t\t\t\t\tsettings.forceLength = true;\n\t\t\t\t\t\t}\n\n\t\t\t\t\t\t// rationale is this:\n\t\t\t\t\t\t// if the template is \"h:mm:ss\" and the moment value is 5 minutes, the user-friendly output is \"5:00\", not \"05:00\"\n\t\t\t\t\t\t// shouldn't pad the `minutes` token even though it has length of two\n\t\t\t\t\t\t// if the template is \"hh:mm:ss\", the user clearly wanted everything padded so we should output \"05:00\"\n\t\t\t\t\t\t// if the user wanted the full padded output, they can set `{ trim: false }` to get \"00:05:00\"\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t});\n\n\t\t\t// update remainder\n\t\t\tremainder.subtract(wholeValue, momentType);\n\t\t});\n\t\n\t\t// trim tokens array\n\t\tif (settings.trim) {\n\t\t\ttokens = (settings.trim === \"left\" ? rest : initial)(tokens, function (token) {\n\t\t\t\t// return `true` if:\n\t\t\t\t// the token is not the least moment token (don't trim the least moment token)\n\t\t\t\t// the token is a moment token that does not have a value (don't trim moment tokens that have a whole value)\n\t\t\t\treturn !(token.isLeast || (token.type != null && token.wholeValue));\n\t\t\t});\n\t\t}\n\t\t\n\t\t\n\t\t// build output\n\n\t\t// the first moment token can have special handling\n\t\tfoundFirst = false;\n\n\t\t// run the map in reverse order if trimming from the right\n\t\tif (settings.trim === \"right\") {\n\t\t\ttokens.reverse();\n\t\t}\n\n\t\ttokens = map(tokens, function (token) {\n\t\t\tvar val,\n\t\t\t\tdecVal;\n\n\t\t\tif (!token.type) {\n\t\t\t\t// if it is not a moment token, use the token as its own value\n\t\t\t\treturn token.token;\n\t\t\t}\n\n\t\t\t// apply negative precision formatting to the least-significant moment token\n\t\t\tif (token.isLeast && (settings.precision < 0)) {\n\t\t\t\tval = (Math.floor(token.wholeValue * Math.pow(10, settings.precision)) * Math.pow(10, -settings.precision)).toString();\n\t\t\t} else {\n\t\t\t\tval = token.wholeValue.toString();\n\t\t\t}\n\t\t\t\n\t\t\t// remove negative sign from the beginning\n\t\t\tval = val.replace(/^\\-/, \"\");\n\n\t\t\t// apply token length formatting\n\t\t\t// special handling for the first moment token that is not the most significant in a trimmed template\n\t\t\tif (token.length > 1 && (foundFirst || token.isMost || settings.forceLength)) {\n\t\t\t\tval = padZero(val, token.length);\n\t\t\t}\n\n\t\t\t// add decimal value if precision > 0\n\t\t\tif (token.isLeast && (settings.precision > 0)) {\n\t\t\t\tdecVal = token.decimalValue.toString().replace(/^\\-/, \"\").split(/\\.|e\\-/);\n\t\t\t\tswitch (decVal.length) {\n\t\t\t\t\tcase 1:\n\t\t\t\t\t\tval += \".\" + padZero(decVal[0], settings.precision, true).slice(0, settings.precision);\n\t\t\t\t\t\tbreak;\n\t\t\t\t\t\t\n\t\t\t\t\tcase 2:\n\t\t\t\t\t\tval += \".\" + padZero(decVal[1], settings.precision, true).slice(0, settings.precision);\t\t\n\t\t\t\t\t\tbreak;\n\t\t\t\t\t\t\n\t\t\t\t\tcase 3:\n\t\t\t\t\t\tval += \".\" + padZero(repeatZero((+decVal[2]) - 1) + (decVal[0] || \"0\") + decVal[1], settings.precision, true).slice(0, settings.precision);\t\t\n\t\t\t\t\t\tbreak;\n\t\t\t\t\t\n\t\t\t\t\tdefault:\n\t\t\t\t\t\tthrow \"Moment Duration Format: unable to parse token decimal value.\";\n\t\t\t\t}\n\t\t\t}\n\t\t\t\n\t\t\t// add a negative sign if the value is negative and token is most significant\n\t\t\tif (token.isMost && token.value < 0) {\n\t\t\t\tval = \"-\" + val;\n\t\t\t}\n\n\t\t\tfoundFirst = true;\n\n\t\t\treturn val;\n\t\t});\n\n\t\t// undo the reverse if trimming from the right\n\t\tif (settings.trim === \"right\") {\n\t\t\ttokens.reverse();\n\t\t}\n\n\t\treturn tokens.join(\"\");\n\t};\n\n\tmoment.duration.fn.format.defaults = {\n\t\t// token definitions\n\t\tescape: /\\[(.+?)\\]/,\n\t\tyears: /[Yy]+/,\n\t\tmonths: /M+/,\n\t\tweeks: /[Ww]+/,\n\t\tdays: /[Dd]+/,\n\t\thours: /[Hh]+/,\n\t\tminutes: /m+/,\n\t\tseconds: /s+/,\n\t\tmilliseconds: /S+/,\n\t\tgeneral: /.+?/,\n\n\t\t// token type names\n\t\t// in order of descending magnitude\n\t\t// can be a space-separated token name list or an array of token names\n\t\ttypes: \"escape years months weeks days hours minutes seconds milliseconds general\",\n\n\t\t// format options\n\n\t\t// trim\n\t\t// \"left\" - template tokens are trimmed from the left until the first moment token that has a value >= 1\n\t\t// \"right\" - template tokens are trimmed from the right until the first moment token that has a value >= 1\n\t\t// (the final moment token is not trimmed, regardless of value)\n\t\t// `false` - template tokens are not trimmed\n\t\ttrim: \"left\",\n\n\t\t// precision\n\t\t// number of decimal digits to include after (to the right of) the decimal point (positive integer)\n\t\t// or the number of digits to truncate to 0 before (to the left of) the decimal point (negative integer)\n\t\tprecision: 0,\n\n\t\t// force first moment token with a value to render at full length even when template is trimmed and first moment token has length of 1\n\t\tforceLength: null,\n\n\t\t// template used to format duration\n\t\t// may be a function or a string\n\t\t// template functions are executed with the `this` binding of the settings object\n\t\t// so that template strings may be dynamically generated based on the duration object\n\t\t// (accessible via `this.duration`)\n\t\t// or any of the other settings\n\t\ttemplate: function () {\n\t\t\tvar types = this.types,\n\t\t\t\tdur = this.duration,\n\t\t\t\tlastType = findLast(types, function (type) {\n\t\t\t\t\treturn dur._data[type];\n\t\t\t\t});\n\n\t\t\t// default template strings for each duration dimension type\n\t\t\tswitch (lastType) {\n\t\t\t\tcase \"seconds\":\n\t\t\t\t\treturn \"h:mm:ss\";\n\t\t\t\tcase \"minutes\":\n\t\t\t\t\treturn \"d[d] h:mm\";\n\t\t\t\tcase \"hours\":\n\t\t\t\t\treturn \"d[d] h[h]\";\n\t\t\t\tcase \"days\":\n\t\t\t\t\treturn \"M[m] d[d]\";\n\t\t\t\tcase \"weeks\":\n\t\t\t\t\treturn \"y[y] w[w]\";\n\t\t\t\tcase \"months\":\n\t\t\t\t\treturn \"y[y] M[m]\";\n\t\t\t\tcase \"years\":\n\t\t\t\t\treturn \"y[y]\";\n\t\t\t\tdefault:\n\t\t\t\t\treturn \"y[y] M[m] d[d] h:mm:ss\";\n\t\t\t}\n\t\t}\n\t};\n\n})(this);\n"]},"metadata":{},"sourceType":"script"}