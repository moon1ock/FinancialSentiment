{"ast":null,"code":"\"use strict\";\n\nvar _interopRequireDefault = require(\"@babel/runtime/helpers/interopRequireDefault\");\n\nObject.defineProperty(exports, \"__esModule\", {\n  value: true\n});\nexports.default = void 0;\n\nvar _underscore = _interopRequireDefault(require(\"underscore\"));\n\nvar _immutable = _interopRequireDefault(require(\"immutable\"));\n\nvar _index = _interopRequireDefault(require(\"../index\"));\n\nvar _indexedevent = _interopRequireDefault(require(\"../indexedevent\"));\n\nvar _processor = _interopRequireDefault(require(\"./processor\"));\n\nvar _timeevent = _interopRequireDefault(require(\"../timeevent\"));\n\nvar _timerange = _interopRequireDefault(require(\"../timerange\"));\n\nvar _timerangeevent = _interopRequireDefault(require(\"../timerangeevent\"));\n\nvar _pipeline = require(\"../pipeline\");\n\nvar _util = _interopRequireDefault(require(\"../base/util\"));\n/**\n *  Copyright (c) 2016-2017, The Regents of the University of California,\n *  through Lawrence Berkeley National Laboratory (subject to receipt\n *  of any required approvals from the U.S. Dept. of Energy).\n *  All rights reserved.\n *\n *  This source code is licensed under the BSD-style license found in the\n *  LICENSE file in the root directory of this source tree.\n */\n\n/*eslint no-console: 0 */\n\n/**\n * A processor to align the data into bins of regular time period.\n */\n\n\nclass Aligner extends _processor.default {\n  constructor(arg1, options) {\n    super(arg1, options);\n\n    if (arg1 instanceof Aligner) {\n      var other = arg1;\n      this._fieldSpec = other._fieldSpec;\n      this._window = other._window;\n      this._method = other._method;\n      this._limit = other._limit;\n    } else if ((0, _pipeline.isPipeline)(arg1)) {\n      var {\n        fieldSpec,\n        window,\n        method = \"hold\",\n        limit = null\n      } = options;\n      this._fieldSpec = fieldSpec;\n      this._window = window;\n      this._method = method;\n      this._limit = limit;\n    } else {\n      throw new Error(\"Unknown arg to Aligner constructor\", arg1);\n    } //\n    // Internal members\n    //\n\n\n    this._previous = null; // work out field specs\n\n    if (_underscore.default.isString(this._fieldSpec)) {\n      this._fieldSpec = [this._fieldSpec];\n    } // check input of method\n\n\n    if (!_underscore.default.contains([\"linear\", \"hold\"], this._method)) {\n      throw new Error(\"Unknown method '\".concat(this._method, \"' passed to Aligner\"));\n    } // check limit\n\n\n    if (this._limit && !Number.isInteger(this._limit)) {\n      throw new Error(\"Limit passed to Aligner is not an integer\");\n    }\n  }\n\n  clone() {\n    return new Aligner(this);\n  }\n  /**\n   * Test to see if an event is perfectly aligned. Used on first event.\n   */\n\n\n  isAligned(event) {\n    var bound = _index.default.getIndexString(this._window, event.timestamp());\n\n    return this.getBoundaryTime(bound) === event.timestamp().getTime();\n  }\n  /**\n   * Returns a list of indexes of window boundaries if the current\n   * event and the previous event do not lie in the same window. If\n   * they are in the same window, return an empty list.\n   */\n\n\n  getBoundaries(event) {\n    var prevIndex = _index.default.getIndexString(this._window, this._previous.timestamp());\n\n    var currentIndex = _index.default.getIndexString(this._window, event.timestamp());\n\n    if (prevIndex !== currentIndex) {\n      var range = new _timerange.default(this._previous.timestamp(), event.timestamp());\n      return _index.default.getIndexStringList(this._window, range).slice(1);\n    } else {\n      return [];\n    }\n  }\n  /**\n   * We are dealing in UTC only with the Index because the events\n   * all have internal timestamps in UTC and that's what we're\n   * aligning. Let the user display in local time if that's\n   * what they want.\n   */\n\n\n  getBoundaryTime(boundaryIndex) {\n    var index = new _index.default(boundaryIndex);\n    return index.begin().getTime();\n  }\n  /**\n   * Generate a new event on the requested boundary and carry over the\n   * value from the previous event.\n   *\n   * A variation just sets the values to null, this is used when the\n   * limit is hit.\n   */\n\n\n  interpolateHold(boundary) {\n    var setNone = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : false;\n    var d = new _immutable.default.Map();\n    var t = this.getBoundaryTime(boundary);\n\n    this._fieldSpec.forEach(path => {\n      var fieldPath = _util.default.fieldPathToArray(path);\n\n      if (!setNone) {\n        d = d.setIn(fieldPath, this._previous.get(fieldPath));\n      } else {\n        d = d.setIn(fieldPath, null);\n      }\n    });\n\n    return new _timeevent.default(t, d);\n  }\n  /**\n    * Generate a linear differential between two counter values that lie\n    * on either side of a window boundary.\n    */\n\n\n  interpolateLinear(boundary, event) {\n    var d = new _immutable.default.Map();\n\n    var previousTime = this._previous.timestamp().getTime();\n\n    var boundaryTime = this.getBoundaryTime(boundary);\n    var currentTime = event.timestamp().getTime(); // This ratio will be the same for all values being processed\n\n    var f = (boundaryTime - previousTime) / (currentTime - previousTime);\n\n    this._fieldSpec.forEach(path => {\n      var fieldPath = _util.default.fieldPathToArray(path); //\n      // Generate the delta beteen the values and\n      // bulletproof against non-numeric or bad paths\n      //\n\n\n      var previousVal = this._previous.get(fieldPath);\n\n      var currentVal = event.get(fieldPath);\n      var interpolatedVal = null;\n\n      if (!_underscore.default.isNumber(previousVal) || !_underscore.default.isNumber(currentVal)) {\n        console.warn(\"Path \".concat(fieldPath, \" contains a non-numeric value or does not exist\"));\n      } else {\n        interpolatedVal = previousVal + f * (currentVal - previousVal);\n      }\n\n      d = d.setIn(fieldPath, interpolatedVal);\n    });\n\n    return new _timeevent.default(boundaryTime, d);\n  }\n  /**\n   * Perform the fill operation on the event and emit.\n   */\n\n\n  addEvent(event) {\n    if (event instanceof _timerangeevent.default || event instanceof _indexedevent.default) {\n      throw new Error(\"TimeRangeEvent and IndexedEvent series can not be aligned.\");\n    }\n\n    if (this.hasObservers()) {\n      if (!this._previous) {\n        this._previous = event;\n\n        if (this.isAligned(event)) {\n          this.emit(event);\n        }\n\n        return;\n      }\n\n      var boundaries = this.getBoundaries(event); //\n      // If the returned list is not empty, interpolate an event\n      // on each of the boundaries and emit them\n      //\n\n      var count = boundaries.length;\n      boundaries.forEach(boundary => {\n        var outputEvent;\n\n        if (this._limit && count > this._limit) {\n          outputEvent = this.interpolateHold(boundary, true);\n        } else {\n          if (this._method === \"linear\") {\n            outputEvent = this.interpolateLinear(boundary, event);\n          } else {\n            outputEvent = this.interpolateHold(boundary);\n          }\n        }\n\n        this.emit(outputEvent);\n      }); //\n      // The current event now becomes the previous event\n      //\n\n      this._previous = event;\n    }\n  }\n\n}\n\nexports.default = Aligner;","map":{"version":3,"sources":["/Users/nicholasraffone/Documents/swefall2021/finalproj/FinancialSentiment/fin_sentiment_front/node_modules/pondjs/lib/lib/processors/aligner.js"],"names":["_interopRequireDefault","require","Object","defineProperty","exports","value","default","_underscore","_immutable","_index","_indexedevent","_processor","_timeevent","_timerange","_timerangeevent","_pipeline","_util","Aligner","constructor","arg1","options","other","_fieldSpec","_window","_method","_limit","isPipeline","fieldSpec","window","method","limit","Error","_previous","isString","contains","concat","Number","isInteger","clone","isAligned","event","bound","getIndexString","timestamp","getBoundaryTime","getTime","getBoundaries","prevIndex","currentIndex","range","getIndexStringList","slice","boundaryIndex","index","begin","interpolateHold","boundary","setNone","arguments","length","undefined","d","Map","t","forEach","path","fieldPath","fieldPathToArray","setIn","get","interpolateLinear","previousTime","boundaryTime","currentTime","f","previousVal","currentVal","interpolatedVal","isNumber","console","warn","addEvent","hasObservers","emit","boundaries","count","outputEvent"],"mappings":"AAAA;;AAEA,IAAIA,sBAAsB,GAAGC,OAAO,CAAC,8CAAD,CAApC;;AAEAC,MAAM,CAACC,cAAP,CAAsBC,OAAtB,EAA+B,YAA/B,EAA6C;AAC3CC,EAAAA,KAAK,EAAE;AADoC,CAA7C;AAGAD,OAAO,CAACE,OAAR,GAAkB,KAAK,CAAvB;;AAEA,IAAIC,WAAW,GAAGP,sBAAsB,CAACC,OAAO,CAAC,YAAD,CAAR,CAAxC;;AAEA,IAAIO,UAAU,GAAGR,sBAAsB,CAACC,OAAO,CAAC,WAAD,CAAR,CAAvC;;AAEA,IAAIQ,MAAM,GAAGT,sBAAsB,CAACC,OAAO,CAAC,UAAD,CAAR,CAAnC;;AAEA,IAAIS,aAAa,GAAGV,sBAAsB,CAACC,OAAO,CAAC,iBAAD,CAAR,CAA1C;;AAEA,IAAIU,UAAU,GAAGX,sBAAsB,CAACC,OAAO,CAAC,aAAD,CAAR,CAAvC;;AAEA,IAAIW,UAAU,GAAGZ,sBAAsB,CAACC,OAAO,CAAC,cAAD,CAAR,CAAvC;;AAEA,IAAIY,UAAU,GAAGb,sBAAsB,CAACC,OAAO,CAAC,cAAD,CAAR,CAAvC;;AAEA,IAAIa,eAAe,GAAGd,sBAAsB,CAACC,OAAO,CAAC,mBAAD,CAAR,CAA5C;;AAEA,IAAIc,SAAS,GAAGd,OAAO,CAAC,aAAD,CAAvB;;AAEA,IAAIe,KAAK,GAAGhB,sBAAsB,CAACC,OAAO,CAAC,cAAD,CAAR,CAAlC;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;;AAEA;AACA;AACA;;;AACA,MAAMgB,OAAN,SAAsBN,UAAU,CAACL,OAAjC,CAAyC;AACvCY,EAAAA,WAAW,CAACC,IAAD,EAAOC,OAAP,EAAgB;AACzB,UAAMD,IAAN,EAAYC,OAAZ;;AAEA,QAAID,IAAI,YAAYF,OAApB,EAA6B;AAC3B,UAAII,KAAK,GAAGF,IAAZ;AACA,WAAKG,UAAL,GAAkBD,KAAK,CAACC,UAAxB;AACA,WAAKC,OAAL,GAAeF,KAAK,CAACE,OAArB;AACA,WAAKC,OAAL,GAAeH,KAAK,CAACG,OAArB;AACA,WAAKC,MAAL,GAAcJ,KAAK,CAACI,MAApB;AACD,KAND,MAMO,IAAI,CAAC,GAAGV,SAAS,CAACW,UAAd,EAA0BP,IAA1B,CAAJ,EAAqC;AAC1C,UAAI;AACFQ,QAAAA,SADE;AAEFC,QAAAA,MAFE;AAGFC,QAAAA,MAAM,GAAG,MAHP;AAIFC,QAAAA,KAAK,GAAG;AAJN,UAKAV,OALJ;AAMA,WAAKE,UAAL,GAAkBK,SAAlB;AACA,WAAKJ,OAAL,GAAeK,MAAf;AACA,WAAKJ,OAAL,GAAeK,MAAf;AACA,WAAKJ,MAAL,GAAcK,KAAd;AACD,KAXM,MAWA;AACL,YAAM,IAAIC,KAAJ,CAAU,oCAAV,EAAgDZ,IAAhD,CAAN;AACD,KAtBwB,CAsBvB;AACF;AACA;;;AAGA,SAAKa,SAAL,GAAiB,IAAjB,CA3ByB,CA2BF;;AAEvB,QAAIzB,WAAW,CAACD,OAAZ,CAAoB2B,QAApB,CAA6B,KAAKX,UAAlC,CAAJ,EAAmD;AACjD,WAAKA,UAAL,GAAkB,CAAC,KAAKA,UAAN,CAAlB;AACD,KA/BwB,CA+BvB;;;AAGF,QAAI,CAACf,WAAW,CAACD,OAAZ,CAAoB4B,QAApB,CAA6B,CAAC,QAAD,EAAW,MAAX,CAA7B,EAAiD,KAAKV,OAAtD,CAAL,EAAqE;AACnE,YAAM,IAAIO,KAAJ,CAAU,mBAAmBI,MAAnB,CAA0B,KAAKX,OAA/B,EAAwC,qBAAxC,CAAV,CAAN;AACD,KApCwB,CAoCvB;;;AAGF,QAAI,KAAKC,MAAL,IAAe,CAACW,MAAM,CAACC,SAAP,CAAiB,KAAKZ,MAAtB,CAApB,EAAmD;AACjD,YAAM,IAAIM,KAAJ,CAAU,2CAAV,CAAN;AACD;AACF;;AAEDO,EAAAA,KAAK,GAAG;AACN,WAAO,IAAIrB,OAAJ,CAAY,IAAZ,CAAP;AACD;AACD;AACF;AACA;;;AAGEsB,EAAAA,SAAS,CAACC,KAAD,EAAQ;AACf,QAAIC,KAAK,GAAGhC,MAAM,CAACH,OAAP,CAAeoC,cAAf,CAA8B,KAAKnB,OAAnC,EAA4CiB,KAAK,CAACG,SAAN,EAA5C,CAAZ;;AAEA,WAAO,KAAKC,eAAL,CAAqBH,KAArB,MAAgCD,KAAK,CAACG,SAAN,GAAkBE,OAAlB,EAAvC;AACD;AACD;AACF;AACA;AACA;AACA;;;AAGEC,EAAAA,aAAa,CAACN,KAAD,EAAQ;AACnB,QAAIO,SAAS,GAAGtC,MAAM,CAACH,OAAP,CAAeoC,cAAf,CAA8B,KAAKnB,OAAnC,EAA4C,KAAKS,SAAL,CAAeW,SAAf,EAA5C,CAAhB;;AAEA,QAAIK,YAAY,GAAGvC,MAAM,CAACH,OAAP,CAAeoC,cAAf,CAA8B,KAAKnB,OAAnC,EAA4CiB,KAAK,CAACG,SAAN,EAA5C,CAAnB;;AAEA,QAAII,SAAS,KAAKC,YAAlB,EAAgC;AAC9B,UAAIC,KAAK,GAAG,IAAIpC,UAAU,CAACP,OAAf,CAAuB,KAAK0B,SAAL,CAAeW,SAAf,EAAvB,EAAmDH,KAAK,CAACG,SAAN,EAAnD,CAAZ;AACA,aAAOlC,MAAM,CAACH,OAAP,CAAe4C,kBAAf,CAAkC,KAAK3B,OAAvC,EAAgD0B,KAAhD,EAAuDE,KAAvD,CAA6D,CAA7D,CAAP;AACD,KAHD,MAGO;AACL,aAAO,EAAP;AACD;AACF;AACD;AACF;AACA;AACA;AACA;AACA;;;AAGEP,EAAAA,eAAe,CAACQ,aAAD,EAAgB;AAC7B,QAAIC,KAAK,GAAG,IAAI5C,MAAM,CAACH,OAAX,CAAmB8C,aAAnB,CAAZ;AACA,WAAOC,KAAK,CAACC,KAAN,GAAcT,OAAd,EAAP;AACD;AACD;AACF;AACA;AACA;AACA;AACA;AACA;;;AAGEU,EAAAA,eAAe,CAACC,QAAD,EAAW;AACxB,QAAIC,OAAO,GAAGC,SAAS,CAACC,MAAV,GAAmB,CAAnB,IAAwBD,SAAS,CAAC,CAAD,CAAT,KAAiBE,SAAzC,GAAqDF,SAAS,CAAC,CAAD,CAA9D,GAAoE,KAAlF;AACA,QAAIG,CAAC,GAAG,IAAIrD,UAAU,CAACF,OAAX,CAAmBwD,GAAvB,EAAR;AACA,QAAIC,CAAC,GAAG,KAAKnB,eAAL,CAAqBY,QAArB,CAAR;;AAEA,SAAKlC,UAAL,CAAgB0C,OAAhB,CAAwBC,IAAI,IAAI;AAC9B,UAAIC,SAAS,GAAGlD,KAAK,CAACV,OAAN,CAAc6D,gBAAd,CAA+BF,IAA/B,CAAhB;;AAEA,UAAI,CAACR,OAAL,EAAc;AACZI,QAAAA,CAAC,GAAGA,CAAC,CAACO,KAAF,CAAQF,SAAR,EAAmB,KAAKlC,SAAL,CAAeqC,GAAf,CAAmBH,SAAnB,CAAnB,CAAJ;AACD,OAFD,MAEO;AACLL,QAAAA,CAAC,GAAGA,CAAC,CAACO,KAAF,CAAQF,SAAR,EAAmB,IAAnB,CAAJ;AACD;AACF,KARD;;AAUA,WAAO,IAAItD,UAAU,CAACN,OAAf,CAAuByD,CAAvB,EAA0BF,CAA1B,CAAP;AACD;AACD;AACF;AACA;AACA;;;AAGES,EAAAA,iBAAiB,CAACd,QAAD,EAAWhB,KAAX,EAAkB;AACjC,QAAIqB,CAAC,GAAG,IAAIrD,UAAU,CAACF,OAAX,CAAmBwD,GAAvB,EAAR;;AAEA,QAAIS,YAAY,GAAG,KAAKvC,SAAL,CAAeW,SAAf,GAA2BE,OAA3B,EAAnB;;AAEA,QAAI2B,YAAY,GAAG,KAAK5B,eAAL,CAAqBY,QAArB,CAAnB;AACA,QAAIiB,WAAW,GAAGjC,KAAK,CAACG,SAAN,GAAkBE,OAAlB,EAAlB,CANiC,CAMc;;AAE/C,QAAI6B,CAAC,GAAG,CAACF,YAAY,GAAGD,YAAhB,KAAiCE,WAAW,GAAGF,YAA/C,CAAR;;AAEA,SAAKjD,UAAL,CAAgB0C,OAAhB,CAAwBC,IAAI,IAAI;AAC9B,UAAIC,SAAS,GAAGlD,KAAK,CAACV,OAAN,CAAc6D,gBAAd,CAA+BF,IAA/B,CAAhB,CAD8B,CACwB;AACtD;AACA;AACA;;;AAGA,UAAIU,WAAW,GAAG,KAAK3C,SAAL,CAAeqC,GAAf,CAAmBH,SAAnB,CAAlB;;AAEA,UAAIU,UAAU,GAAGpC,KAAK,CAAC6B,GAAN,CAAUH,SAAV,CAAjB;AACA,UAAIW,eAAe,GAAG,IAAtB;;AAEA,UAAI,CAACtE,WAAW,CAACD,OAAZ,CAAoBwE,QAApB,CAA6BH,WAA7B,CAAD,IAA8C,CAACpE,WAAW,CAACD,OAAZ,CAAoBwE,QAApB,CAA6BF,UAA7B,CAAnD,EAA6F;AAC3FG,QAAAA,OAAO,CAACC,IAAR,CAAa,QAAQ7C,MAAR,CAAe+B,SAAf,EAA0B,iDAA1B,CAAb;AACD,OAFD,MAEO;AACLW,QAAAA,eAAe,GAAGF,WAAW,GAAGD,CAAC,IAAIE,UAAU,GAAGD,WAAjB,CAAjC;AACD;;AAEDd,MAAAA,CAAC,GAAGA,CAAC,CAACO,KAAF,CAAQF,SAAR,EAAmBW,eAAnB,CAAJ;AACD,KAnBD;;AAqBA,WAAO,IAAIjE,UAAU,CAACN,OAAf,CAAuBkE,YAAvB,EAAqCX,CAArC,CAAP;AACD;AACD;AACF;AACA;;;AAGEoB,EAAAA,QAAQ,CAACzC,KAAD,EAAQ;AACd,QAAIA,KAAK,YAAY1B,eAAe,CAACR,OAAjC,IAA4CkC,KAAK,YAAY9B,aAAa,CAACJ,OAA/E,EAAwF;AACtF,YAAM,IAAIyB,KAAJ,CAAU,4DAAV,CAAN;AACD;;AAED,QAAI,KAAKmD,YAAL,EAAJ,EAAyB;AACvB,UAAI,CAAC,KAAKlD,SAAV,EAAqB;AACnB,aAAKA,SAAL,GAAiBQ,KAAjB;;AAEA,YAAI,KAAKD,SAAL,CAAeC,KAAf,CAAJ,EAA2B;AACzB,eAAK2C,IAAL,CAAU3C,KAAV;AACD;;AAED;AACD;;AAED,UAAI4C,UAAU,GAAG,KAAKtC,aAAL,CAAmBN,KAAnB,CAAjB,CAXuB,CAWqB;AAC5C;AACA;AACA;;AAEA,UAAI6C,KAAK,GAAGD,UAAU,CAACzB,MAAvB;AACAyB,MAAAA,UAAU,CAACpB,OAAX,CAAmBR,QAAQ,IAAI;AAC7B,YAAI8B,WAAJ;;AAEA,YAAI,KAAK7D,MAAL,IAAe4D,KAAK,GAAG,KAAK5D,MAAhC,EAAwC;AACtC6D,UAAAA,WAAW,GAAG,KAAK/B,eAAL,CAAqBC,QAArB,EAA+B,IAA/B,CAAd;AACD,SAFD,MAEO;AACL,cAAI,KAAKhC,OAAL,KAAiB,QAArB,EAA+B;AAC7B8D,YAAAA,WAAW,GAAG,KAAKhB,iBAAL,CAAuBd,QAAvB,EAAiChB,KAAjC,CAAd;AACD,WAFD,MAEO;AACL8C,YAAAA,WAAW,GAAG,KAAK/B,eAAL,CAAqBC,QAArB,CAAd;AACD;AACF;;AAED,aAAK2B,IAAL,CAAUG,WAAV;AACD,OAdD,EAjBuB,CA+BnB;AACJ;AACA;;AAEA,WAAKtD,SAAL,GAAiBQ,KAAjB;AACD;AACF;;AAzMsC;;AA6MzCpC,OAAO,CAACE,OAAR,GAAkBW,OAAlB","sourcesContent":["\"use strict\";\n\nvar _interopRequireDefault = require(\"@babel/runtime/helpers/interopRequireDefault\");\n\nObject.defineProperty(exports, \"__esModule\", {\n  value: true\n});\nexports.default = void 0;\n\nvar _underscore = _interopRequireDefault(require(\"underscore\"));\n\nvar _immutable = _interopRequireDefault(require(\"immutable\"));\n\nvar _index = _interopRequireDefault(require(\"../index\"));\n\nvar _indexedevent = _interopRequireDefault(require(\"../indexedevent\"));\n\nvar _processor = _interopRequireDefault(require(\"./processor\"));\n\nvar _timeevent = _interopRequireDefault(require(\"../timeevent\"));\n\nvar _timerange = _interopRequireDefault(require(\"../timerange\"));\n\nvar _timerangeevent = _interopRequireDefault(require(\"../timerangeevent\"));\n\nvar _pipeline = require(\"../pipeline\");\n\nvar _util = _interopRequireDefault(require(\"../base/util\"));\n\n/**\n *  Copyright (c) 2016-2017, The Regents of the University of California,\n *  through Lawrence Berkeley National Laboratory (subject to receipt\n *  of any required approvals from the U.S. Dept. of Energy).\n *  All rights reserved.\n *\n *  This source code is licensed under the BSD-style license found in the\n *  LICENSE file in the root directory of this source tree.\n */\n\n/*eslint no-console: 0 */\n\n/**\n * A processor to align the data into bins of regular time period.\n */\nclass Aligner extends _processor.default {\n  constructor(arg1, options) {\n    super(arg1, options);\n\n    if (arg1 instanceof Aligner) {\n      var other = arg1;\n      this._fieldSpec = other._fieldSpec;\n      this._window = other._window;\n      this._method = other._method;\n      this._limit = other._limit;\n    } else if ((0, _pipeline.isPipeline)(arg1)) {\n      var {\n        fieldSpec,\n        window,\n        method = \"hold\",\n        limit = null\n      } = options;\n      this._fieldSpec = fieldSpec;\n      this._window = window;\n      this._method = method;\n      this._limit = limit;\n    } else {\n      throw new Error(\"Unknown arg to Aligner constructor\", arg1);\n    } //\n    // Internal members\n    //\n\n\n    this._previous = null; // work out field specs\n\n    if (_underscore.default.isString(this._fieldSpec)) {\n      this._fieldSpec = [this._fieldSpec];\n    } // check input of method\n\n\n    if (!_underscore.default.contains([\"linear\", \"hold\"], this._method)) {\n      throw new Error(\"Unknown method '\".concat(this._method, \"' passed to Aligner\"));\n    } // check limit\n\n\n    if (this._limit && !Number.isInteger(this._limit)) {\n      throw new Error(\"Limit passed to Aligner is not an integer\");\n    }\n  }\n\n  clone() {\n    return new Aligner(this);\n  }\n  /**\n   * Test to see if an event is perfectly aligned. Used on first event.\n   */\n\n\n  isAligned(event) {\n    var bound = _index.default.getIndexString(this._window, event.timestamp());\n\n    return this.getBoundaryTime(bound) === event.timestamp().getTime();\n  }\n  /**\n   * Returns a list of indexes of window boundaries if the current\n   * event and the previous event do not lie in the same window. If\n   * they are in the same window, return an empty list.\n   */\n\n\n  getBoundaries(event) {\n    var prevIndex = _index.default.getIndexString(this._window, this._previous.timestamp());\n\n    var currentIndex = _index.default.getIndexString(this._window, event.timestamp());\n\n    if (prevIndex !== currentIndex) {\n      var range = new _timerange.default(this._previous.timestamp(), event.timestamp());\n      return _index.default.getIndexStringList(this._window, range).slice(1);\n    } else {\n      return [];\n    }\n  }\n  /**\n   * We are dealing in UTC only with the Index because the events\n   * all have internal timestamps in UTC and that's what we're\n   * aligning. Let the user display in local time if that's\n   * what they want.\n   */\n\n\n  getBoundaryTime(boundaryIndex) {\n    var index = new _index.default(boundaryIndex);\n    return index.begin().getTime();\n  }\n  /**\n   * Generate a new event on the requested boundary and carry over the\n   * value from the previous event.\n   *\n   * A variation just sets the values to null, this is used when the\n   * limit is hit.\n   */\n\n\n  interpolateHold(boundary) {\n    var setNone = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : false;\n    var d = new _immutable.default.Map();\n    var t = this.getBoundaryTime(boundary);\n\n    this._fieldSpec.forEach(path => {\n      var fieldPath = _util.default.fieldPathToArray(path);\n\n      if (!setNone) {\n        d = d.setIn(fieldPath, this._previous.get(fieldPath));\n      } else {\n        d = d.setIn(fieldPath, null);\n      }\n    });\n\n    return new _timeevent.default(t, d);\n  }\n  /**\n    * Generate a linear differential between two counter values that lie\n    * on either side of a window boundary.\n    */\n\n\n  interpolateLinear(boundary, event) {\n    var d = new _immutable.default.Map();\n\n    var previousTime = this._previous.timestamp().getTime();\n\n    var boundaryTime = this.getBoundaryTime(boundary);\n    var currentTime = event.timestamp().getTime(); // This ratio will be the same for all values being processed\n\n    var f = (boundaryTime - previousTime) / (currentTime - previousTime);\n\n    this._fieldSpec.forEach(path => {\n      var fieldPath = _util.default.fieldPathToArray(path); //\n      // Generate the delta beteen the values and\n      // bulletproof against non-numeric or bad paths\n      //\n\n\n      var previousVal = this._previous.get(fieldPath);\n\n      var currentVal = event.get(fieldPath);\n      var interpolatedVal = null;\n\n      if (!_underscore.default.isNumber(previousVal) || !_underscore.default.isNumber(currentVal)) {\n        console.warn(\"Path \".concat(fieldPath, \" contains a non-numeric value or does not exist\"));\n      } else {\n        interpolatedVal = previousVal + f * (currentVal - previousVal);\n      }\n\n      d = d.setIn(fieldPath, interpolatedVal);\n    });\n\n    return new _timeevent.default(boundaryTime, d);\n  }\n  /**\n   * Perform the fill operation on the event and emit.\n   */\n\n\n  addEvent(event) {\n    if (event instanceof _timerangeevent.default || event instanceof _indexedevent.default) {\n      throw new Error(\"TimeRangeEvent and IndexedEvent series can not be aligned.\");\n    }\n\n    if (this.hasObservers()) {\n      if (!this._previous) {\n        this._previous = event;\n\n        if (this.isAligned(event)) {\n          this.emit(event);\n        }\n\n        return;\n      }\n\n      var boundaries = this.getBoundaries(event); //\n      // If the returned list is not empty, interpolate an event\n      // on each of the boundaries and emit them\n      //\n\n      var count = boundaries.length;\n      boundaries.forEach(boundary => {\n        var outputEvent;\n\n        if (this._limit && count > this._limit) {\n          outputEvent = this.interpolateHold(boundary, true);\n        } else {\n          if (this._method === \"linear\") {\n            outputEvent = this.interpolateLinear(boundary, event);\n          } else {\n            outputEvent = this.interpolateHold(boundary);\n          }\n        }\n\n        this.emit(outputEvent);\n      }); //\n      // The current event now becomes the previous event\n      //\n\n      this._previous = event;\n    }\n  }\n\n}\n\nexports.default = Aligner;"]},"metadata":{},"sourceType":"script"}